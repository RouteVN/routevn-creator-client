(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb2, mod) => function __require() {
    return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i3 = isLE ? nBytes - 1 : 0;
        var d2 = isLE ? -1 : 1;
        var s = buffer[offset + i3];
        i3 += d2;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i3], i3 += d2, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i3], i3 += d2, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt3 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i3 = isLE ? 0 : nBytes - 1;
        var d2 = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt3 / c;
          } else {
            value += rt3 * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i3] = m & 255, i3 += d2, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i3] = e & 255, i3 += d2, e /= 256, eLen -= 8) {
        }
        buffer[offset + i3 - d2] |= s * 128;
      };
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d2 = h * 24;
      var w = d2 * 7;
      var y = d2 * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type2 = typeof val;
        if (type2 === "string" && val.length > 0) {
          return parse(val);
        } else if (type2 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str2) {
        str2 = String(str2);
        if (str2.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str2
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type2 = (match[2] || "ms").toLowerCase();
        switch (type2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d2;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d2) {
          return Math.round(ms2 / d2) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms2 / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms2 / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms2 / s) + "s";
        }
        return ms2 + "ms";
      }
      function fmtLong(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d2) {
          return plural(ms2, msAbs, d2, "day");
        }
        if (msAbs >= h) {
          return plural(ms2, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms2, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms2, msAbs, s, "second");
        }
        return ms2 + " ms";
      }
      function plural(ms2, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports, module) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i3 = 0; i3 < namespace.length; i3++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i3);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug2(...args) {
            if (!debug2.enabled) {
              return;
            }
            const self2 = debug2;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms2 = curr - (prevTime || curr);
            self2.diff = ms2;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug2.namespace = namespace;
          debug2.useColors = createDebug.useColors();
          debug2.color = createDebug.selectColor(namespace);
          debug2.extend = extend3;
          debug2.destroy = createDebug.destroy;
          Object.defineProperty(debug2, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          return debug2;
        }
        function extend3(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
          for (const ns2 of split) {
            if (ns2[0] === "-") {
              createDebug.skips.push(ns2.slice(1));
            } else {
              createDebug.names.push(ns2);
            }
          }
        }
        function matchesTemplate(search, template) {
          let searchIndex = 0;
          let templateIndex = 0;
          let starIndex = -1;
          let matchIndex = 0;
          while (searchIndex < search.length) {
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
              if (template[templateIndex] === "*") {
                starIndex = templateIndex;
                matchIndex = searchIndex;
                templateIndex++;
              } else {
                searchIndex++;
                templateIndex++;
              }
            } else if (starIndex !== -1) {
              templateIndex = starIndex + 1;
              matchIndex++;
              searchIndex = matchIndex;
            } else {
              return false;
            }
          }
          while (templateIndex < template.length && template[templateIndex] === "*") {
            templateIndex++;
          }
          return templateIndex === template.length;
        }
        function disable() {
          const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          for (const skip of createDebug.skips) {
            if (matchesTemplate(name, skip)) {
              return false;
            }
          }
          for (const ns2 of createDebug.names) {
            if (matchesTemplate(name, ns2)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "node_modules/debug/src/browser.js"(exports, module) {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load2;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load2() {
        let r;
        try {
          r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/js-yaml/dist/js-yaml.mjs
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  var isNothing_1 = isNothing;
  var isObject_1 = isObject;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend;
  var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark) return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException$1(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;
  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  var exception = YAMLException$1;
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string, max2) {
    return common.repeat(" ", max2 - string.length) + string;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re2 = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re2.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i3, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i3 = 1; i3 <= options.linesBefore; i3++) {
      if (foundLineNo - i3 < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i3],
        lineEnds[foundLineNo - i3],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i3]),
        maxLineLength
      );
      result = common.repeat(" ", options.indent) + padStart((mark.line - i3 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i3 = 1; i3 <= options.linesAfter; i3++) {
      if (foundLineNo + i3 >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i3],
        lineEnds[foundLineNo + i3],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i3]),
        maxLineLength
      );
      result += common.repeat(" ", options.indent) + padStart((mark.line + i3 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  var snippet = makeSnippet;
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style) {
        map2[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var type = Type$1;
  function compileList(schema2, name) {
    var result = [];
    schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema$1(definition) {
    return this.extend(definition);
  }
  Schema$1.prototype.extend = function extend2(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type$1.loadKind && type$1.loadKind !== "scalar") {
        throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type$1.multi) {
        throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  var schema = Schema$1;
  var str = new type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  var seq = new type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  var map = new type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });
  function resolveYamlNull(data) {
    if (data === null) return true;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var _null = new type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var bool = new type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max2 = data.length, index = 0, hasDigits = false, ch2;
    if (!max2) return false;
    ch2 = data[index];
    if (ch2 === "-" || ch2 === "+") {
      ch2 = data[++index];
    }
    if (ch2 === "0") {
      if (index + 1 === max2) return true;
      ch2 = data[++index];
      if (ch2 === "b") {
        index++;
        for (; index < max2; index++) {
          ch2 = data[index];
          if (ch2 === "_") continue;
          if (ch2 !== "0" && ch2 !== "1") return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
      if (ch2 === "x") {
        index++;
        for (; index < max2; index++) {
          ch2 = data[index];
          if (ch2 === "_") continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
      if (ch2 === "o") {
        index++;
        for (; index < max2; index++) {
          ch2 = data[index];
          if (ch2 === "_") continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
    }
    if (ch2 === "_") return false;
    for (; index < max2; index++) {
      ch2 = data[index];
      if (ch2 === "_") continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch2 === "_") return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch2;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch2 = value[0];
    if (ch2 === "-" || ch2 === "+") {
      if (ch2 === "-") sign = -1;
      value = value.slice(1);
      ch2 = value[0];
    }
    if (value === "0") return 0;
    if (ch2 === "0") {
      if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  var int = new type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  var float = new type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });
  var core = json;
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp = new type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  var merge = new type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      code = map2.indexOf(data.charAt(idx));
      if (code > 64) continue;
      if (code < 0) return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map2 = BASE64_MAP, bits2 = 0, result = [];
    for (idx = 0; idx < max2; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits2 >> 16 & 255);
        result.push(bits2 >> 8 & 255);
        result.push(bits2 & 255);
      }
      bits2 = bits2 << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max2 % 4 * 6;
    if (tailbits === 0) {
      result.push(bits2 >> 16 & 255);
      result.push(bits2 >> 8 & 255);
      result.push(bits2 & 255);
    } else if (tailbits === 18) {
      result.push(bits2 >> 10 & 255);
      result.push(bits2 >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits2 >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits2 = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits2 >> 18 & 63];
        result += map2[bits2 >> 12 & 63];
        result += map2[bits2 >> 6 & 63];
        result += map2[bits2 & 63];
      }
      bits2 = (bits2 << 8) + object[idx];
    }
    tail = max2 % 3;
    if (tail === 0) {
      result += map2[bits2 >> 18 & 63];
      result += map2[bits2 >> 12 & 63];
      result += map2[bits2 >> 6 & 63];
      result += map2[bits2 & 63];
    } else if (tail === 2) {
      result += map2[bits2 >> 10 & 63];
      result += map2[bits2 >> 4 & 63];
      result += map2[bits2 << 2 & 63];
      result += map2[64];
    } else if (tail === 1) {
      result += map2[bits2 >> 2 & 63];
      result += map2[bits2 << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  var binary = new type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString$2.call(pair) !== "[object Object]") return false;
      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }
      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var omap = new type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString$1.call(pair) !== "[object Object]") return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  var pairs = new type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var set = new type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc2;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc2 = c | 32;
    if (97 <= lc2 && lc2 <= 102) {
      return lc2 - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode(
      (c - 65536 >> 10) + 55296,
      (c - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i3 = 0; i3 < 256; i3++) {
    simpleEscapeCheck[i3] = simpleEscapeSequence(i3) ? 1 : 0;
    simpleEscapeMap[i3] = simpleEscapeSequence(i3);
  }
  var i3;
  function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || _default;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err2) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 10) {
      state.position++;
    } else if (ch2 === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch2 = state.input.charCodeAt(state.position);
    while (ch2 !== 0) {
      while (is_WHITE_SPACE(ch2)) {
        if (ch2 === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch2 = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch2 === 35) {
        do {
          ch2 = state.input.charCodeAt(++state.position);
        } while (ch2 !== 10 && ch2 !== 13 && ch2 !== 0);
      }
      if (is_EOL(ch2)) {
        readLineBreak(state);
        ch2 = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch2 === 32) {
          state.lineIndent++;
          ch2 = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch2;
    ch2 = state.input.charCodeAt(_position);
    if ((ch2 === 45 || ch2 === 46) && ch2 === state.input.charCodeAt(_position + 1) && ch2 === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch2 = state.input.charCodeAt(_position);
      if (ch2 === 0 || is_WS_OR_EOL(ch2)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch2) || is_FLOW_INDICATOR(ch2) || ch2 === 35 || ch2 === 38 || ch2 === 42 || ch2 === 33 || ch2 === 124 || ch2 === 62 || ch2 === 39 || ch2 === 34 || ch2 === 37 || ch2 === 64 || ch2 === 96) {
      return false;
    }
    if (ch2 === 63 || ch2 === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch2 !== 0) {
      if (ch2 === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch2 === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch2)) {
        break;
      } else if (is_EOL(ch2)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch2 = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch2)) {
        captureEnd = state.position + 1;
      }
      ch2 = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch2, captureStart, captureEnd;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
      if (ch2 === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch2 = state.input.charCodeAt(++state.position);
        if (ch2 === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch2)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
      if (ch2 === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch2 === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch2 = state.input.charCodeAt(++state.position);
        if (is_EOL(ch2)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch2 < 256 && simpleEscapeCheck[ch2]) {
          state.result += simpleEscapeMap[ch2];
          state.position++;
        } else if ((tmp = escapedHexLen(ch2)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch2 = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch2)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch2)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch2 === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch2 = state.input.charCodeAt(++state.position);
    while (ch2 !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch2 = state.input.charCodeAt(state.position);
      if (ch2 === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch2 === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch2 === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch2 = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch2 === 58) {
        isPair = true;
        ch2 = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch2 = state.input.charCodeAt(state.position);
      if (ch2 === 44) {
        readNext = true;
        ch2 = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 124) {
      folding = false;
    } else if (ch2 === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch2 !== 0) {
      ch2 = state.input.charCodeAt(++state.position);
      if (ch2 === 43 || ch2 === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch2 === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch2)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch2)) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch2));
      if (ch2 === 35) {
        do {
          ch2 = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch2) && ch2 !== 0);
      }
    }
    while (ch2 !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch2 = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch2 === 32) {
        state.lineIndent++;
        ch2 = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch2)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch2)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch2) && ch2 !== 0) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch2;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch2 = state.input.charCodeAt(state.position);
    while (ch2 !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch2 !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch2 = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch2 = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch2 !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch2;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch2 = state.input.charCodeAt(state.position);
    while (ch2 !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch2 === 63 || ch2 === 58) && is_WS_OR_EOL(following)) {
        if (ch2 === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch2 = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch2 = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch2)) {
            ch2 = state.input.charCodeAt(++state.position);
          }
          if (ch2 === 58) {
            ch2 = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch2)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch2 = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch2 !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 33) return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch2 = state.input.charCodeAt(++state.position);
    if (ch2 === 60) {
      isVerbatim = true;
      ch2 = state.input.charCodeAt(++state.position);
    } else if (ch2 === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch2 = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (ch2 !== 0 && ch2 !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch2 = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        if (ch2 === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch2 = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err2) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 38) return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch2 = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 42) return false;
    ch2 = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch2;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = /* @__PURE__ */ Object.create(null);
    state.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch2 = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch2 !== 37) {
        break;
      }
      hasDirectives = true;
      ch2 = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch2 !== 0) {
        while (is_WHITE_SPACE(ch2)) {
          ch2 = state.input.charCodeAt(++state.position);
        }
        if (ch2 === 35) {
          do {
            ch2 = state.input.charCodeAt(++state.position);
          } while (ch2 !== 0 && !is_EOL(ch2));
          break;
        }
        if (is_EOL(ch2)) break;
        _position = state.position;
        while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
          ch2 = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch2 !== 0) readLineBreak(state);
      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception("expected a single document in the stream, but found more");
  }
  var loadAll_1 = loadAll$1;
  var load_1 = load$1;
  var loader = {
    loadAll: loadAll_1,
    load: load_1
  };
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    result = {};
    keys = Object.keys(map2);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map2[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1;
  var QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || _default;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n") result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type2 = state.implicitTypes[index];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
  }
  function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c) {
    return !isWhitespace(c) && c !== CHAR_COLON;
  }
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i3;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i3 = 0; i3 < string.length; char >= 65536 ? i3 += 2 : i3++) {
        char = codePointAt(string, i3);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i3 = 0; i3 < string.length; char >= 65536 ? i3 += 2 : i3++) {
        char = codePointAt(string, i3);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i3 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i3;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i3 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = (function() {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception("impossible error: invalid scalar style");
      }
    })();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = (function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    })();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i3 = 0; i3 < string.length; char >= 65536 ? i3 += 2 : i3++) {
      char = codePointAt(string, i3);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i3];
        if (char >= 65536) result += string[i3 + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (_result !== "") pairBuffer += ", ";
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024) pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new exception("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type2 = typeList[index];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(
          state.tag[0] === "!" ? state.tag.slice(1) : state.tag
        ).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
  }
  var dump_1 = dump$1;
  var dumper = {
    dump: dump_1
  };
  function renamed(from, to2) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to2 + " instead, which is now safe by default.");
    };
  }
  var Type = type;
  var Schema = schema;
  var FAILSAFE_SCHEMA = failsafe;
  var JSON_SCHEMA = json;
  var CORE_SCHEMA = core;
  var DEFAULT_SCHEMA = _default;
  var load = loader.load;
  var loadAll = loader.loadAll;
  var dump = dumper.dump;
  var YAMLException = exception;
  var types = {
    binary,
    float,
    map,
    null: _null,
    pairs,
    set,
    timestamp,
    bool,
    int,
    merge,
    omap,
    seq,
    str
  };
  var safeLoad = renamed("safeLoad", "load");
  var safeLoadAll = renamed("safeLoadAll", "loadAll");
  var safeDump = renamed("safeDump", "dump");
  var jsYaml = {
    Type,
    Schema,
    FAILSAFE_SCHEMA,
    JSON_SCHEMA,
    CORE_SCHEMA,
    DEFAULT_SCHEMA,
    load,
    loadAll,
    dump,
    YAMLException,
    types,
    safeLoad,
    safeLoadAll,
    safeDump
  };
  var js_yaml_default = jsYaml;

  // node_modules/token-types/lib/index.js
  var ieee754 = __toESM(require_ieee754(), 1);

  // node_modules/@borewit/text-codec/lib/index.js
  var WINDOWS_1252_EXTRA = {
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };
  var WINDOWS_1252_REVERSE = {};
  for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
  }
  function textDecode(bytes, encoding = "utf-8") {
    switch (encoding.toLowerCase()) {
      case "utf-8":
      case "utf8":
        if (typeof globalThis.TextDecoder !== "undefined") {
          return new globalThis.TextDecoder("utf-8").decode(bytes);
        }
        return decodeUTF8(bytes);
      case "utf-16le":
        return decodeUTF16LE(bytes);
      case "ascii":
        return decodeASCII(bytes);
      case "latin1":
      case "iso-8859-1":
        return decodeLatin1(bytes);
      case "windows-1252":
        return decodeWindows1252(bytes);
      default:
        throw new RangeError(`Encoding '${encoding}' not supported`);
    }
  }
  function decodeUTF8(bytes) {
    let out = "";
    let i3 = 0;
    while (i3 < bytes.length) {
      const b1 = bytes[i3++];
      if (b1 < 128) {
        out += String.fromCharCode(b1);
      } else if (b1 < 224) {
        const b2 = bytes[i3++] & 63;
        out += String.fromCharCode((b1 & 31) << 6 | b2);
      } else if (b1 < 240) {
        const b2 = bytes[i3++] & 63;
        const b3 = bytes[i3++] & 63;
        out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
      } else {
        const b2 = bytes[i3++] & 63;
        const b3 = bytes[i3++] & 63;
        const b4 = bytes[i3++] & 63;
        let cp2 = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
        cp2 -= 65536;
        out += String.fromCharCode(55296 + (cp2 >> 10 & 1023), 56320 + (cp2 & 1023));
      }
    }
    return out;
  }
  function decodeUTF16LE(bytes) {
    let out = "";
    for (let i3 = 0; i3 < bytes.length; i3 += 2) {
      out += String.fromCharCode(bytes[i3] | bytes[i3 + 1] << 8);
    }
    return out;
  }
  function decodeASCII(bytes) {
    return String.fromCharCode(...bytes.map((b) => b & 127));
  }
  function decodeLatin1(bytes) {
    return String.fromCharCode(...bytes);
  }
  function decodeWindows1252(bytes) {
    let out = "";
    for (const b of bytes) {
      if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
        out += WINDOWS_1252_EXTRA[b];
      } else {
        out += String.fromCharCode(b);
      }
    }
    return out;
  }

  // node_modules/token-types/lib/index.js
  function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
  }
  var UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  var UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  var UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  var UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  var UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  var INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  var UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  var StringType = class {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(data, offset = 0) {
      const bytes = data.subarray(offset, offset + this.len);
      return textDecode(bytes, this.encoding);
    }
  };

  // node_modules/strtok3/lib/stream/Errors.js
  var defaultMessages = "End-Of-Stream";
  var EndOfStreamError = class extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  var AbortError = class extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  };

  // node_modules/strtok3/lib/stream/AbstractStreamReader.js
  var AbstractStreamReader = class {
    constructor() {
      this.endOfStream = false;
      this.interrupted = false;
      this.peekQueue = [];
    }
    async peek(uint8Array, mayBeLess = false) {
      const bytesRead = await this.read(uint8Array, mayBeLess);
      this.peekQueue.push(uint8Array.subarray(0, bytesRead));
      return bytesRead;
    }
    async read(buffer, mayBeLess = false) {
      if (buffer.length === 0) {
        return 0;
      }
      let bytesRead = this.readFromPeekBuffer(buffer);
      if (!this.endOfStream) {
        bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
      }
      if (bytesRead === 0 && !mayBeLess) {
        throw new EndOfStreamError();
      }
      return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @returns Number of bytes read
     */
    readFromPeekBuffer(buffer) {
      let remaining = buffer.length;
      let bytesRead = 0;
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop();
        if (!peekData)
          throw new Error("peekData should be defined");
        const lenCopy = Math.min(peekData.length, remaining);
        buffer.set(peekData.subarray(0, lenCopy), bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      return bytesRead;
    }
    async readRemainderFromStream(buffer, mayBeLess) {
      let bytesRead = 0;
      while (bytesRead < buffer.length && !this.endOfStream) {
        if (this.interrupted) {
          throw new AbortError();
        }
        const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
        if (chunkLen === 0)
          break;
        bytesRead += chunkLen;
      }
      if (!mayBeLess && bytesRead < buffer.length) {
        throw new EndOfStreamError();
      }
      return bytesRead;
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamReader.js
  var WebStreamReader = class extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamByobReader.js
  var WebStreamByobReader = class extends WebStreamReader {
    /**
     * Read from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param mayBeLess - If true, may fill the buffer partially
     * @protected Bytes read
     */
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? void 0 : buffer.length });
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer.set(result.value);
        return result.value.length;
      }
      return 0;
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
  var WebStreamDefaultReader = class extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
      this.buffer = null;
    }
    /**
     * Copy chunk to target, and store the remainder in this.buffer
     */
    writeChunk(target, chunk) {
      const written = Math.min(chunk.length, target.length);
      target.set(chunk.subarray(0, written));
      if (written < chunk.length) {
        this.buffer = chunk.subarray(written);
      } else {
        this.buffer = null;
      }
      return written;
    }
    /**
     * Read from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param mayBeLess - If true, may fill the buffer partially
     * @protected Bytes read
     */
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      let totalBytesRead = 0;
      if (this.buffer) {
        totalBytesRead += this.writeChunk(buffer, this.buffer);
      }
      while (totalBytesRead < buffer.length && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
        }
      }
      if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError();
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
  function makeWebStreamReader(stream) {
    try {
      const reader = stream.getReader({ mode: "byob" });
      if (reader instanceof ReadableStreamDefaultReader) {
        return new WebStreamDefaultReader(reader);
      }
      return new WebStreamByobReader(reader);
    } catch (error) {
      if (error instanceof TypeError) {
        return new WebStreamDefaultReader(stream.getReader());
      }
      throw error;
    }
  }

  // node_modules/strtok3/lib/AbstractTokenizer.js
  var AbstractTokenizer = class {
    /**
     * Constructor
     * @param options Tokenizer options
     * @protected
     */
    constructor(options) {
      this.numBuffer = new Uint8Array(8);
      this.position = 0;
      this.onClose = options?.onClose;
      if (options?.abortSignal) {
        options.abortSignal.addEventListener("abort", () => {
          this.abort();
        });
      }
    }
    /**
     * Read a token from the tokenizer-stream
     * @param token - The token to read
     * @param position - If provided, the desired position in the tokenizer-stream
     * @returns Promise with token data
     */
    async readToken(token, position = this.position) {
      const uint8Array = new Uint8Array(token.len);
      const len = await this.readBuffer(uint8Array, { position });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(uint8Array, 0);
    }
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */
    async peekToken(token, position = this.position) {
      const uint8Array = new Uint8Array(token.len);
      const len = await this.peekBuffer(uint8Array, { position });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(uint8Array, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async readNumber(token) {
      const len = await this.readBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(this.numBuffer, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async peekNumber(token) {
      const len = await this.peekBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(this.numBuffer, 0);
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */
    async ignore(length) {
      if (this.fileInfo.size !== void 0) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length > bytesLeft) {
          this.position += bytesLeft;
          return bytesLeft;
        }
      }
      this.position += length;
      return length;
    }
    async close() {
      await this.abort();
      await this.onClose?.();
    }
    normalizeOptions(uint8Array, options) {
      if (!this.supportsRandomAccess() && options && options.position !== void 0 && options.position < this.position) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      return {
        ...{
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        },
        ...options
      };
    }
    abort() {
      return Promise.resolve();
    }
  };

  // node_modules/strtok3/lib/ReadStreamTokenizer.js
  var maxBufferSize = 256e3;
  var ReadStreamTokenizer = class extends AbstractTokenizer {
    /**
     * Constructor
     * @param streamReader stream-reader to read from
     * @param options Tokenizer options
     */
    constructor(streamReader, options) {
      super(options);
      this.streamReader = streamReader;
      this.fileInfo = options?.fileInfo ?? {};
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError();
      }
      return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        } catch (err2) {
          if (options?.mayBeLess && err2 instanceof EndOfStreamError) {
            return 0;
          }
          throw err2;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError();
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };

  // node_modules/strtok3/lib/BufferTokenizer.js
  var BufferTokenizer = class extends AbstractTokenizer {
    /**
     * Construct BufferTokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options Tokenizer options
     */
    constructor(uint8Array, options) {
      super(options);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async readBuffer(uint8Array, options) {
      if (options?.position) {
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError();
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };

  // node_modules/strtok3/lib/core.js
  function fromWebStream(webStream, options) {
    const webStreamReader = makeWebStreamReader(webStream);
    const _options = options ?? {};
    const chainedClose = _options.onClose;
    _options.onClose = async () => {
      await webStreamReader.close();
      if (chainedClose) {
        return chainedClose();
      }
    };
    return new ReadStreamTokenizer(webStreamReader, _options);
  }
  function fromBuffer(uint8Array, options) {
    return new BufferTokenizer(uint8Array, options);
  }

  // node_modules/fflate/esm/browser.js
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb2, start) {
    var b = new u16(31);
    for (var i3 = 0; i3 < 31; ++i3) {
      b[i3] = start += 1 << eb2[i3 - 1];
    }
    var r = new i32(b[30]);
    for (var i3 = 1; i3 < 30; ++i3) {
      for (var j2 = b[i3]; j2 < b[i3 + 1]; ++j2) {
        r[j2] = j2 - b[i3] << 5 | i3;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2);
  var fl = _a.b;
  var revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i3 = 0; i3 < 32768; ++i3) {
    x2 = (i3 & 43690) >> 1 | (i3 & 21845) << 1;
    x2 = (x2 & 52428) >> 2 | (x2 & 13107) << 2;
    x2 = (x2 & 61680) >> 4 | (x2 & 3855) << 4;
    rev[i3] = ((x2 & 65280) >> 8 | (x2 & 255) << 8) >> 1;
  }
  var x2;
  var i3;
  var hMap = (function(cd2, mb2, r) {
    var s = cd2.length;
    var i3 = 0;
    var l = new u16(mb2);
    for (; i3 < s; ++i3) {
      if (cd2[i3])
        ++l[cd2[i3] - 1];
    }
    var le3 = new u16(mb2);
    for (i3 = 1; i3 < mb2; ++i3) {
      le3[i3] = le3[i3 - 1] + l[i3 - 1] << 1;
    }
    var co2;
    if (r) {
      co2 = new u16(1 << mb2);
      var rvb = 15 - mb2;
      for (i3 = 0; i3 < s; ++i3) {
        if (cd2[i3]) {
          var sv2 = i3 << 4 | cd2[i3];
          var r_1 = mb2 - cd2[i3];
          var v = le3[cd2[i3] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co2[rev[v] >> rvb] = sv2;
          }
        }
      }
    } else {
      co2 = new u16(s);
      for (i3 = 0; i3 < s; ++i3) {
        if (cd2[i3]) {
          co2[i3] = rev[le3[cd2[i3] - 1]++] >> 15 - cd2[i3];
        }
      }
    }
    return co2;
  });
  var flt = new u8(288);
  for (i3 = 0; i3 < 144; ++i3)
    flt[i3] = 8;
  var i3;
  for (i3 = 144; i3 < 256; ++i3)
    flt[i3] = 9;
  var i3;
  for (i3 = 256; i3 < 280; ++i3)
    flt[i3] = 7;
  var i3;
  for (i3 = 280; i3 < 288; ++i3)
    flt[i3] = 8;
  var i3;
  var fdt = new u8(32);
  for (i3 = 0; i3 < 32; ++i3)
    fdt[i3] = 5;
  var i3;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a) {
    var m = a[0];
    for (var i3 = 1; i3 < a.length; ++i3) {
      if (a[i3] > m)
        m = a[i3];
    }
    return m;
  };
  var bits = function(d2, p2, m) {
    var o = p2 / 8 | 0;
    return (d2[o] | d2[o + 1] << 8) >> (p2 & 7) & m;
  };
  var bits16 = function(d2, p2) {
    var o = p2 / 8 | 0;
    return (d2[o] | d2[o + 1] << 8 | d2[o + 2] << 16) >> (p2 & 7);
  };
  var shft = function(p2) {
    return (p2 + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt3) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt3)
      throw e;
    return e;
  };
  var inflt = function(dat, st3, buf, dict) {
    var sl2 = dat.length, dl2 = dict ? dict.length : 0;
    if (!sl2 || st3.f && !st3.l)
      return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st3.i != 2;
    var noSt = st3.i;
    if (noBuf)
      buf = new u8(sl2 * 3);
    var cbuf = function(l2) {
      var bl2 = buf.length;
      if (l2 > bl2) {
        var nbuf = new u8(Math.max(bl2 * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st3.f || 0, pos = st3.p || 0, bt3 = st3.b || 0, lm2 = st3.l, dm2 = st3.d, lbt = st3.m, dbt = st3.n;
    var tbts = sl2 * 8;
    do {
      if (!lm2) {
        final = bits(dat, pos, 1);
        var type2 = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type2) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl2) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt3 + l);
          buf.set(dat.subarray(s, t), bt3);
          st3.b = bt3 += l, st3.p = pos = t * 8, st3.f = final;
          continue;
        } else if (type2 == 1)
          lm2 = flrm, dm2 = fdrm, lbt = 9, dbt = 5;
        else if (type2 == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl2 = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl2);
          var clt = new u8(19);
          for (var i3 = 0; i3 < hcLen; ++i3) {
            clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i3 = 0; i3 < tl2; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i3++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i3 - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i3++] = c;
            }
          }
          var lt3 = ldt.subarray(0, hLit), dt3 = ldt.subarray(hLit);
          lbt = max(lt3);
          dbt = max(dt3);
          lm2 = hMap(lt3, lbt, 1);
          dm2 = hMap(dt3, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt3 + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm2[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt3++] = sym;
        else if (sym == 256) {
          lpos = pos, lm2 = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i3 = sym - 257, b = fleb[i3];
            add = bits(dat, pos, (1 << b) - 1) + fl[i3];
            pos += b;
          }
          var d2 = dm2[bits16(dat, pos) & dms], dsym = d2 >> 4;
          if (!d2)
            err(3);
          pos += d2 & 15;
          var dt3 = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt3 += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt3 + 131072);
          var end = bt3 + add;
          if (bt3 < dt3) {
            var shift = dl2 - dt3, dend = Math.min(dt3, end);
            if (shift + bt3 < 0)
              err(3);
            for (; bt3 < dend; ++bt3)
              buf[bt3] = dict[shift + bt3];
          }
          for (; bt3 < end; ++bt3)
            buf[bt3] = buf[bt3 - dt3];
        }
      }
      st3.l = lm2, st3.p = lpos, st3.b = bt3, st3.f = final;
      if (lm2)
        final = 1, st3.m = lbt, st3.d = dm2, st3.n = dbt;
    } while (!final);
    return bt3 != buf.length && noBuf ? slc(buf, 0, bt3) : buf.subarray(0, bt3);
  };
  var et = /* @__PURE__ */ new u8(0);
  var gzs = function(d2) {
    if (d2[0] != 31 || d2[1] != 139 || d2[2] != 8)
      err(6, "invalid gzip data");
    var flg = d2[3];
    var st3 = 10;
    if (flg & 4)
      st3 += (d2[10] | d2[11] << 8) + 2;
    for (var zs2 = (flg >> 3 & 1) + (flg >> 4 & 1); zs2 > 0; zs2 -= !d2[st3++])
      ;
    return st3 + (flg & 2);
  };
  var gzl = function(d2) {
    var l = d2.length;
    return (d2[l - 4] | d2[l - 3] << 8 | d2[l - 2] << 16 | d2[l - 1] << 24) >>> 0;
  };
  var zls = function(d2, dict) {
    if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
      err(6, "invalid zlib data");
    if ((d2[1] >> 5 & 1) == +!dict)
      err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
    return (d2[1] >> 3 & 4) + 2;
  };
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function gunzipSync(data, opts) {
    var st3 = gzs(data);
    if (st3 + 8 > data.length)
      err(6, "invalid gzip data");
    return inflt(data.subarray(st3, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
  }
  function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function decompressSync(data, opts) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }

  // node_modules/@tokenizer/inflate/lib/index.js
  var import_debug = __toESM(require_browser(), 1);

  // node_modules/@tokenizer/inflate/lib/ZipToken.js
  var Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  var DataDescriptor = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        compressedSize: UINT32_LE.get(array, 8),
        uncompressedSize: UINT32_LE.get(array, 12)
      };
    },
    len: 16
  };
  var LocalFileHeaderToken = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 8),
        compressedSize: UINT32_LE.get(array, 18),
        uncompressedSize: UINT32_LE.get(array, 22),
        filenameLength: UINT16_LE.get(array, 26),
        extraFieldLength: UINT16_LE.get(array, 28),
        filename: null
      };
    },
    len: 30
  };
  var EndOfCentralDirectoryRecordToken = {
    get(array) {
      return {
        signature: UINT32_LE.get(array, 0),
        nrOfThisDisk: UINT16_LE.get(array, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array, 10),
        sizeOfCd: UINT32_LE.get(array, 12),
        offsetOfStartOfCd: UINT32_LE.get(array, 16),
        zipFileCommentLength: UINT16_LE.get(array, 20)
      };
    },
    len: 22
  };
  var FileHeader = {
    get(array) {
      const flags = UINT16_LE.get(array, 8);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 10),
        compressedSize: UINT32_LE.get(array, 20),
        uncompressedSize: UINT32_LE.get(array, 24),
        filenameLength: UINT16_LE.get(array, 28),
        extraFieldLength: UINT16_LE.get(array, 30),
        fileCommentLength: UINT16_LE.get(array, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
        filename: null
      };
    },
    len: 46
  };

  // node_modules/@tokenizer/inflate/lib/index.js
  function signatureToArray(signature) {
    const signatureBytes = new Uint8Array(UINT32_LE.len);
    UINT32_LE.put(signatureBytes, 0, signature);
    return signatureBytes;
  }
  var debug = (0, import_debug.default)("tokenizer:inflate");
  var syncBufferSize = 256 * 1024;
  var ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  var eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
  var ZipHandler = class {
    constructor(tokenizer) {
      this.tokenizer = tokenizer;
      this.syncBuffer = new Uint8Array(syncBufferSize);
    }
    async isZip() {
      return await this.peekSignature() === Signature.LocalFileHeader;
    }
    peekSignature() {
      return this.tokenizer.peekToken(UINT32_LE);
    }
    async findEndOfCentralDirectoryLocator() {
      const randomReadTokenizer = this.tokenizer;
      const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
      const buffer = this.syncBuffer.subarray(0, chunkLength);
      await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
      for (let i3 = buffer.length - 4; i3 >= 0; i3--) {
        if (buffer[i3] === eocdSignatureBytes[0] && buffer[i3 + 1] === eocdSignatureBytes[1] && buffer[i3 + 2] === eocdSignatureBytes[2] && buffer[i3 + 3] === eocdSignatureBytes[3]) {
          return randomReadTokenizer.fileInfo.size - chunkLength + i3;
        }
      }
      return -1;
    }
    async readCentralDirectory() {
      if (!this.tokenizer.supportsRandomAccess()) {
        debug("Cannot reading central-directory without random-read support");
        return;
      }
      debug("Reading central-directory...");
      const pos = this.tokenizer.position;
      const offset = await this.findEndOfCentralDirectoryLocator();
      if (offset > 0) {
        debug("Central-directory 32-bit signature found");
        const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
        const files = [];
        this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
        for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
          const entry = await this.tokenizer.readToken(FileHeader);
          if (entry.signature !== Signature.CentralFileHeader) {
            throw new Error("Expected Central-File-Header signature");
          }
          entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
          await this.tokenizer.ignore(entry.extraFieldLength);
          await this.tokenizer.ignore(entry.fileCommentLength);
          files.push(entry);
          debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
        }
        this.tokenizer.setPosition(pos);
        return files;
      }
      this.tokenizer.setPosition(pos);
    }
    async unzip(fileCb) {
      const entries = await this.readCentralDirectory();
      if (entries) {
        return this.iterateOverCentralDirectory(entries, fileCb);
      }
      let stop = false;
      do {
        const zipHeader = await this.readLocalFileHeader();
        if (!zipHeader)
          break;
        const next = fileCb(zipHeader);
        stop = !!next.stop;
        let fileData = void 0;
        await this.tokenizer.ignore(zipHeader.extraFieldLength);
        if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
          const chunks = [];
          let len = syncBufferSize;
          debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
          let nextHeaderIndex = -1;
          while (nextHeaderIndex < 0 && len === syncBufferSize) {
            len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
            nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
            const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
            if (next.handler) {
              const data = new Uint8Array(size);
              await this.tokenizer.readBuffer(data);
              chunks.push(data);
            } else {
              await this.tokenizer.ignore(size);
            }
          }
          debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
          if (next.handler) {
            await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
          }
        } else {
          if (next.handler) {
            debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
            fileData = new Uint8Array(zipHeader.compressedSize);
            await this.tokenizer.readBuffer(fileData);
            await this.inflate(zipHeader, fileData, next.handler);
          } else {
            debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
            await this.tokenizer.ignore(zipHeader.compressedSize);
          }
        }
        debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
        if (zipHeader.dataDescriptor) {
          const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
          if (dataDescriptor.signature !== 134695760) {
            throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
          }
        }
      } while (!stop);
    }
    async iterateOverCentralDirectory(entries, fileCb) {
      for (const fileHeader of entries) {
        const next = fileCb(fileHeader);
        if (next.handler) {
          this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
          const zipHeader = await this.readLocalFileHeader();
          if (zipHeader) {
            await this.tokenizer.ignore(zipHeader.extraFieldLength);
            const fileData = new Uint8Array(fileHeader.compressedSize);
            await this.tokenizer.readBuffer(fileData);
            await this.inflate(zipHeader, fileData, next.handler);
          }
        }
        if (next.stop)
          break;
      }
    }
    inflate(zipHeader, fileData, cb2) {
      if (zipHeader.compressedMethod === 0) {
        return cb2(fileData);
      }
      debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
      const uncompressedData = decompressSync(fileData);
      return cb2(uncompressedData);
    }
    async readLocalFileHeader() {
      const signature = await this.tokenizer.peekToken(UINT32_LE);
      if (signature === Signature.LocalFileHeader) {
        const header = await this.tokenizer.readToken(LocalFileHeaderToken);
        header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
        return header;
      }
      if (signature === Signature.CentralFileHeader) {
        return false;
      }
      if (signature === 3759263696) {
        throw new Error("Encrypted ZIP");
      }
      throw new Error("Unexpected signature");
    }
  };
  function indexOf(buffer, portion) {
    const bufferLength = buffer.length;
    const portionLength = portion.length;
    if (portionLength > bufferLength)
      return -1;
    for (let i3 = 0; i3 <= bufferLength - portionLength; i3++) {
      let found = true;
      for (let j2 = 0; j2 < portionLength; j2++) {
        if (buffer[i3 + j2] !== portion[j2]) {
          found = false;
          break;
        }
      }
      if (found) {
        return i3;
      }
    }
    return -1;
  }
  function mergeArrays(chunks) {
    const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
    const mergedArray = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      mergedArray.set(chunk, offset);
      offset += chunk.length;
    }
    return mergedArray;
  }

  // node_modules/uint8array-extras/index.js
  var cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  var cachedEncoder = new globalThis.TextEncoder();
  var byteToHexLookupTable = Array.from({ length: 256 }, (_3, index) => index.toString(16).padStart(2, "0"));
  function getUintBE(view) {
    const { byteLength } = view;
    if (byteLength === 6) {
      return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
    }
    if (byteLength === 5) {
      return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
    }
    if (byteLength === 4) {
      return view.getUint32(0);
    }
    if (byteLength === 3) {
      return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
    }
    if (byteLength === 2) {
      return view.getUint16(0);
    }
    if (byteLength === 1) {
      return view.getUint8(0);
    }
  }

  // node_modules/file-type/util.js
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
    const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
    if (Number.isNaN(readSum)) {
      return false;
    }
    let sum = 8 * 32;
    for (let index = offset; index < offset + 148; index++) {
      sum += arrayBuffer[index];
    }
    for (let index = offset + 156; index < offset + 512; index++) {
      sum += arrayBuffer[index];
    }
    return readSum === sum;
  }
  var uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };

  // node_modules/file-type/supported.js
  var extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  var mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    // RFC 4337
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    // Non-standard
    "application/x.ms.shortcut",
    // Invented by us
    "application/x.apple.alias",
    // Invented by us
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    // Invented by us
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    // Invented by us
    "application/x-lz4",
    // Invented by us
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];

  // node_modules/file-type/core.js
  var reasonableDetectionSizeInBytes = 4100;
  async function fileTypeFromBuffer(input, options) {
    return new FileTypeParser(options).fromBuffer(input);
  }
  function getFileTypeFromMimeType(mimeType) {
    mimeType = mimeType.toLowerCase();
    switch (mimeType) {
      case "application/epub+zip":
        return {
          ext: "epub",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.text":
        return {
          ext: "odt",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.text-template":
        return {
          ext: "ott",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.spreadsheet":
        return {
          ext: "ods",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.spreadsheet-template":
        return {
          ext: "ots",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.presentation":
        return {
          ext: "odp",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.presentation-template":
        return {
          ext: "otp",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.graphics":
        return {
          ext: "odg",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.graphics-template":
        return {
          ext: "otg",
          mime: mimeType
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
        return {
          ext: "ppsx",
          mime: mimeType
        };
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
        return {
          ext: "xlsx",
          mime: mimeType
        };
      case "application/vnd.ms-excel.sheet.macroenabled":
        return {
          ext: "xlsm",
          mime: "application/vnd.ms-excel.sheet.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
        return {
          ext: "xltx",
          mime: mimeType
        };
      case "application/vnd.ms-excel.template.macroenabled":
        return {
          ext: "xltm",
          mime: "application/vnd.ms-excel.template.macroenabled.12"
        };
      case "application/vnd.ms-powerpoint.slideshow.macroenabled":
        return {
          ext: "ppsm",
          mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
        return {
          ext: "docx",
          mime: mimeType
        };
      case "application/vnd.ms-word.document.macroenabled":
        return {
          ext: "docm",
          mime: "application/vnd.ms-word.document.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
        return {
          ext: "dotx",
          mime: mimeType
        };
      case "application/vnd.ms-word.template.macroenabledtemplate":
        return {
          ext: "dotm",
          mime: "application/vnd.ms-word.template.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.template":
        return {
          ext: "potx",
          mime: mimeType
        };
      case "application/vnd.ms-powerpoint.template.macroenabled":
        return {
          ext: "potm",
          mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
        return {
          ext: "pptx",
          mime: mimeType
        };
      case "application/vnd.ms-powerpoint.presentation.macroenabled":
        return {
          ext: "pptm",
          mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
        };
      case "application/vnd.ms-visio.drawing":
        return {
          ext: "vsdx",
          mime: "application/vnd.visio"
        };
      case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
        return {
          ext: "3mf",
          mime: "model/3mf"
        };
      default:
    }
  }
  function _check(buffer, headers, options) {
    options = {
      offset: 0,
      ...options
    };
    for (const [index, header] of headers.entries()) {
      if (options.mask) {
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
    return true;
  }
  var FileTypeParser = class {
    constructor(options) {
      this.options = {
        mpegOffsetTolerance: 0,
        ...options
      };
      this.detectors = [
        ...options?.customDetectors ?? [],
        { id: "core", detect: this.detectConfident },
        { id: "core.imprecise", detect: this.detectImprecise }
      ];
      this.tokenizerOptions = {
        abortSignal: options?.signal
      };
    }
    async fromTokenizer(tokenizer) {
      const initialPosition = tokenizer.position;
      for (const detector of this.detectors) {
        const fileType = await detector.detect(tokenizer);
        if (fileType) {
          return fileType;
        }
        if (initialPosition !== tokenizer.position) {
          return void 0;
        }
      }
    }
    async fromBuffer(input) {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buffer?.length > 1)) {
        return;
      }
      return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
    }
    async fromBlob(blob) {
      return this.fromStream(blob.stream());
    }
    async fromStream(stream) {
      const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
      try {
        return await this.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async toDetectionStream(stream, options) {
      const { sampleSize = reasonableDetectionSizeInBytes } = options;
      let detectedFileType;
      let firstChunk;
      const reader = stream.getReader({ mode: "byob" });
      try {
        const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
        firstChunk = chunk;
        if (!done && chunk) {
          try {
            detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
          } catch (error) {
            if (!(error instanceof EndOfStreamError)) {
              throw error;
            }
            detectedFileType = void 0;
          }
        }
        firstChunk = chunk;
      } finally {
        reader.releaseLock();
      }
      const transformStream = new TransformStream({
        async start(controller) {
          controller.enqueue(firstChunk);
        },
        transform(chunk, controller) {
          controller.enqueue(chunk);
        }
      });
      const newStream = stream.pipeThrough(transformStream);
      newStream.fileType = detectedFileType;
      return newStream;
    }
    check(header, options) {
      return _check(this.buffer, header, options);
    }
    checkString(header, options) {
      return this.check(stringToBytes(header), options);
    }
    // Detections with a high degree of certainty in identifying the correct file type
    detectConfident = async (tokenizer) => {
      this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
      if (tokenizer.fileInfo.size === void 0) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      this.tokenizer = tokenizer;
      await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
      if (this.check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (this.check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (this.check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (this.check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (this.check([37, 33])) {
        await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
        if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (this.check([31, 160]) || this.check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (this.check([199, 113])) {
        return {
          ext: "cpio",
          mime: "application/x-cpio"
        };
      }
      if (this.check([96, 234])) {
        return {
          ext: "arj",
          mime: "application/x-arj"
        };
      }
      if (this.check([239, 187, 191])) {
        this.tokenizer.ignore(3);
        return this.detectConfident(tokenizer);
      }
      if (this.check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (this.check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (this.check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (this.check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (this.checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLength);
        return this.fromTokenizer(tokenizer);
      }
      if (this.checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (this.check([255, 216, 255])) {
        if (this.check([247], { offset: 3 })) {
          return {
            ext: "jls",
            mime: "image/jls"
          };
        }
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (this.check([79, 98, 106, 1])) {
        return {
          ext: "avro",
          mime: "application/avro"
        };
      }
      if (this.checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (this.checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (this.checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (this.checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (this.checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (this.check([80, 75, 3, 4])) {
        let fileType;
        await new ZipHandler(tokenizer).unzip((zipHeader) => {
          switch (zipHeader.filename) {
            case "META-INF/mozilla.rsa":
              fileType = {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
              return {
                stop: true
              };
            case "META-INF/MANIFEST.MF":
              fileType = {
                ext: "jar",
                mime: "application/java-archive"
              };
              return {
                stop: true
              };
            case "mimetype":
              return {
                async handler(fileData) {
                  const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                  fileType = getFileTypeFromMimeType(mimeType);
                },
                stop: true
              };
            case "[Content_Types].xml":
              return {
                async handler(fileData) {
                  let xmlContent = new TextDecoder("utf-8").decode(fileData);
                  const endPos = xmlContent.indexOf('.main+xml"');
                  if (endPos === -1) {
                    const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                    if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                      fileType = getFileTypeFromMimeType(mimeType);
                    }
                  } else {
                    xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                    const firstPos = xmlContent.lastIndexOf('"');
                    const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                },
                stop: true
              };
            default:
              if (/classes\d*\.dex/.test(zipHeader.filename)) {
                fileType = {
                  ext: "apk",
                  mime: "application/vnd.android.package-archive"
                };
                return { stop: true };
              }
              return {};
          }
        });
        return fileType ?? {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("OggS")) {
        await tokenizer.ignore(28);
        const type2 = new Uint8Array(8);
        await tokenizer.readBuffer(type2);
        if (_check(type2, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/ogg; codecs=opus"
          };
        }
        if (_check(type2, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type2, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type2, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type2, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type2, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (this.checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (this.checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (this.checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/flac"
        };
      }
      if (this.check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (this.checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (this.checkString("%PDF")) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (this.check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (this.check([73, 73])) {
        const fileType = await this.readTiffHeader(false);
        if (fileType) {
          return fileType;
        }
      }
      if (this.check([77, 77])) {
        const fileType = await this.readTiffHeader(true);
        if (fileType) {
          return fileType;
        }
      }
      if (this.checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (this.check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(UINT8);
          let mask = 128;
          let ic2 = 0;
          while ((msb & mask) === 0 && mask !== 0) {
            ++ic2;
            mask >>= 1;
          }
          const id2 = new Uint8Array(ic2 + 1);
          await tokenizer.readBuffer(id2);
          return id2;
        }
        async function readElement() {
          const idField = await readField();
          const lengthField = await readField();
          lengthField[0] ^= 128 >> lengthField.length - 1;
          const nrLength = Math.min(6, lengthField.length);
          const idView = new DataView(idField.buffer);
          const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
          return {
            id: getUintBE(idView),
            len: getUintBE(lengthView)
          };
        }
        async function readChildren(children) {
          while (children > 0) {
            const element = await readElement();
            if (element.id === 17026) {
              const rawValue = await tokenizer.readToken(new StringType(element.len));
              return rawValue.replaceAll(/\00.*$/g, "");
            }
            await tokenizer.ignore(element.len);
            --children;
          }
        }
        const re2 = await readElement();
        const documentType = await readChildren(re2.len);
        switch (documentType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/matroska"
            };
          default:
            return;
        }
      }
      if (this.checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (this.check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (this.checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (this.checkString("MSCF") || this.checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (this.check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (this.check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (this.check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (this.check([127, 69, 76, 70])) {
        return {
          ext: "elf",
          mime: "application/x-elf"
        };
      }
      if (this.check([33, 66, 68, 78])) {
        return {
          ext: "pst",
          mime: "application/vnd.ms-outlook"
        };
      }
      if (this.checkString("PAR1") || this.checkString("PARE")) {
        return {
          ext: "parquet",
          mime: "application/vnd.apache.parquet"
        };
      }
      if (this.checkString("ttcf")) {
        return {
          ext: "ttc",
          mime: "font/collection"
        };
      }
      if (this.check([207, 250, 237, 254])) {
        return {
          ext: "macho",
          mime: "application/x-mach-binary"
        };
      }
      if (this.check([4, 34, 77, 24])) {
        return {
          ext: "lz4",
          mime: "application/x-lz4"
          // Invented by us
        };
      }
      if (this.check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (this.checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (this.checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (this.check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (this.checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (this.check([0, 0, 1, 186])) {
        if (this.check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        }
        if (this.check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
        }
      }
      if (this.checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (this.check([202, 254, 186, 190])) {
        return {
          ext: "class",
          mime: "application/java-vm"
        };
      }
      if (this.checkString(".RMF")) {
        return {
          ext: "rm",
          mime: "application/vnd.rn-realmedia"
        };
      }
      if (this.checkString("DRACO")) {
        return {
          ext: "drc",
          mime: "application/vnd.google.draco"
          // Invented by us
        };
      }
      if (this.check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (this.checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (this.checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (this.checkString("AC")) {
        const version = new StringType(4, "latin1").get(this.buffer, 2);
        if (version.match("^d*") && version >= 1e3 && version <= 1050) {
          return {
            ext: "dwg",
            mime: "image/vnd.dwg"
          };
        }
      }
      if (this.checkString("070707")) {
        return {
          ext: "cpio",
          mime: "application/x-cpio"
        };
      }
      if (this.checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (this.checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const string = await tokenizer.readToken(new StringType(13, "ascii"));
        if (string === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (this.checkString("WEBVTT") && // One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
      ["\n", "\r", "	", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
        return {
          ext: "vtt",
          mime: "text/vtt"
        };
      }
      if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(INT32_BE),
            type: await tokenizer.readToken(new StringType(4, "latin1"))
          };
        }
        do {
          const chunk = await readChunkHeader();
          if (chunk.length < 0) {
            return;
          }
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/vnd.apache.arrow.file"
        };
      }
      if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (this.checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
        const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
          case "avis":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (this.check([82, 73, 70, 70])) {
        if (this.checkString("WEBP", { offset: 8 })) {
          return {
            ext: "webp",
            mime: "image/webp"
          };
        }
        if (this.check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (this.check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/wav"
          };
        }
        if (this.check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          const guid = new Uint8Array(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(UINT64_LE))
          };
        }
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = new Uint8Array(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (this.check([255, 79, 255, 81])) {
        return {
          ext: "j2c",
          mime: "image/j2c"
        };
      }
      if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type2 = await tokenizer.readToken(new StringType(4, "ascii"));
        switch (type2) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (this.check([254, 255])) {
        if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        return void 0;
      }
      if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.check([97, 99, 115, 112], { offset: 36 })) {
        return {
          ext: "icc",
          mime: "application/vnd.iccprofile"
        };
      }
      if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
        return {
          ext: "ace",
          mime: "application/x-ace-compressed"
        };
      }
      if (this.checkString("BEGIN:")) {
        if (this.checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (this.checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (this.checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (this.checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (this.checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
        const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
        if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
          try {
            const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
            const json2 = JSON.parse(header);
            if (json2.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch {
          }
        }
      }
      if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (this.checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (this.check([71]) && this.check([71], { offset: 188 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (this.check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (this.checkString("Kaydara FBX Binary  \0")) {
        return {
          ext: "fbx",
          mime: "application/x.autodesk.fbx"
          // Invented by us
        };
      }
      if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (this.check([255, 254])) {
        if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
          return {
            ext: "skp",
            mime: "application/vnd.sketchup.skp"
          };
        }
        return void 0;
      }
      if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
    };
    // Detections with limited supporting data, resulting in a higher likelihood of false positives
    detectImprecise = async (tokenizer) => {
      this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (this.check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (this.check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (this.check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
        for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
          const type2 = this.scanMpeg(depth);
          if (type2) {
            return type2;
          }
        }
      }
    };
    async readTiffTag(bigEndian) {
      const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
      this.tokenizer.ignore(10);
      switch (tagId) {
        case 50341:
          return {
            ext: "arw",
            mime: "image/x-sony-arw"
          };
        case 50706:
          return {
            ext: "dng",
            mime: "image/x-adobe-dng"
          };
        default:
      }
    }
    async readTiffIFD(bigEndian) {
      const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
      for (let n = 0; n < numberOfTags; ++n) {
        const fileType = await this.readTiffTag(bigEndian);
        if (fileType) {
          return fileType;
        }
      }
    }
    async readTiffHeader(bigEndian) {
      const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
      const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
      if (version === 42) {
        if (ifdOffset >= 6) {
          if (this.checkString("CR", { offset: 8 })) {
            return {
              ext: "cr2",
              mime: "image/x-canon-cr2"
            };
          }
          if (ifdOffset >= 8) {
            const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
            const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
            if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
              return {
                ext: "nef",
                mime: "image/x-nikon-nef"
              };
            }
          }
        }
        await this.tokenizer.ignore(ifdOffset);
        const fileType = await this.readTiffIFD(bigEndian);
        return fileType ?? {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (version === 43) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
    }
    /**
    	Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).
    
    	@param offset - Offset to scan for sync-preamble.
    	@returns {{ext: string, mime: string}}
    	*/
    scanMpeg(offset) {
      if (this.check([255, 224], { offset, mask: [255, 224] })) {
        if (this.check([16], { offset: offset + 1, mask: [22] })) {
          if (this.check([8], { offset: offset + 1, mask: [8] })) {
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        if (this.check([2], { offset: offset + 1, mask: [6] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (this.check([4], { offset: offset + 1, mask: [6] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (this.check([6], { offset: offset + 1, mask: [6] })) {
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
        }
      }
    }
  };
  var supportedExtensions = new Set(extensions);
  var supportedMimeTypes = new Set(mimeTypes);

  // node_modules/route-engine-js/dist/RouteEngine.js
  var Gt = Object.defineProperty;
  var K = (e, t) => {
    for (var r in t) Gt(e, r, { get: t[r], enumerable: true });
  };
  var Ye = Symbol.for("immer-nothing");
  var Ue = Symbol.for("immer-draftable");
  var R = Symbol.for("immer-state");
  function S(e, ...t) {
    throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`);
  }
  var J = Object.getPrototypeOf;
  function Y(e) {
    return !!e && !!e[R];
  }
  function W(e) {
    return e ? Ge(e) || Array.isArray(e) || !!e[Ue] || !!e.constructor?.[Ue] || le(e) || ue(e) : false;
  }
  var Ht = Object.prototype.constructor.toString();
  function Ge(e) {
    if (!e || typeof e != "object") return false;
    let t = J(e);
    if (t === null) return true;
    let r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
    return r === Object ? true : typeof r == "function" && Function.toString.call(r) === Ht;
  }
  function se(e, t) {
    ce(e) === 0 ? Reflect.ownKeys(e).forEach((r) => {
      t(r, e[r], e);
    }) : e.forEach((r, n) => t(n, r, e));
  }
  function ce(e) {
    let t = e[R];
    return t ? t.type_ : Array.isArray(e) ? 1 : le(e) ? 2 : ue(e) ? 3 : 0;
  }
  function ge(e, t) {
    return ce(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
  }
  function He(e, t, r) {
    let n = ce(e);
    n === 2 ? e.set(t, r) : n === 3 ? e.add(r) : e[t] = r;
  }
  function Xt(e, t) {
    return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
  }
  function le(e) {
    return e instanceof Map;
  }
  function ue(e) {
    return e instanceof Set;
  }
  function F(e) {
    return e.copy_ || e.base_;
  }
  function Ie(e, t) {
    if (le(e)) return new Map(e);
    if (ue(e)) return new Set(e);
    if (Array.isArray(e)) return Array.prototype.slice.call(e);
    let r = Ge(e);
    if (t === true || t === "class_only" && !r) {
      let n = Object.getOwnPropertyDescriptors(e);
      delete n[R];
      let s = Reflect.ownKeys(n);
      for (let i3 = 0; i3 < s.length; i3++) {
        let o = s[i3], a = n[o];
        a.writable === false && (a.writable = true, a.configurable = true), (a.get || a.set) && (n[o] = { configurable: true, writable: true, enumerable: a.enumerable, value: e[o] });
      }
      return Object.create(J(e), n);
    } else {
      let n = J(e);
      if (n !== null && r) return { ...e };
      let s = Object.create(n);
      return Object.assign(s, e);
    }
  }
  function Ee(e, t = false) {
    return fe(e) || Y(e) || !W(e) || (ce(e) > 1 && (e.set = e.add = e.clear = e.delete = Qt), Object.freeze(e), t && Object.entries(e).forEach(([r, n]) => Ee(n, true))), e;
  }
  function Qt() {
    S(2);
  }
  function fe(e) {
    return Object.isFrozen(e);
  }
  var qt = {};
  function U(e) {
    let t = qt[e];
    return t || S(0, e), t;
  }
  var Q;
  function Xe() {
    return Q;
  }
  function Zt(e, t) {
    return { drafts_: [], parent_: e, immer_: t, canAutoFreeze_: true, unfinalizedDrafts_: 0 };
  }
  function je(e, t) {
    t && (U("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
  }
  function ve(e) {
    _e(e), e.drafts_.forEach(er), e.drafts_ = null;
  }
  function _e(e) {
    e === Q && (Q = e.parent_);
  }
  function ze(e) {
    return Q = Zt(Q, e);
  }
  function er(e) {
    let t = e[R];
    t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = true;
  }
  function Ke(e, t) {
    t.unfinalizedDrafts_ = t.drafts_.length;
    let r = t.drafts_[0];
    return e !== void 0 && e !== r ? (r[R].modified_ && (ve(t), S(4)), W(e) && (e = oe(t, e), t.parent_ || ae(t, e)), t.patches_ && U("Patches").generateReplacementPatches_(r[R].base_, e, t.patches_, t.inversePatches_)) : e = oe(t, r, []), ve(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Ye ? e : void 0;
  }
  function oe(e, t, r) {
    if (fe(t)) return t;
    let n = t[R];
    if (!n) return se(t, (s, i3) => Je(e, n, t, s, i3, r)), t;
    if (n.scope_ !== e) return t;
    if (!n.modified_) return ae(e, n.base_, true), n.base_;
    if (!n.finalized_) {
      n.finalized_ = true, n.scope_.unfinalizedDrafts_--;
      let s = n.copy_, i3 = s, o = false;
      n.type_ === 3 && (i3 = new Set(s), s.clear(), o = true), se(i3, (a, l) => Je(e, n, s, a, l, r, o)), ae(e, s, false), r && e.patches_ && U("Patches").generatePatches_(n, r, e.patches_, e.inversePatches_);
    }
    return n.copy_;
  }
  function Je(e, t, r, n, s, i3, o) {
    if (Y(s)) {
      let a = i3 && t && t.type_ !== 3 && !ge(t.assigned_, n) ? i3.concat(n) : void 0, l = oe(e, s, a);
      if (He(r, n, l), Y(l)) e.canAutoFreeze_ = false;
      else return;
    } else o && r.add(s);
    if (W(s) && !fe(s)) {
      if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return;
      oe(e, s), (!t || !t.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(r, n) && ae(e, s);
    }
  }
  function ae(e, t, r = false) {
    !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Ee(t, r);
  }
  function tr(e, t) {
    let r = Array.isArray(e), n = { type_: r ? 1 : 0, scope_: t ? t.scope_ : Xe(), modified_: false, finalized_: false, assigned_: {}, parent_: t, base_: e, draft_: null, copy_: null, revoke_: null, isManual_: false }, s = n, i3 = xe;
    r && (s = [n], i3 = q);
    let { revoke: o, proxy: a } = Proxy.revocable(s, i3);
    return n.draft_ = a, n.revoke_ = o, a;
  }
  var xe = { get(e, t) {
    if (t === R) return e;
    let r = F(e);
    if (!ge(r, t)) return rr(e, r, t);
    let n = r[t];
    return e.finalized_ || !W(n) ? n : n === ye(e.base_, t) ? (me(e), e.copy_[t] = be(n, e)) : n;
  }, has(e, t) {
    return t in F(e);
  }, ownKeys(e) {
    return Reflect.ownKeys(F(e));
  }, set(e, t, r) {
    let n = Qe(F(e), t);
    if (n?.set) return n.set.call(e.draft_, r), true;
    if (!e.modified_) {
      let s = ye(F(e), t), i3 = s?.[R];
      if (i3 && i3.base_ === r) return e.copy_[t] = r, e.assigned_[t] = false, true;
      if (Xt(r, s) && (r !== void 0 || ge(e.base_, t))) return true;
      me(e), Ae(e);
    }
    return e.copy_[t] === r && (r !== void 0 || t in e.copy_) || Number.isNaN(r) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = r, e.assigned_[t] = true), true;
  }, deleteProperty(e, t) {
    return ye(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = false, me(e), Ae(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], true;
  }, getOwnPropertyDescriptor(e, t) {
    let r = F(e), n = Reflect.getOwnPropertyDescriptor(r, t);
    return n && { writable: true, configurable: e.type_ !== 1 || t !== "length", enumerable: n.enumerable, value: r[t] };
  }, defineProperty() {
    S(11);
  }, getPrototypeOf(e) {
    return J(e.base_);
  }, setPrototypeOf() {
    S(12);
  } };
  var q = {};
  se(xe, (e, t) => {
    q[e] = function() {
      return arguments[0] = arguments[0][0], t.apply(this, arguments);
    };
  });
  q.deleteProperty = function(e, t) {
    return q.set.call(this, e, t, void 0);
  };
  q.set = function(e, t, r) {
    return xe.set.call(this, e[0], t, r, e[0]);
  };
  function ye(e, t) {
    let r = e[R];
    return (r ? F(r) : e)[t];
  }
  function rr(e, t, r) {
    let n = Qe(t, r);
    return n ? "value" in n ? n.value : n.get?.call(e.draft_) : void 0;
  }
  function Qe(e, t) {
    if (!(t in e)) return;
    let r = J(e);
    for (; r; ) {
      let n = Object.getOwnPropertyDescriptor(r, t);
      if (n) return n;
      r = J(r);
    }
  }
  function Ae(e) {
    e.modified_ || (e.modified_ = true, e.parent_ && Ae(e.parent_));
  }
  function me(e) {
    e.copy_ || (e.copy_ = Ie(e.base_, e.scope_.immer_.useStrictShallowCopy_));
  }
  var nr = class {
    constructor(e) {
      this.autoFreeze_ = true, this.useStrictShallowCopy_ = false, this.produce = (t, r, n) => {
        if (typeof t == "function" && typeof r != "function") {
          let i3 = r;
          r = t;
          let o = this;
          return function(l = i3, ...c) {
            return o.produce(l, (u) => r.call(this, u, ...c));
          };
        }
        typeof r != "function" && S(6), n !== void 0 && typeof n != "function" && S(7);
        let s;
        if (W(t)) {
          let i3 = ze(this), o = be(t, void 0), a = true;
          try {
            s = r(o), a = false;
          } finally {
            a ? ve(i3) : _e(i3);
          }
          return je(i3, n), Ke(s, i3);
        } else if (!t || typeof t != "object") {
          if (s = r(t), s === void 0 && (s = t), s === Ye && (s = void 0), this.autoFreeze_ && Ee(s, true), n) {
            let i3 = [], o = [];
            U("Patches").generateReplacementPatches_(t, s, i3, o), n(i3, o);
          }
          return s;
        } else S(1, t);
      }, this.produceWithPatches = (t, r) => {
        if (typeof t == "function") return (o, ...a) => this.produceWithPatches(o, (l) => t(l, ...a));
        let n, s;
        return [this.produce(t, r, (o, a) => {
          n = o, s = a;
        }), n, s];
      }, typeof e?.autoFreeze == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof e?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
    }
    createDraft(e) {
      W(e) || S(8), Y(e) && (e = ir(e));
      let t = ze(this), r = be(e, void 0);
      return r[R].isManual_ = true, _e(t), r;
    }
    finishDraft(e, t) {
      let r = e && e[R];
      (!r || !r.isManual_) && S(9);
      let { scope_: n } = r;
      return je(n, t), Ke(void 0, n);
    }
    setAutoFreeze(e) {
      this.autoFreeze_ = e;
    }
    setUseStrictShallowCopy(e) {
      this.useStrictShallowCopy_ = e;
    }
    applyPatches(e, t) {
      let r;
      for (r = t.length - 1; r >= 0; r--) {
        let s = t[r];
        if (s.path.length === 0 && s.op === "replace") {
          e = s.value;
          break;
        }
      }
      r > -1 && (t = t.slice(r + 1));
      let n = U("Patches").applyPatches_;
      return Y(e) ? n(e, t) : this.produce(e, (s) => n(s, t));
    }
  };
  function be(e, t) {
    let r = le(e) ? U("MapSet").proxyMap_(e, t) : ue(e) ? U("MapSet").proxySet_(e, t) : tr(e, t);
    return (t ? t.scope_ : Xe()).drafts_.push(r), r;
  }
  function ir(e) {
    return Y(e) || S(10, e), qe(e);
  }
  function qe(e) {
    if (!W(e) || fe(e)) return e;
    let t = e[R], r;
    if (t) {
      if (!t.modified_) return t.base_;
      t.finalized_ = true, r = Ie(e, t.scope_.immer_.useStrictShallowCopy_);
    } else r = Ie(e, true);
    return se(r, (n, s) => {
      He(r, n, qe(s));
    }), t && (t.finalized_ = false), r;
  }
  var T = new nr();
  var we = T.produce;
  var Xn = T.produceWithPatches.bind(T);
  var Qn = T.setAutoFreeze.bind(T);
  var qn = T.setUseStrictShallowCopy.bind(T);
  var Zn = T.applyPatches.bind(T);
  var ei = T.createDraft.bind(T);
  var ti = T.finishDraft.bind(T);
  var Pe = (e, t, r = {}) => {
    let n = structuredClone(e), s = {}, i3 = {}, { transformSelectorFirstArgument: o = (l) => l, transformActionFirstArgument: a = (l) => l } = r;
    for (let [l, c] of Object.entries(t)) l !== "createInitialState" && (l.startsWith("select") ? s[l] = (...u) => c(o(n), ...u) : i3[l] = (...u) => {
      n = we(n, (p2) => c(a(p2), ...u));
    });
    return { ...s, ...i3 };
  };
  var ke = (e, t) => (r) => {
    let n = e(), s = Array.isArray(r) ? r : [r];
    return we(n, (i3) => {
      s.forEach((o) => {
        t.forEach((a) => {
          a(i3, o);
        });
      });
    });
  };
  var de = (e) => {
    let t = window.atob(e.replace(/^data:image\/[a-z]+;base64,/, "")), r = t.length, n = new Uint8Array(r);
    for (let s = 0; s < r; s++) n[s] = t.charCodeAt(s);
    return n.buffer;
  };
  var Se = {};
  K(Se, { addBackgrundOrCg: () => dt, addBgm: () => gt, addCharacters: () => pt, addChoices: () => mt, addDialogue: () => yt, addGlobalAudios: () => bt, addLayout: () => _t, addModals: () => At, addScreen: () => ft, addSfx: () => It, addVisuals: () => ht, addVoice: () => vt, createInitialState: () => Nr, default: () => Te });
  var d = { LITERAL: 0, VARIABLE: 1, INTERPOLATION: 2, FUNCTION: 3, BINARY: 4, UNARY: 5, CONDITIONAL: 6, LOOP: 7, OBJECT: 8, ARRAY: 9, PARTIAL: 10, PATH_REFERENCE: 11 };
  var x = { EQ: 0, NEQ: 1, GT: 2, LT: 3, GTE: 4, LTE: 5, AND: 6, OR: 7, IN: 8, ADD: 10, SUBTRACT: 11 };
  var Z = { NOT: 0 };
  var _ = class extends Error {
    constructor(t) {
      super(`Parse Error: ${t}`), this.name = "JemplParseError";
    }
  };
  var L = class extends Error {
    constructor(t) {
      super(`Render Error: ${t}`), this.name = "JemplRenderError";
    }
  };
  var $e = (e) => {
    if (!e || e.trim() === "") throw new _("Missing condition expression after '$if'");
    if (e.includes("===") || e.includes("!==")) {
      let r = e.includes("===") ? "==" : "!=";
      throw new _(`Invalid comparison operator '${e.includes("===") ? "===" : "!=="}' - did you mean '${r}'? (got: '${e}')`);
    }
    let t = ["<", ">", "<=", ">=", "==", "!="];
    for (let r of t) if (e.trim().endsWith(r)) throw new _(`Incomplete comparison expression - missing right operand (got: '${e}')`);
  };
  var Ze = (e) => {
    if (e.trim().endsWith(" in")) throw new _(`Missing iterable expression after 'in' (got: '$for ${e}')`);
    if (!e.includes(" in ")) throw new _(`Invalid loop syntax - missing 'in' keyword (got: '$for ${e}')`);
    let [t, r] = e.split(" in ");
    if (!r || r.trim() === "") throw new _(`Missing iterable expression after 'in' (got: '$for ${e}')`);
    if (t.includes(",")) {
      let n = t.split(",").map((s) => s.trim());
      for (let s of n) if (!s) throw new _(`Invalid loop variable - variable name cannot be empty (got: '$for ${e}')`);
    } else if (!t.trim()) throw new _(`Invalid loop variable - variable name cannot be empty (got: '$for ${e}')`);
  };
  var et2 = (e, t, r = false) => {
    if (t === null) return new L(`Cannot iterate over null value at '$for ${e}'`);
    if (t === void 0) return new L(`Cannot iterate over undefined value at '$for ${e}'`);
    let n = typeof t;
    return r ? new L(`Cannot iterate over non-array value in loop '${e}' - got ${n} instead`) : new L(`Cannot iterate over non-array value (got: ${n}) at '$for ${e}'`);
  };
  var tt = (e, t) => {
    let r = t && Object.keys(t).length > 0 ? Object.keys(t).join(", ") : "no custom functions provided";
    return new L(`Unknown function '${e}' (${r})`);
  };
  var sr = (e, t, r = {}) => {
    let n = {}, s = {};
    r && typeof r == "object" && (r.functions !== void 0 || r.partials !== void 0 ? (n = r.functions || {}, s = r.partials || {}) : typeof r == "object" && (n = r));
    let o = A(e, { functions: n, partials: s }, t, {});
    return o === void 0 ? {} : o;
  };
  var A = (e, t, r, n) => {
    let s = t.functions || t;
    if (e.var && !e.type) return k(e.var, r, n);
    if (e.type === d.LITERAL) return e.value;
    if (e.type === d.VARIABLE) return k(e.path, r, n);
    if (e.type === d.INTERPOLATION) return ar(e.parts, t, r, n);
    switch (e.type) {
      case d.FUNCTION:
        return nt(e, t, r, n);
      case d.BINARY:
        return it(e, t, r, n);
      case d.UNARY:
        return st(e, t, r, n);
      case d.CONDITIONAL:
        return lr(e, t, r, n);
      case d.LOOP:
        return hr(e, t, r, n);
      case d.OBJECT:
        return mr(e, t, r, n);
      case d.ARRAY:
        return gr(e, t, r, n);
      case d.PARTIAL:
        return Ir(e, t, r, n);
      case d.PATH_REFERENCE:
        return vr(e, t, r, n);
      default:
        throw new Error(`Unknown node type: ${e.type}`);
    }
  };
  var rt = /* @__PURE__ */ new Map();
  var or = (e) => {
    let t = [], r = "", n = false;
    for (let s = 0; s < e.length; s++) {
      let i3 = e[s];
      if (i3 === "[") r && (t.push({ type: "property", value: r }), r = ""), n = true;
      else if (i3 === "]") {
        if (n && r) {
          let o = r.trim();
          if (/^\d+$/.test(o)) t.push({ type: "index", value: parseInt(o, 10) });
          else if (o.startsWith('"') && o.endsWith('"') || o.startsWith("'") && o.endsWith("'")) {
            let a = o.slice(1, -1);
            t.push({ type: "property", value: a });
          } else t.push({ type: "property", value: o });
          r = "";
        }
        n = false;
      } else r += i3;
    }
    return r && t.push({ type: "property", value: r }), t;
  };
  var k = (e, t, r) => {
    if (!e) return;
    if (e in r) return r[e];
    let n = rt.get(e);
    if (!n) {
      let i3 = [], o = "", a = 0;
      for (let l = 0; l < e.length; l++) {
        let c = e[l];
        c === "[" ? (a++, o += c) : c === "]" ? (a--, o += c) : c === "." && a === 0 ? o && (i3.push(o), o = "") : o += c;
      }
      o && i3.push(o), n = [];
      for (let l of i3) {
        let c = or(l.trim());
        n.push(...c);
      }
      rt.set(e, n);
    }
    let s = t;
    for (let i3 = 0; i3 < n.length; i3++) {
      let o = n[i3];
      if (o.type === "property" && o.value in r) {
        s = r[o.value];
        continue;
      }
      if (s == null) return;
      (o.type === "property" || o.type === "index") && (s = s[o.value]);
    }
    return s;
  };
  var ar = (e, t, r, n) => {
    let s = [];
    for (let i3 of e) if (typeof i3 == "string") s.push(i3);
    else {
      let o = A(i3, t, r, n);
      s.push(o != null ? String(o) : "");
    }
    return s.join("");
  };
  var nt = (e, t, r, n) => {
    let s = t.functions || t, i3 = s[e.name];
    if (!i3) throw tt(e.name, s);
    let o = e.args.map((a) => A(a, t, r, n));
    return i3(...o);
  };
  var G = (e, t, r, n) => {
    if (e.var && !e.type) return k(e.var, r, n);
    switch (e.type) {
      case d.VARIABLE:
        return k(e.path, r, n);
      case d.LITERAL:
        return e.value;
      case d.BINARY:
        return it(e, t, r, n);
      case d.UNARY:
        return st(e, t, r, n);
      case d.FUNCTION:
        return nt(e, t, r, n);
      default:
        return A(e, t, r, n);
    }
  };
  var it = (e, t, r, n) => {
    if (e.op === x.AND || e.op === x.OR) {
      let o = G(e.left, t, r, n), a = G(e.right, t, r, n);
      switch (e.op) {
        case x.AND:
          return o && a;
        case x.OR:
          return o || a;
      }
    }
    let s = A(e.left, t, r, n), i3 = A(e.right, t, r, n);
    switch (e.op) {
      case x.EQ:
        return s == i3;
      case x.NEQ:
        return s != i3;
      case x.GT:
        return s > i3;
      case x.LT:
        return s < i3;
      case x.GTE:
        return s >= i3;
      case x.LTE:
        return s <= i3;
      case x.IN:
        return Array.isArray(i3) ? i3.includes(s) : false;
      case x.ADD:
        if (typeof s != "number" || typeof i3 != "number") throw new L(`Arithmetic operations require numbers. Got ${typeof s} + ${typeof i3}`);
        return s + i3;
      case x.SUBTRACT:
        if (typeof s != "number" || typeof i3 != "number") throw new L(`Arithmetic operations require numbers. Got ${typeof s} - ${typeof i3}`);
        return s - i3;
      default:
        throw new Error(`Unknown binary operator: ${e.op}`);
    }
  };
  var st = (e, t, r, n) => {
    let s = e.op === Z.NOT ? G(e.operand, t, r, n) : A(e.operand, t, r, n);
    switch (e.op) {
      case Z.NOT:
        return !s;
      default:
        throw new Error(`Unknown unary operator: ${e.op}`);
    }
  };
  var cr = (e, t, r, n) => {
    if (e.conditions.length === 2 && e.conditions[1] === null) {
      let s = e.conditions[0];
      if (s.type === d.VARIABLE) if (k(s.path, r, n)) {
        let o = e.bodies[0];
        if (o.type === d.OBJECT && o.properties.length <= 5) {
          let a = {};
          for (let l of o.properties) {
            let c = l.parsedKey ? A(l.parsedKey, t, r, n) : l.key, u = l.value;
            if (u.type === d.LITERAL) a[c] = u.value;
            else if (u.type === d.VARIABLE) a[c] = k(u.path, r, n);
            else if (u.type === d.INTERPOLATION) {
              let f = [];
              for (let p2 of u.parts) if (typeof p2 == "string") f.push(p2);
              else if (p2.type === d.VARIABLE) {
                let y = k(p2.path, r, n);
                f.push(y != null ? String(y) : "");
              } else {
                let y = A(p2, t, r, n);
                f.push(y != null ? String(y) : "");
              }
              a[c] = f.join("");
            } else a[c] = A(u, t, r, n);
          }
          return a;
        }
      } else {
        let o = e.bodies[1];
        if (o.type === d.OBJECT && o.properties.length <= 5) {
          let a = {};
          for (let l of o.properties) {
            let c = l.parsedKey ? A(l.parsedKey, t, r, n) : l.key, u = l.value;
            if (u.type === d.LITERAL) a[c] = u.value;
            else if (u.type === d.VARIABLE) a[c] = k(u.path, r, n);
            else if (u.type === d.INTERPOLATION) {
              let f = [];
              for (let p2 of u.parts) if (typeof p2 == "string") f.push(p2);
              else if (p2.type === d.VARIABLE) {
                let y = k(p2.path, r, n);
                f.push(y != null ? String(y) : "");
              } else {
                let y = A(p2, t, r, n);
                f.push(y != null ? String(y) : "");
              }
              a[c] = f.join("");
            } else a[c] = A(u, t, r, n);
          }
          return a;
        }
      }
    }
    return null;
  };
  var lr = (e, t, r, n) => {
    let s = cr(e, t, r, n);
    if (s !== null) return s;
    for (let i3 = 0; i3 < e.conditions.length; i3++) {
      let o = e.conditions[i3];
      if (o === null || G(o, t, r, n)) return A(e.bodies[i3], t, r, n);
    }
    return ot;
  };
  var ur = (e, t) => {
    let r = e.body, n = e.itemVar;
    if (r.type === d.CONDITIONAL && r.conditions.length === 1 && r.conditions[0].type === d.VARIABLE) {
      let s = r.conditions[0].path, i3 = r.bodies[0];
      if (s.startsWith(n + ".")) {
        let o = s.substring(n.length + 1);
        if (i3.type === d.OBJECT && i3.properties.length <= 5) {
          for (let l of i3.properties) if (l.parsedKey) return null;
          let a = [];
          for (let l = 0; l < t.length; l++) {
            let c = t[l];
            if (c[o]) {
              let u = {};
              for (let f of i3.properties) {
                let p2 = f.key, y = f.value;
                if (y.type === d.LITERAL) u[p2] = y.value;
                else if (y.type === d.VARIABLE) {
                  let h = y.path;
                  if (h === n) u[p2] = c;
                  else if (h.startsWith(n + ".")) {
                    let g = h.substring(n.length + 1);
                    u[p2] = c[g];
                  } else return null;
                } else if (y.type === d.INTERPOLATION) {
                  let h = [], g = true;
                  for (let v of y.parts) if (typeof v == "string") h.push(v);
                  else if (v.type === d.VARIABLE) {
                    let m = v.path;
                    if (m === n) h.push(c != null ? String(c) : "");
                    else if (m.startsWith(n + ".")) {
                      let I2 = m.substring(n.length + 1), b = c[I2];
                      h.push(b != null ? String(b) : "");
                    } else {
                      g = false;
                      break;
                    }
                  } else {
                    g = false;
                    break;
                  }
                  if (!g) return null;
                  u[p2] = h.join("");
                } else return null;
              }
              a.push(u);
            }
          }
          return a;
        }
      }
    }
    return null;
  };
  var fr = (e, t) => {
    let r = e.body, n = e.itemVar, s = ur(e, t);
    if (s !== null) return s;
    if (r.type === d.OBJECT && r.properties.length <= 5) {
      for (let a of r.properties) if (a.parsedKey) return null;
      let i3 = [], o = true;
      for (let a of r.properties) {
        let l = a.key, c = a.value;
        if (c.type === d.LITERAL) i3.push({ key: l, type: "literal", value: c.value });
        else if (c.type === d.VARIABLE) {
          let u = c.path;
          if (u === n) i3.push({ key: l, type: "item" });
          else if (u.startsWith(n + ".")) {
            let f = u.substring(n.length + 1);
            if (!f.includes(".") && !f.includes("[")) i3.push({ key: l, type: "prop", prop: f });
            else {
              o = false;
              break;
            }
          } else {
            o = false;
            break;
          }
        } else if (c.type === d.INTERPOLATION && c.parts.length === 1) {
          let u = c.parts[0];
          if (u.type === d.VARIABLE) {
            let f = u.path;
            if (f === n) i3.push({ key: l, type: "item_string" });
            else if (f.startsWith(n + ".")) {
              let p2 = f.substring(n.length + 1);
              if (!p2.includes(".") && !p2.includes("[")) i3.push({ key: l, type: "prop_string", prop: p2 });
              else {
                o = false;
                break;
              }
            } else {
              o = false;
              break;
            }
          } else {
            o = false;
            break;
          }
        } else {
          o = false;
          break;
        }
      }
      if (o) {
        let a = new Array(t.length);
        if (i3.length === 3 && i3[0].type === "prop" && i3[0].key === "id" && i3[1].type === "prop_string" && i3[1].key === "title" && i3[2].type === "prop" && i3[2].key === "completed") for (let l = 0; l < t.length; l++) {
          let c = t[l];
          a[l] = { id: c.id, title: c.title != null ? String(c.title) : "", completed: c.completed };
        }
        else for (let l = 0; l < t.length; l++) {
          let c = t[l], u = {};
          for (let f of i3) if (f.type === "literal") u[f.key] = f.value;
          else if (f.type === "item") u[f.key] = c;
          else if (f.type === "prop") u[f.key] = c[f.prop];
          else if (f.type === "item_string") u[f.key] = c != null ? String(c) : "";
          else if (f.type === "prop_string") {
            let p2 = c[f.prop];
            u[f.key] = p2 != null ? String(p2) : "";
          }
          a[l] = u;
        }
        return a;
      }
    }
    return null;
  };
  var dr = (e, t, r, n, s) => {
    let i3 = [], o = e.body;
    if (o.type === d.OBJECT && o.fast !== false) {
      let a = e.itemVar, l = e.indexVar;
      for (let c = 0; c < s.length; c++) {
        let u = s[c], f = {}, p2 = { ...n, [a]: u, ...l && { [l]: c } };
        p2.__paths__ || (p2.__paths__ = n.__paths__ || {});
        let y = e.iterable.path || "";
        if (n && n.__paths__ && y) {
          let h = y.split("."), g = h[0];
          g in n.__paths__ && (y = n.__paths__[g], h.length > 1 && (y += "." + h.slice(1).join(".")));
        }
        p2.__paths__ = { ...p2.__paths__, [a]: `${y}[${c}]`, ...l && { [l]: c } };
        for (let h of o.properties) {
          let g = h.parsedKey ? A(h.parsedKey, t, r, p2) : h.key, v = h.value;
          if (v.type === d.LITERAL) f[g] = v.value;
          else if (v.type === d.VARIABLE) {
            let m = v.path;
            if (m === a) f[g] = u;
            else if (m === l) f[g] = c;
            else if (m.startsWith(a + ".")) {
              let I2 = m.substring(a.length + 1);
              !I2.includes(".") && !I2.includes("[") ? f[g] = u[I2] : f[g] = k(m, r, { ...n, [a]: u, ...l && { [l]: c } });
            } else f[g] = k(m, r, { ...n, [a]: u, ...l && { [l]: c } });
          } else if (v.type === d.INTERPOLATION) {
            let m = [];
            for (let I2 of v.parts) if (typeof I2 == "string") m.push(I2);
            else if (I2.type === d.VARIABLE) {
              let b = I2.path, E2;
              if (b === a) E2 = u;
              else if (b === l) E2 = c;
              else if (b.startsWith(a + ".")) {
                let w = b.substring(a.length + 1);
                !w.includes(".") && !w.includes("[") ? E2 = u[w] : E2 = k(b, r, { ...n, [a]: u, ...l && { [l]: c } });
              } else E2 = k(b, r, { ...n, [a]: u, ...l && { [l]: c } });
              m.push(E2 != null ? String(E2) : "");
            } else {
              let b = { ...n, [a]: u, ...l && { [l]: c } }, E2 = A(I2, t, r, b);
              m.push(E2 != null ? String(E2) : "");
            }
            f[g] = m.join("");
          } else {
            let m = { ...n, [a]: u, ...l && { [l]: c } };
            f[g] = A(v, t, r, m);
          }
        }
        i3.push(f);
      }
      return i3;
    }
    return null;
  };
  var pr = (e, t, r) => {
    let n = e.body;
    if (n.type === d.OBJECT && n.properties.length === 1 && n.properties[0].key === "$if item.visible") {
      let i3 = n.properties[0].value;
      if (i3.type === d.CONDITIONAL && i3.conditions.length === 1 && i3.conditions[0].type === d.VARIABLE && i3.conditions[0].path === "item.visible") {
        let o = i3.bodies[0];
        if (o.type === d.OBJECT && o.properties.length === 2) {
          let a = o.properties[0], l = o.properties[1];
          if (a.key === "id" && a.value.type === d.VARIABLE && a.value.path === "item.id" && l.key === "$if item.highlighted" && l.value.type === d.CONDITIONAL) {
            let c = [];
            for (let u = 0; u < t.length; u++) {
              let f = t[u];
              if (f.visible) {
                let p2 = { id: f.id };
                f.highlighted ? (p2.highlight = true, p2.message = `This item is highlighted: ${f.name}`) : (p2.highlight = false, p2.message = f.name), c.push(p2);
              }
            }
            return c;
          }
        }
      }
    }
    return null;
  };
  var hr = (e, t, r, n) => {
    let s = A(e.iterable, t, r, n);
    if (!Array.isArray(s)) {
      let c, u = false;
      if (e.iterable.type === d.FUNCTION) {
        u = true;
        let p2 = e.iterable.args.map((y) => y.type === d.LITERAL ? typeof y.value == "string" ? `'${y.value}'` : String(y.value) : y.type === d.VARIABLE ? y.path : y.type === d.FUNCTION ? `${y.name}(...)` : "?").join(", ");
        c = `${e.iterable.name}(${p2})`;
      } else c = e.iterable.path || "undefined";
      let f = `${e.itemVar}${e.indexVar ? `, ${e.indexVar}` : ""} in ${c}`;
      throw et2(f, s, u);
    }
    if (!e.indexVar) {
      let c = pr(e, s, e.itemVar);
      if (c !== null) return c;
    }
    if (!e.indexVar) {
      let c = fr(e, s);
      if (c !== null) return c;
    }
    let i3 = dr(e, t, r, n, s);
    if (i3 !== null) return i3;
    let o = [], a = e.iterable.path || "";
    if (n && n.__paths__ && a) {
      let c = a.split("."), u = c[0];
      u in n.__paths__ && (a = n.__paths__[u], c.length > 1 && (a += "." + c.slice(1).join(".")));
    }
    let l = false;
    e.body.type === d.ARRAY && (e.body.items.length <= 1 ? l = false : l = e.body._shouldPreserveArray ??= e.body.items.some((c) => c.type === d.OBJECT && c.properties.some((u) => u.key.startsWith("$if ") || u.key.startsWith("$when "))));
    for (let c = 0; c < s.length; c++) {
      let u = e.indexVar ? { ...n, [e.itemVar]: s[c], [e.indexVar]: c } : { ...n, [e.itemVar]: s[c] };
      u.__paths__ || (u.__paths__ = n.__paths__ || {}), u.__paths__ = { ...u.__paths__, [e.itemVar]: `${a}[${c}]` }, e.indexVar && (u.__paths__[e.indexVar] = c);
      let f = A(e.body, t, r, u);
      Array.isArray(f) && f.length === 1 && !l ? o.push(f[0]) : o.push(f);
    }
    return o;
  };
  var yr = (e, t, r, n) => {
    if (e.whenCondition) return null;
    if (e.properties.length === 1) {
      let s = e.properties[0], i3 = s.parsedKey ? A(s.parsedKey, t, r, n) : s.key, o = s.value;
      if (o.type === d.OBJECT && o.properties.length <= 10 && !o.whenCondition) {
        let a = {}, l = {}, c = true;
        for (let u of o.properties) {
          let f = u.parsedKey ? A(u.parsedKey, t, r, n) : u.key, p2 = u.value;
          if (p2.type === d.LITERAL) l[f] = p2.value;
          else if (p2.type === d.VARIABLE) l[f] = k(p2.path, r, n);
          else if (p2.type === d.INTERPOLATION) {
            let y = [];
            for (let h of p2.parts) if (typeof h == "string") y.push(h);
            else if (h.type === d.VARIABLE) {
              let g = k(h.path, r, n);
              y.push(g != null ? String(g) : "");
            } else {
              c = false;
              break;
            }
            if (!c) break;
            l[f] = y.join("");
          } else if (p2.type === d.OBJECT && p2.properties.length <= 5) {
            let y = {};
            for (let h of p2.properties) {
              let g = h.key, v = h.value;
              if (v.type === d.LITERAL) y[g] = v.value;
              else if (v.type === d.VARIABLE) y[g] = k(v.path, r, n);
              else if (v.type === d.INTERPOLATION) {
                let m = [];
                for (let I2 of v.parts) if (typeof I2 == "string") m.push(I2);
                else if (I2.type === d.VARIABLE) {
                  let b = k(I2.path, r, n);
                  m.push(b != null ? String(b) : "");
                } else {
                  c = false;
                  break;
                }
                if (!c) break;
                y[g] = m.join("");
              } else {
                c = false;
                break;
              }
            }
            if (!c) break;
            l[f] = y;
          } else {
            c = false;
            break;
          }
        }
        if (c) return a[i3] = l, a;
      }
    }
    return null;
  };
  var mr = (e, t, r, n) => {
    let s = t.functions || t;
    if (e.whenCondition && !G(e.whenCondition, s, r, n)) return;
    let i3 = yr(e, t, r, n);
    if (i3 !== null) return i3;
    if (e.fast) {
      let c = {};
      for (let u of e.properties) {
        let f = u.parsedKey ? A(u.parsedKey, t, r, n) : u.key, p2 = u.value;
        if (p2.type === d.LITERAL) c[f] = p2.value;
        else if (p2.type === d.VARIABLE) c[f] = k(p2.path, r, n);
        else if (p2.type === d.INTERPOLATION) {
          let y = [];
          for (let h of p2.parts) if (typeof h == "string") y.push(h);
          else if (h.type === d.VARIABLE) {
            let g = k(h.path, r, n);
            y.push(g != null ? String(g) : "");
          } else {
            let g = A(h, t, r, n);
            y.push(g != null ? String(g) : "");
          }
          c[f] = y.join("");
        } else c[f] = A(p2, t, r, n);
      }
      return c;
    }
    let o = {}, a = null, l = false;
    for (let c of e.properties) if (!c.key.startsWith("$if ") && !c.key.match(/^\$if\s+\w+.*:?$/) && !c.key.startsWith("$elif") && !c.key.startsWith("$else") && !c.key.startsWith("$for ")) {
      l = true;
      break;
    }
    for (let c of e.properties) if (c.key.startsWith("$if ") || c.key.match(/^\$if\s+\w+.*:?$/)) {
      let u = A(c.value, t, r, n);
      if (!l && u !== null && u !== void 0) return Array.isArray(u) && u.length === 1 ? u[0] : u;
      typeof u == "object" && u !== null && !Array.isArray(u) && Object.assign(o, u);
    } else if (c.key.startsWith("$for ")) {
      if (e.properties.length === 1) return A(c.value, t, r, n);
    } else {
      let u = c.value;
      if (u && u.type === d.OBJECT && u.properties) {
        let f = u.properties.find((p2) => p2.key.startsWith("$for "));
        if (f) {
          let p2 = A(f.value, t, r, n);
          p2 !== void 0 && (o[c.key] = p2);
        } else {
          let p2 = A(c.value, t, r, n);
          p2 !== void 0 && (o[c.key] = p2);
        }
      } else {
        let f = c.parsedKey ? A(c.parsedKey, t, r, n) : c.key, p2 = A(c.value, t, r, n);
        p2 !== void 0 && (o[f] = p2);
      }
    }
    return o;
  };
  var ot = {};
  var gr = (e, t, r, n) => {
    let s = [];
    for (let i3 of e.items) if (i3.type === d.LOOP) {
      let o = A(i3, t, r, n);
      Array.isArray(o) && i3.flatten !== false ? s.push(...o) : s.push(o);
    } else {
      let o = A(i3, t, r, n);
      o !== ot && o !== void 0 && s.push(o);
    }
    return s;
  };
  var Ir = (e, t, r, n) => {
    let { name: s, data: i3, whenCondition: o } = e, a = t.partials || {}, l = t.functions || t;
    if (o && !G(o, l, r, n)) return;
    if (!a[s]) throw new L(`Partial '${s}' is not defined`);
    let c = n._partialStack || [];
    if (c.includes(s)) throw new L(`Circular partial reference detected: ${s}`);
    let u = a[s], f = r, p2 = { ...n, _partialStack: [...c, s] };
    if (n) {
      f = { ...r };
      for (let y of Object.keys(n)) y.startsWith("_") || (f[y] = n[y]);
    }
    if (i3) {
      let y = A(i3, t, r, n);
      f = { ...f, ...y };
    }
    return A(u, t, f, p2);
  };
  var vr = (e, t, r, n) => {
    let { path: s } = e, i3 = s.split("."), o = i3[0], a = i3.slice(1);
    if (!n || !(o in n)) throw new L(`Path reference '#{${s}}' refers to '${o}' which is not a loop variable in the current scope`);
    if (n.__paths__ || (n.__paths__ = {}), !(o in n.__paths__)) throw new L(`Path reference '#{${s}}' cannot be resolved - path tracking may not be initialized properly`);
    let l = n.__paths__[o];
    if (typeof l == "number") {
      if (a.length > 0) throw new L(`Path reference '#{${s}}' - cannot access properties on index variable '${o}'`);
      return String(l);
    }
    return a.length > 0 && (l += "." + a.join(".")), l;
  };
  var Oe = sr;
  var _r = /\$\{([^}]*)\}/g;
  var Ar = /#\{([^}]*)\}/g;
  var ct = (e, t = {}) => {
    let r = e.match(/^(\w+)\((.*)\)$/);
    if (!r) return { isFunction: false };
    let [, n, s] = r, i3 = br(s, t);
    return { isFunction: true, type: d.FUNCTION, name: n, args: i3 };
  };
  var br = (e, t = {}) => e.trim() ? Er(e).map((n) => xr(n.trim(), t)) : [];
  var Er = (e) => {
    let t = [], r = "", n = 0, s = false, i3 = "";
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = o > 0 ? e[o - 1] : "";
      !s && (a === '"' || a === "'") ? (s = true, i3 = a, r += a) : s && a === i3 && l !== "\\" ? (s = false, i3 = "", r += a) : !s && a === "(" ? (n++, r += a) : !s && a === ")" ? (n--, r += a) : !s && a === "," && n === 0 ? (t.push(r), r = "") : r += a;
    }
    return r && t.push(r), t;
  };
  var xr = (e, t = {}) => {
    if (e.startsWith('"') && e.endsWith('"') || e.startsWith("'") && e.endsWith("'")) return { type: d.LITERAL, value: e.slice(1, -1) };
    if (/^-?\d+(\.\d+)?$/.test(e)) return { type: d.LITERAL, value: parseFloat(e) };
    if (e === "true") return { type: d.LITERAL, value: true };
    if (e === "false") return { type: d.LITERAL, value: false };
    if (e === "null") return { type: d.LITERAL, value: null };
    let r = ct(e, t);
    if (r.isFunction) return { type: r.type, name: r.name, args: r.args };
    let n = e.trim(), s = [{ op: " + ", type: "ADD" }, { op: " - ", type: "SUBTRACT" }], i3 = -1, o = null;
    for (let { op: a, type: l } of s) {
      let c = 0;
      for (; c < n.length; ) {
        let u = j(n.substring(c), a);
        if (u === -1) break;
        let f = c + u;
        f > i3 && (i3 = f, o = { op: a, type: l }), c = f + a.length;
      }
    }
    if (i3 !== -1) try {
      return O(n, t);
    } catch {
      return { type: d.VARIABLE, path: n };
    }
    return { type: d.VARIABLE, path: n };
  };
  var lt = /^\w+\(.*\)$/;
  var wr = /\s[+\-*/%]\s|\|\||&&|\?\?|.*\?.*:/;
  var Pr = (e) => {
    if (!(!e || e.trim() === "" || lt.test(e)) && wr.test(e)) throw e.includes("?") && e.includes(":") ? new _(`Complex expressions not supported in variable replacements - consider calculating the value in your data instead. Offending expression: "${e}"`) : e.includes("||") || e.includes("&&") || e.includes("??") ? new _(`Logical operators not supported in variable replacements - consider calculating the value in your data instead (operators like ||, &&, ?? are not supported). Offending expression: "${e}"`) : new _(`Arithmetic expressions not supported in variable replacements - consider calculating '${e}' in your data instead (expressions with +, -, *, /, % are not supported). Offending expression: "${e}"`);
  };
  var at = (e) => {
    let t = e.trim();
    if (lt.test(t)) throw new _(`Functions are not supported in path references - path references can only refer to loop variables. Offending expression: "#{${e}}"`);
    if (t.includes("[")) throw new _(`Array indices not supported in path references - use simple variable names or properties. Offending expression: "#{${e}}"`);
    if (/[+\-*/%]/.test(t)) throw new _(`Arithmetic expressions not supported in path references - path references can only refer to loop variables. Offending expression: "#{${e}}"`);
    if (/\|\||&&/.test(t)) throw new _(`Logical operators not supported in path references - path references can only refer to loop variables. Offending expression: "#{${e}}"`);
    if (t.includes("?") && t.includes(":")) throw new _(`Complex expressions not supported in path references - path references can only refer to loop variables. Offending expression: "#{${e}}"`);
    return { type: d.PATH_REFERENCE, path: t };
  };
  var ee = (e, t = {}) => {
    let r = e.trim();
    Pr(r);
    let n = ct(r, t);
    if (n.isFunction) return { type: n.type, name: n.name, args: n.args };
    if (r.includes("[") && !/[\s+\-*/%|&?:]/.test(r)) {
      let s = 0;
      for (let i3 of r) i3 === "[" ? s++ : i3 === "]" && s--;
      if (s !== 0) throw new Error("Invalid array index syntax");
    }
    return { type: d.VARIABLE, path: r };
  };
  var Le = (e, t = {}) => {
    let r = e, n = [];
    (e.includes("\\${") || e.includes("\\#{")) && (r = e.replace(/\\\\(\$\{[^}]*\})/g, "\\DOUBLE_ESC_VAR$1"), r = r.replace(/\\\\(#\{[^}]*\})/g, "\\DOUBLE_ESC_PATH$1"), r = r.replace(/\\(\$\{[^}]*\})/g, (c, u) => {
      let f = `__ESCAPED_${n.length}__`;
      return n.push(u), f;
    }), r = r.replace(/\\(#\{[^}]*\})/g, (c, u) => {
      let f = `__ESCAPED_${n.length}__`;
      return n.push(u), f;
    }), r = r.replace(/\\DOUBLE_ESC_VAR/g, "\\"), r = r.replace(/\\DOUBLE_ESC_PATH/g, "\\"));
    let s = [...r.matchAll(_r)], i3 = [...r.matchAll(Ar)], o = [...s.map((c) => ({ match: c, type: "variable" })), ...i3.map((c) => ({ match: c, type: "pathref" }))].sort((c, u) => c.match.index - u.match.index);
    if (o.length === 0) {
      let c = r;
      for (let u = 0; u < n.length; u++) c = c.replace(`__ESCAPED_${u}__`, n[u]);
      return { type: d.LITERAL, value: c };
    }
    if (o.length === 1 && o[0].match[0] === r && n.length === 0) {
      let { match: c, type: u } = o[0];
      try {
        return u === "variable" ? ee(c[1], t) : at(c[1]);
      } catch (f) {
        if (f.message === "Invalid array index syntax") return { type: d.LITERAL, value: r };
        throw f;
      }
    }
    let a = [], l = 0;
    for (let { match: c, type: u } of o) {
      let [f, p2] = c, y = c.index;
      if (y > l) {
        let h = r.substring(l, y);
        for (let g = 0; g < n.length; g++) h = h.replace(`__ESCAPED_${g}__`, n[g]);
        h && a.push(h);
      }
      try {
        let h;
        u === "variable" ? h = ee(p2.trim(), t) : h = at(p2.trim()), a.push(h);
      } catch (h) {
        if (h.message === "Invalid array index syntax") a.push(f);
        else throw h;
      }
      l = y + f.length;
    }
    if (l < r.length) {
      let c = r.substring(l);
      for (let u = 0; u < n.length; u++) c = c.replace(`__ESCAPED_${u}__`, n[u]);
      c && a.push(c);
    }
    return { type: d.INTERPOLATION, parts: a };
  };
  var V = (e, t) => typeof e == "string" ? Le(e, t) : typeof e == "object" && e !== null ? Array.isArray(e) ? kr(e, t) : $r(e, t) : { type: d.LITERAL, value: e };
  var kr = (e, t) => {
    let r = [], n = false;
    for (let s = 0; s < e.length; s++) {
      let i3 = e[s];
      if (typeof i3 == "object" && i3 !== null && !Array.isArray(i3)) {
        let a = Object.keys(i3);
        if (a.length === 1 && /^\$for(?::\w+)?\s/.test(a[0])) {
          let l = Cr(a[0], i3[a[0]], t);
          r.push(l), n = true;
          continue;
        }
      }
      let o = V(i3, t);
      r.push(o), (o.type === d.FUNCTION || o.type === d.CONDITIONAL || o.type === d.LOOP || o.type === d.PARTIAL || o.type === d.OBJECT && !o.fast || o.type === d.ARRAY && !o.fast) && (n = true);
    }
    return { type: d.ARRAY, items: r, fast: !n };
  };
  var $r = (e, t) => {
    let r = [], n = false, s = null, i3 = Object.entries(e), o = 0;
    if (e.$partial !== void 0) {
      if (typeof e.$partial != "string") throw new _("$partial value must be a string");
      if (e.$partial.trim() === "") throw new _("$partial value cannot be an empty string");
      let l = ["$if", "$elif", "$else", "$for"], c = [];
      for (let [m] of i3) for (let I2 of l) if (m === I2 || m.startsWith(I2 + " ") || m.startsWith(I2 + "#")) {
        c.push(I2);
        break;
      }
      if (c.length > 0) throw new _(`Cannot use $partial with ${c.join(", ")} at the same level. Wrap $partial in a parent object if you need conditionals.`);
      let { $partial: u, $when: f, ...p2 } = e, y = {}, h = false;
      for (let [m, I2] of Object.entries(p2)) {
        let b = m;
        (m.startsWith("\\$") || m.startsWith("$$")) && (b = m.slice(1)), y[b] = I2, h = true;
      }
      let g = null;
      if (h && (g = V(y, t), g.type === d.OBJECT)) {
        let m = false;
        for (let I2 of g.properties) if (I2.value.type === d.VARIABLE || I2.value.type === d.INTERPOLATION || I2.value.type === d.FUNCTION || I2.value.type === d.CONDITIONAL || I2.value.type === d.OBJECT && !I2.value.fast || I2.value.type === d.ARRAY && !I2.value.fast) {
          m = true;
          break;
        }
        m && (g.fast = false);
      }
      let v = { type: d.PARTIAL, name: u, data: g };
      if (f !== void 0) {
        let m;
        if (typeof f == "string") {
          if (f.trim() === "") throw new _("Empty condition expression after '$when'");
          m = O(f, t);
        } else m = { type: d.LITERAL, value: f };
        v.whenCondition = m;
      }
      return v;
    }
    for (let [l, c] of i3) if (l === "$when") {
      if (s !== null) throw new _("Multiple '$when' directives on the same object are not allowed");
      if (c == null) throw new _("Missing condition expression after '$when'");
      let u = typeof c == "string" ? c : JSON.stringify(c);
      if (u.trim() === "") throw new _("Empty condition expression after '$when'");
      s = O(u, t), n = true;
    } else if (l.startsWith("$when#") || l.startsWith("$when ")) throw new _("'$when' does not support ID syntax or inline conditions - use '$when' as a property");
    for (; o < i3.length; ) {
      let [l, c] = i3[o];
      if (l === "$when") {
        o++;
        continue;
      }
      if (l.startsWith("$if ") || l.match(/^\$if#\w+\s/) || l.match(/^\$if\s+\w+.*:$/)) {
        let u = Or(i3, o, t);
        r.push({ key: l, value: u.node }), n = true, o = u.nextIndex;
      } else if (/^\$for(?::\w+)?\s/.test(l)) {
        let u = l.match(/^\$for(?::(\w+))?\s/)?.[1] || "", f = u ? `:${u}` : "";
        throw new _(`$for loops must be inside arrays - use '- $for${f} item in items:' instead of '$for${f} item in items:'`);
      } else {
        if (l.startsWith("$elif ") || l.startsWith("$else")) throw new _(`'${l.split(" ")[0]}' without matching '$if'`);
        if (l === "$if" || l === "$if:") throw new _("Missing condition expression after '$if'");
        {
          let u = V(c, t);
          (u.type === d.FUNCTION || u.type === d.CONDITIONAL || u.type === d.PARTIAL || u.type === d.OBJECT && !u.fast || u.type === d.ARRAY && !u.fast) && (n = true);
          let f = Le(l, t), p2 = { key: l, value: u };
          (f.type !== d.LITERAL || f.value !== l) && (p2.parsedKey = f), r.push(p2), o++;
        }
      }
    }
    let a = { type: d.OBJECT, properties: r, fast: !n };
    return s && (a.whenCondition = s), a;
  };
  var Or = (e, t, r = {}) => {
    let n = [], s = [], i3 = t, [o, a] = e[i3], l = null, c;
    if (o.startsWith("$if#")) {
      let f = o.match(/^\$if#(\w+)\s+(.+)$/);
      if (f) l = f[1], c = f[2];
      else throw new _(`Invalid conditional syntax: ${o}`);
    } else c = o.substring(4), c.endsWith(":") && (c = c.slice(0, -1).trim());
    $e(c);
    let u = O(c, r);
    for (n.push(u), s.push(V(a, r)), i3++; i3 < e.length; ) {
      let [f, p2] = e[i3], y = false, h;
      if (l ? f.startsWith(`$elif#${l} `) ? (h = f.substring(`$elif#${l} `.length), h.endsWith(":") && (h = h.slice(0, -1).trim()), y = true) : (f === `$else#${l}` || f === `$else#${l}:`) && (y = true, h = null) : f.startsWith("$elif ") ? (h = f.substring(6), h.endsWith(":") && (h = h.slice(0, -1).trim()), y = true) : (f === "$else" || f === "$else:") && (y = true, h = null), y) {
        if (h === null) n.push(null);
        else {
          $e(h);
          let g = O(h, r);
          n.push(g);
        }
        if (s.push(V(p2, r)), i3++, h === null) break;
      } else break;
    }
    return { node: { type: d.CONDITIONAL, conditions: n, bodies: s, id: l }, nextIndex: i3 };
  };
  var O = (e, t = {}) => {
    if (e = e.trim(), e.startsWith("(") && e.endsWith(")")) {
      let c = e.slice(1, -1), u = 0, f = true;
      for (let p2 = 0; p2 < c.length; p2++) if (c[p2] === "(" ? u++ : c[p2] === ")" && u--, u < 0) {
        f = false;
        break;
      }
      if (f && u === 0) return O(c, t);
    }
    let r = j(e, "||");
    if (r !== -1) return { type: d.BINARY, op: x.OR, left: O(e.substring(0, r).trim(), t), right: O(e.substring(r + 2).trim(), t) };
    let n = j(e, "&&");
    if (n !== -1) return { type: d.BINARY, op: x.AND, left: O(e.substring(0, n).trim(), t), right: O(e.substring(n + 2).trim(), t) };
    let s = [{ op: ">=", type: x.GTE }, { op: "<=", type: x.LTE }, { op: "==", type: x.EQ }, { op: "!=", type: x.NEQ }, { op: ">", type: x.GT }, { op: "<", type: x.LT }, { op: " in ", type: x.IN }];
    for (let { op: c, type: u } of s) {
      let f = j(e, c);
      if (f !== -1) return { type: d.BINARY, op: u, left: O(e.substring(0, f).trim(), t), right: O(e.substring(f + c.length).trim(), t) };
    }
    let i3 = -1, o = null, a = [{ op: " + ", type: x.ADD }, { op: " - ", type: x.SUBTRACT }];
    for (let { op: c, type: u } of a) {
      let f = 0;
      for (; f < e.length; ) {
        let p2 = j(e.substring(f), c);
        if (p2 === -1) break;
        let y = f + p2;
        y > i3 && (i3 = y, o = { op: c, type: u }), f = y + c.length;
      }
    }
    if (i3 !== -1 && o) return { type: d.BINARY, op: o.type, left: O(e.substring(0, i3).trim(), t), right: O(e.substring(i3 + o.op.length).trim(), t) };
    let l = [" * ", " / ", " % "];
    for (let c of l) if (j(e, c) !== -1) throw new _(`Arithmetic operations are not allowed in conditionals: "${c}"`);
    return e.startsWith("!") ? { type: d.UNARY, op: Z.NOT, operand: O(e.substring(1).trim(), t) } : ut(e, t);
  };
  var j = (e, t) => {
    let r = 0, n = 0;
    for (; n <= e.length - t.length; ) {
      if (e[n] === "(") r++;
      else if (e[n] === ")") r--;
      else if (r === 0 && e.substring(n, n + t.length) === t) return n;
      n++;
    }
    return -1;
  };
  var Lr = (e) => {
    if (e = e.trim(), e === "true") return { type: d.LITERAL, value: true };
    if (e === "false") return { type: d.LITERAL, value: false };
    if (e === "null") return { type: d.LITERAL, value: null };
    if (e.startsWith('"') && e.endsWith('"') || e.startsWith("'") && e.endsWith("'")) return { type: d.LITERAL, value: e.slice(1, -1) };
    if (e === '""' || e === "''") return { type: d.LITERAL, value: "" };
    if (e === "{}") return { type: d.LITERAL, value: {} };
    if (e === "[]") return { type: d.LITERAL, value: [] };
    let t = Number(e);
    return !isNaN(t) && isFinite(t) ? { type: d.LITERAL, value: t } : { type: d.VARIABLE, path: e };
  };
  var ut = (e, t) => {
    let r = e.trim();
    if (r.match(/^(\w+)\((.*)\)$/)) return ee(r, t);
    let s = Lr(r);
    if (s.type === d.LITERAL) return s;
    if (/^[a-zA-Z_$][\w.$]*$/.test(r)) return { type: d.VARIABLE, path: r };
    try {
      return ee(r, t);
    } catch (i3) {
      if (i3.message && i3.message.includes("not supported")) return s;
      throw i3;
    }
  };
  var Cr = (e, t, r) => {
    let n = /^\$for(?::(\w+))?\s+(.+)$/, s = e.match(n);
    if (!s) throw new _(`Invalid loop syntax (got: '${e}')`);
    let i3 = s[1], o = s[2].trim();
    Ze(o);
    let a = o.match(/^(.+?)\s+in\s+(.+)$/);
    if (!a) throw new _(`Invalid loop syntax - missing 'in' keyword (got: '$for ${o}')`);
    let l = a[1].trim(), c = a[2].trim(), u, f = null;
    if (l.includes(",")) {
      let h = l.split(",").map((g) => g.trim());
      if (h.length !== 2) throw new _(`Invalid loop variables: ${l}. Expected format: "item" or "item, index"`);
      u = h[0], f = h[1];
    } else u = l;
    let p2 = ut(c, r), y = V(t, r);
    return { type: d.LOOP, itemVar: u, indexVar: f, iterable: p2, body: y, flatten: i3 !== "nested" };
  };
  var Rr = (e, t = {}) => {
    let { functions: r = {} } = t;
    return V(e, r);
  };
  var pe = Rr;
  var Ce = {};
  K(Ce, { now: () => Tr });
  var Tr = () => Date.now();
  var Sr = (e, t, r = {}) => {
    let { functions: n = {}, partials: s = {} } = r, i3 = { ...Ce, ...n }, o = pe(e, { functions: i3 }), a = {};
    for (let [l, c] of Object.entries(s)) a[l] = pe(c, { functions: i3 });
    return Oe(o, t, { functions: i3, partials: a });
  };
  var M = Sr;
  var Re = { objectValues: (e) => Object.entries(e).map(([t, r]) => ({ id: t, ...r })) };
  var Nr = () => ({ elements: [{ id: "story", type: "container", x: 0, y: 0, children: [] }], transitions: [] });
  var ft = ({ elements: e }, { presentationState: t, resources: r }) => {
    if (t.screen) {
      let n = e.find((s) => s.id === "story");
      if (!n) return;
      if (t.screen.resourceId && t.screen.resourceType === "layout") {
        let s = r.layouts[t.screen.resourceId];
        s && n.children.unshift({ id: "screen", type: "container", children: s.elements });
      }
    }
  };
  var dt = ({ elements: e, transitions: t }, { presentationState: r, resources: n, ui: s, resolveFile: i3 }) => {
    if (r.background) {
      let o = e.find((a) => a.id === "story");
      if (!o) return;
      if (r.background.resourceId && r.background.resourceType === "image") {
        let a = n.images[r.background.resourceId];
        o.children.push({ id: `bg-cg-${r.background.resourceId}`, type: "sprite", x: 0, y: 0, url: i3(a.fileId) });
      }
      if (r.background.resourceId && r.background.resourceType === "layout") {
        let a = n.layouts[r.background.resourceId];
        o.children.push({ id: `bg-cg-${r.background.resourceId}`, type: "container", children: a.elements });
      }
      if (r.background.animations) {
        if (r.background.animations.in) {
          let a = r.background.animations.in.animationId, l = n.animations[a];
          l && t.push({ id: "bg-cg-animation-in", type: "keyframes", event: "add", elementId: `bg-cg-${r.background.resourceId}`, properties: l.properties });
        }
        if (r.background.animations.out) {
          let a = r.background.animations.out.animationId, l = r.background.animations.out.resourceId, c = n.animations[a];
          c && t.push({ id: "bg-cg-animation-out", type: "keyframes", event: "remove", elementId: `bg-cg-${l}`, properties: c.properties });
        }
        if (r.background.animations.update) {
          let a = r.background.animations.update.animationId, l = n.animations[a];
          l && t.push({ id: "bg-cg-animation-update", type: "keyframes", event: "update", elementId: `bg-cg-${r.background.resourceId}`, properties: l.properties });
        }
      }
    }
  };
  var pt = ({ elements: e, transitions: t }, { presentationState: r, resources: n, resolveFile: s }) => {
    if (r.character) {
      let i3 = e.find((a) => a.id === "story");
      if (!i3) return;
      let o = r.character.items;
      for (let a of o) {
        let { transformId: l, sprites: c } = a;
        if (a.animations && a.animations.out && !c && !l) {
          let h = a.animations.out.animationId, g = n.animations[h];
          if (g) {
            let v = { id: "character-animation-out", type: "keyframes", event: "remove", elementId: `character-container-${a.id}`, properties: g.properties };
            t.push(v);
          }
          continue;
        }
        if (!c || !l) {
          console.warn("Character item missing sprites or transformId:", a);
          continue;
        }
        let u = c.map(({ imageId: h }) => h), f = n.transforms[l], p2 = { type: "container", id: `character-container-${a.id}`, x: f.x, y: f.y, anchorX: f.anchorX, anchorY: f.anchorY, rotation: f.rotation, scaleX: f.scaleX, scaleY: f.scaleY, children: [] }, y = [];
        Object.entries(n.characters).flatMap(([h, g]) => {
          let { sprites: v } = g;
          Object.entries(v).map(([m, I2]) => {
            u.includes(m) && y.push({ partId: m, fileId: I2.fileId });
          });
        });
        for (let h of y) p2.children.push({ type: "sprite", id: `${a.id}-${h.partId}`, url: s(h.fileId), x: 0, y: 0 });
        if (i3.children.push(p2), a.animations) {
          if (a.animations.in) {
            let h = a.animations.in.animationId, g = n.animations[h];
            g && t.push({ id: "character-animation-in", type: "keyframes", event: "add", elementId: `character-container-${a.id}`, properties: g.properties });
          }
          if (a.animations.update) {
            let h = a.animations.update.animationId, g = n.animations[h];
            if (g) {
              let v = { id: "character-animation-update", type: "keyframes", event: "update", elementId: `character-container-${a.id}`, properties: g.properties };
              t.push(v);
            }
          }
        }
      }
    }
  };
  var ht = ({ elements: e, transitions: t }, { presentationState: r, resources: n, resolveFile: s }) => {
    if (r.visual) {
      let i3 = e.find((a) => a.id === "story");
      if (!i3) return;
      let o = r.visual.items;
      for (let a of o) {
        if (a.resourceId && a.resourceType) {
          let l;
          if (a.resourceType === "image") l = n.images[a.resourceId];
          else continue;
          if (l) {
            let c = n.transforms[a.transformId];
            i3.children.push({ id: `visual-${a.id}`, type: "sprite", url: s(l.fileId), x: c.x, y: c.y, anchorX: c.anchorX, anchorY: c.anchorY, rotation: c.rotation, scaleX: c.scaleX, scaleY: c.scaleY });
          }
        }
        if (a.animations) {
          if (a.animations.in) {
            let l = a.animations.in.animationId || a.animations.in, c = n.animations[l];
            c && t.push({ id: `${a.id}-animation`, type: "keyframes", event: "add", elementId: `visual-${a.id}`, properties: c.properties });
          }
          if (a.animations.out) {
            let l = a.animations.out.animationId || a.animations.out, c = n.animations[l];
            c && t.push({ id: `${a.id}-animation-2`, type: "keyframes", event: "remove", elementId: `visual-${a.id}`, properties: c.properties });
          }
        }
      }
    }
  };
  var yt = ({ elements: e }, { presentationState: t, resources: r, systemState: n, systemStore: s }) => {
    if (!t.dialogue || n?.dialogueUIHidden) return;
    let i3 = e.find((p2) => p2.id === "story");
    if (!i3) return;
    let o = r.layouts[t.dialogue.layoutId];
    if (!o) return;
    let a;
    t.dialogue.characterId && (a = r.characters[t.dialogue.characterId]), t.dialogue.character && (a = { ...a, name: t.dialogue.character.name });
    let l = { elements: o.elements }, c = { variables: n?.variables || {}, saveDataArray: s.selectSaveDataPage({ page: n?.variables.currentSavePageIndex, numberPerPage: 6 }), autoMode: s.selectAutoMode(), skipMode: s.selectSkipMode(), dialogue: { character: { name: a?.name || "" }, content: t.dialogue.content, lines: t.dialogue.lines }, currentLanguagePackId: s.selectCurrentLanguagePackId(), i18n: s.selectCurrentLanguagePackKeys() }, u = M(l, c, { functions: Re });
    u = M(u, { i18n: s.selectCurrentLanguagePackKeys() });
    let f = u?.elements;
    if (Array.isArray(f)) for (let p2 of f) i3.children.push(structuredClone(p2));
    else f && i3.children.push(structuredClone(f));
  };
  var mt = ({ elements: e, transitions: t }, { presentationState: r, resources: n, ui: s }) => {
    if (r.choice) {
      let i3 = e.find((u) => u.id === "story");
      if (!i3) return;
      let a = { elements: n.layouts[r.choice.layoutId].elements }, c = M(a, { choice: { items: r.choice.items } })?.elements;
      if (Array.isArray(c)) for (let u of c) i3.children.push(structuredClone(u));
      else c && i3.children.push(structuredClone(c));
    }
  };
  var gt = ({ elements: e }, { presentationState: t, resources: r, resolveFile: n }) => {
    if (t.bgm) {
      let s = e.find((o) => o.id === "story");
      if (!s) return;
      let i3 = r.audio[t.bgm.audioId];
      s.children.push({ id: "bgm", type: "audio", url: n(i3.fileId) });
    }
  };
  var It = ({ elements: e }, { presentationState: t, resources: r, resolveFile: n }) => {
    if (t.sfx) {
      let s = e.find((o) => o.id === "story");
      if (!s) return;
      let i3 = t.sfx.items;
      for (let o of i3) {
        let a = r.audio[o.audioId];
        s.children.push({ id: o.id, type: "audio", url: n(a.fileId) });
      }
    }
  };
  var vt = ({ elements: e }, { presentationState: t, resolveFile: r }) => {
    if (!t.voice) return;
    let n = e.find((a) => a.id === "story");
    if (!n) return;
    let { fileId: s, volume: i3, loop: o } = t.voice;
    n.children.push({ id: `voice-${s}`, type: "audio", url: r(s), volume: i3, loop: o });
  };
  var _t = ({ elements: e, transitions: t }, { presentationState: r, resources: n, resolveFile: s, systemState: i3, systemStore: o }) => {
    if (r.layout) {
      let a = e.find((h) => h.id === "story");
      if (!a) return;
      let l = n.layouts[r.layout.layoutId];
      if (!l) return;
      Array.isArray(l.transitions) && l.transitions.forEach((h) => {
        t.push(h);
      });
      let c = (h) => {
        let g = { ...h };
        if (h.url && h.url.startsWith("file:")) {
          let v = h.url.replace("file:", "");
          g.url = s(v);
        }
        return h.children && Array.isArray(h.children) && (g.children = h.children.map(c)), g;
      }, u = { id: `layout-${r.layout.layoutId}`, type: "container", x: 0, y: 0, children: l.elements || [] }, f = { variables: i3?.variables || {}, saveDataArray: o.selectSaveDataPage({ page: i3?.variables.currentSavePageIndex, numberPerPage: 6 }), autoMode: o.selectAutoMode(), skipMode: o.selectSkipMode(), globalAudios: o.selectGlobalAudios() || [], currentLanguagePackId: o.selectCurrentLanguagePackId(), i18n: o.selectCurrentLanguagePackKeys(), languagePacks: o.selectLanguagePacks() }, p2 = M(u, f, { functions: Re });
      p2 = M(p2, { i18n: o.selectCurrentLanguagePackKeys() });
      let y = (h) => {
        let g = { ...h };
        if (h.url && h.url.startsWith("file:")) {
          let v = h.url.replace("file:", "");
          g.url = s(v);
        }
        return h.children && Array.isArray(h.children) && (g.children = h.children.map(y)), g;
      };
      a.children.push(y(p2));
    }
  };
  var At = ({ elements: e, transitions: t }, { systemState: r, resources: n, resolveFile: s, systemStore: i3 }) => {
    let o = r.modes[r.currentMode].modals;
    o && o.length > 0 && o.forEach((a, l) => {
      if (a.resourceType === "layout") {
        let c = n.layouts[a.resourceId];
        if (!c) {
          console.warn(`Modal layout not found: ${a.resourceId}`);
          return;
        }
        Array.isArray(c.transitions) && c.transitions.forEach((m) => {
          t.push(m);
        });
        let u = (m) => {
          let I2 = { ...m };
          if (m.url && m.url.startsWith("file:")) {
            let b = m.url.replace("file:", "");
            I2.url = s(b);
          }
          return m.children && Array.isArray(m.children) && (I2.children = m.children.map(u)), I2;
        }, f = { id: `modal-${l}`, type: "container", x: 0, y: 0, children: c.elements || [] }, p2, y = false;
        if (r.variables.activeGalleryIndex !== void 0) {
          let m = r.variables.gallery.items;
          m && Array.isArray(m) && r.variables.activeGalleryIndex < m.length && (p2 = m[r.variables.activeGalleryIndex]?.fileIds[r.variables.activeGalleryFileIndex]), r.variables.activeGalleryFileIndex < m[r.variables.activeGalleryIndex]?.fileIds.length - 1 ? y = false : y = true;
        }
        let h = { variables: r.variables || {}, currentActiveGalleryFileId: p2, isLastFileIdIndex: y, saveDataArray: i3.selectSaveDataPage({ page: r?.variables.currentSavePageIndex, numberPerPage: 6 }), autoMode: i3.selectAutoMode(), skipMode: i3.selectSkipMode(), globalAudios: i3.selectGlobalAudios() || [], historyDialogue: i3.selectHistoryDialogue() || [], currentLanguagePackId: i3.selectCurrentLanguagePackId(), i18n: i3.selectCurrentLanguagePackKeys(), languagePacks: i3.selectLanguagePacks() }, g = M(f, h, { functions: Re });
        g = M(g, { i18n: i3.selectCurrentLanguagePackKeys() });
        let v = (m) => {
          let I2 = { ...m };
          if (m.url && m.url.startsWith("file:")) {
            let b = m.url.replace("file:", "");
            I2.url = s(b);
          }
          return m.children && Array.isArray(m.children) && (I2.children = m.children.map(v)), I2;
        };
        e.push(v(g));
      }
    });
  };
  var bt = ({ elements: e }, { systemState: t, resources: r, resolveFile: n }) => {
    let s = t.globalAudios;
    s && s.length > 0 && s.forEach((i3, o) => {
      e.push({ id: `global-audio-${o}-${i3.audioId}`, type: "audio", url: n(i3.fileId) });
    });
  };
  var Te = [ft, dt, pt, ht, yt, mt, _t, gt, It, vt, At, bt];
  var te = {};
  K(te, { animation: () => Lt, background: () => xt, bgm: () => Pt, character: () => Ot, choice: () => Rt, cleanAll: () => St, createInitialState: () => Dr, default: () => Ne, dialogue: () => $t, layout: () => Ct, screen: () => Et, sfx: () => wt, visual: () => kt, voice: () => Tt });
  var Et = (e, t) => {
    t.screen && (e.screen = { ...t.screen });
  };
  var xt = (e, t) => {
    t.background && (e.background = { ...t.background });
  };
  var wt = (e, t) => {
    t.sfx ? e.sfx = t.sfx : e.sfx && delete e.sfx;
  };
  var Pt = (e, t) => {
    if (t.bgm) {
      if (!t.bgm.audioId) {
        e.bgm = void 0;
        return;
      }
      e.bgm = { ...t.bgm, loop: t.bgm.loop || t.bgm.loop === void 0 };
    }
  };
  var kt = (e, t) => {
    t.visual && (e.visual = t.visual);
  };
  var $t = (e, t) => {
    if (!t.dialogue) {
      e.dialogue && e.dialogue.mode === "adv" && (e.dialogue.content = void 0, e.dialogue.characterId = void 0);
      return;
    }
    if (e.dialogue || (t.dialogue.mode === "adv" && (e.dialogue = { layoutId: t.dialogue.layoutId, content: void 0, characterId: void 0, mode: "adv" }), t.dialogue.mode === "nvl" && e.dialogue?.mode !== "nvl" && (e.dialogue = { layoutId: t.dialogue.layoutId, lines: [], mode: "nvl" })), e.dialogue.mode === "adv" && (Object.assign(e.dialogue, t.dialogue), t.dialogue.character && !t.dialogue.character.characterName && e.dialogue.character && delete e.dialogue.character.characterName), t.dialogue.mode === "nvl") {
      t.dialogue.clear && (e.dialogue.lines = []), e.dialogue.lines.push({ content: t.dialogue.content });
      return;
    }
  };
  var Ot = (e, t) => {
    t.character && (e.character = JSON.parse(JSON.stringify(t.character)));
  };
  var Lt = (e, t) => {
    t.animation ? e.animation = t.animation : e.animation && delete e.animation;
  };
  var Ct = (e, t) => {
    t.layout ? e.layout = t.layout : e.layout && delete e.layout;
  };
  var Rt = (e, t) => {
    t.choice ? e.choice = t.choice : e.choice && delete e.choice;
  };
  var Tt = (e, t) => {
    t.voice ? e.voice = t.voice : e.voice && delete e.voice;
  };
  var St = (e, t) => {
    t.cleanAll && Object.keys(e).forEach((r) => {
      delete e[r];
    });
  };
  var Dr = () => ({});
  var Ne = [St, Et, xt, wt, Pt, kt, $t, Ot, Lt, Ct, Rt, Tt];
  var ie = {};
  K(ie, { addGlobalAudio: () => _n, addModal: () => bn, clearAllGlobalAudio: () => An, clearCurrentMode: () => un, clearLastModal: () => En, clearPendingEffects: () => nn, createInitialState: () => Mr, handleCompleted: () => wn, lineCompleted: () => sn, loadVnData: () => In, nextConfig: () => hn, nextLine: () => on, prevLine: () => an, render: () => vn, saveVnData: () => gn, sectionTransition: () => cn, selectAutoMode: () => ne, selectCurrentLanguagePackId: () => Qr, selectCurrentLanguagePackKeys: () => Zr, selectCurrentPointer: () => De, selectCurrentPreset: () => Ur, selectCurrentPresetId: () => Wr, selectCurrentReplayPointer: () => Yr, selectDeviceVariables: () => en, selectDialogueUIHidden: () => Kr, selectGlobalAudios: () => Xr, selectHistory: () => Dt, selectHistoryDialogue: () => tn, selectLanguagePacks: () => qr, selectModals: () => rn, selectNextConfig: () => he, selectPendingEffects: () => Br, selectPointerMode: () => Nt, selectPointers: () => jr, selectReplayPointer: () => Jr, selectRuntimeState: () => zr, selectSaveData: () => Vt, selectSaveDataPage: () => Gr, selectSkipMode: () => re, selectSortedPendingEffects: () => Fr, selectSpecificPointer: () => Mt, selectState: () => Vr, selectVariables: () => Hr, setDeviceVariables: () => mn, setLanguagePackId: () => xn, setSaveData: () => yn, startAutoMode: () => Bt, startSkipMode: () => Wt, stopAutoMode: () => Ft, stopSkipMode: () => Ut, toggleAutoMode: () => fn, toggleDialogueUIHidden: () => pn, toggleSkipMode: () => dn, updateVariable: () => ln });
  var Mr = ({ sectionId: e, lineId: t, saveData: r, variables: n, projectDataStore: s }) => {
    let i3 = s.selectI18n(), o = { pendingEffects: [], variables: n, saveData: r || {}, lastLineAction: void 0, dialogueUIHidden: false, autoMode: false, skipMode: false, currentLanguagePackId: i3?.defaultPackId, history: { entries: [] }, globalAudios: [], historyEntryIndex: void 0, currentMode: "main", nextConfig: {}, modes: { main: { currentPointer: "read", modals: [], read: { sectionId: e, lineId: t }, history: { sectionId: void 0, lineId: void 0, historyEntryIndex: void 0 } }, replay: { currentPointer: "read", modals: [], read: { sectionId: void 0, lineId: void 0 }, history: { sectionId: void 0, lineId: void 0, historyEntryIndex: void 0 } } } };
    return o.history.entries.push({ sectionId: e }), o;
  };
  var Vr = ({ state: e }) => e;
  var Br = ({ state: e }) => e.pendingEffects;
  var Fr = ({ state: e }) => {
    let t = e.pendingEffects, r = /* @__PURE__ */ new Map();
    return t.forEach((n) => {
      r.set(n.name, n);
    }), Array.from(r.values());
  };
  var De = ({ state: e }) => {
    let t = e.modes[e.currentMode];
    return t[t.currentPointer];
  };
  var Wr = ({ state: e }) => null;
  var Ur = ({ state: e, projectDataStore: t }) => null;
  var re = ({ state: e }) => e.skipMode;
  var ne = ({ state: e }) => e.autoMode;
  var jr = ({ state: e }) => e.modes[e.currentMode];
  var he = ({ state: e }) => e.nextConfig;
  var zr = ({ state: e }) => e.runtimeState;
  var Nt = ({ state: e }) => e.modes[e.currentMode].currentPointer;
  var Kr = ({ state: e }) => e.dialogueUIHidden;
  var Dt = ({ state: e }) => e.history;
  var Mt = ({ state: e, mode: t }) => e.modes[e.currentMode][t];
  var Jr = ({ state: e, mode: t }) => e.modes.replay[t];
  var Yr = ({ state: e }) => {
    let t = e.modes.replay;
    return t[t.currentPointer];
  };
  var Vt = ({ state: e }) => e.saveData;
  var Gr = ({ state: e }, t) => {
    let { page: r, numberPerPage: n } = t, s = r * n, i3 = [];
    for (let o = s; o < s + n; o++) {
      let a = e.saveData[o] ? { id: o, label: new Date(e.saveData[o].date).toISOString().split("T")[0], hasData: true } : { id: o, label: "No Data", hasData: false };
      i3.push(a);
    }
    return i3;
  };
  var Hr = ({ state: e }) => e.variables;
  var Xr = ({ state: e }) => e.globalAudios;
  var Qr = ({ state: e }) => e.currentLanguagePackId;
  var qr = ({ state: e, projectDataStore: t }) => t.selectI18n().packs;
  var Zr = ({ state: e, projectDataStore: t }) => {
    let r = t.selectI18n(), n = e.currentLanguagePackId;
    return r.packs[n].keys;
  };
  var en = ({ state: e, projectDataStore: t }) => {
    let r = t.selectVariables(), n = e.variables, s = {};
    return Object.entries(r).forEach(([i3, o]) => {
      o.persistence === "device" && n.hasOwnProperty(i3) && (s[i3] = n[i3]);
    }), s;
  };
  var tn = ({ state: e, projectDataStore: t }) => {
    let r = De({ state: e }), { sectionId: n, lineId: s } = r;
    if (!n || !s) return [];
    let i3 = t.selectSectionLines(n), o = i3.findIndex((c) => c.id === s);
    if (o === -1) return [];
    let a = i3.slice(0, o + 1), l = [];
    return a.forEach((c, u) => {
      c.actions?.dialogue?.content && Array.isArray(c.actions.dialogue.content) && c.actions.dialogue.content.forEach((f) => {
        l.push({ content: f.text });
      });
    }), l;
  };
  var rn = ({ state: e }) => e.modes[e.currentMode].modals;
  var nn = ({ state: e }) => {
    e.pendingEffects = [];
  };
  var sn = ({ state: e, projectDataStore: t }) => {
    let r = ne(e), { pendingEffects: n } = e;
    if (r) {
      n.push({ name: "systemInstructions", options: { delay: 1e3, systemInstructions: { nextLine: { forceSkipAutonext: true } } } });
      return;
    }
    if (re(e)) {
      n.push({ name: "systemInstructions", options: { delay: 300, systemInstructions: { nextLine: { forceSkipAutonext: true } } } });
      return;
    }
    let i3 = he(e);
    if (!i3 || !i3.auto) return;
    let { trigger: o, delay: a } = i3.auto;
    switch (o) {
      case "fromComplete":
        n.push({ name: "systemInstructions", options: { delay: a, systemInstructions: { nextLine: { forceSkipAutonext: true } } } });
        break;
      case "fromStart":
        delete e.nextConfig;
        break;
      default:
        delete e.nextConfig;
        break;
    }
  };
  var on = ({ state: e, projectDataStore: t }, r = {}) => {
    let { pendingEffects: n } = e;
    if (e.dialogueUIHidden) {
      e.dialogueUIHidden = false, n.push({ name: "render" });
      return;
    }
    let { forceSkipAutonext: s = false, targetMode: i3 } = r, o = i3 || e.currentMode, a = he({ state: e });
    if (!s && a && a.manual && (!a.manual.enabled || a.manual.requireComplete && !e.lineComplete)) return;
    let l = e.modes[o], c = l[l.currentPointer], u = t.selectSectionLines(c.sectionId), f = u.findIndex((y) => y.id === c.lineId), p2 = u[f + 1];
    if (!p2) {
      e.skipMode = false, e.autoMode = false, n.push({ name: "clearAutoNextTimer" }), n.push({ name: "clearSkipNextTimer" });
      return;
    }
    l[l.currentPointer].lineId = p2.id, delete e.nextConfig, n.push({ name: "render" });
  };
  var an = ({ state: e, projectDataStore: t }) => {
    let r = Nt({ state: e }), n = De({ state: e }), s = t.selectSectionLines(n.sectionId), i3 = s.findIndex((a) => a.id === n.lineId), o = s[i3 - 1];
    if (!o) {
      if (r === "history") {
        if (e.historyEntryIndex > 0) e.historyEntryIndex--;
        else return;
        e.modes[e.currentMode].history.sectionId = e.history.entries[e.historyEntryIndex].sectionId;
        let a = t.selectSectionLines(e.modes[e.currentMode].history.sectionId);
        e.modes[e.currentMode].history.lineId = a[a.length - 1].id, e.lastLineAction = "prevLine", e.pendingEffects.push({ name: "render" });
      }
      return;
    }
    r === "read" && (e.modes[e.currentMode].currentPointer = "history", e.historyEntryIndex = e.history.entries.length - 1), e.modes[e.currentMode].history.lineId = o.id, e.modes[e.currentMode].history.sectionId = n.sectionId, e.lastLineAction = "prevLine", e.pendingEffects.push({ name: "render" });
  };
  var cn = ({ state: e, projectDataStore: t }, r) => {
    let { sectionId: n, sceneId: s, mode: i3, targetMode: o, endReplay: a } = r;
    if (e.currentMode === "replay" && a) {
      e.currentMode = "main", e.modes.replay.currentPointer = "read", e.modes.replay.modals = [], e.modes.replay.read = { sectionId: void 0, lineId: void 0 }, e.modes.replay.history = { sectionId: void 0, lineId: void 0, historyEntryIndex: void 0 }, e.pendingEffects.push({ name: "render" });
      return;
    }
    let l = t.selectSectionLines(n), c = o || (i3 && e.modes[i3] ? i3 : e.currentMode);
    i3 && e.modes[i3] && i3 !== e.currentMode && !o && (e.modes[i3].modals = []), o && o !== e.currentMode ? e.currentMode = o : i3 && e.modes[i3] && i3 !== e.currentMode && (e.currentMode = i3), i3 && !e.modes[i3] && (e.modes[c].currentPointer = i3);
    let u = e.modes[c].currentPointer;
    u === "read" && c === e.currentMode ? e.history.entries.push({ sectionId: n }) : u === "history" && n === e.history.entries[e.historyEntryIndex + 1].sectionId && e.historyEntryIndex++, e.modes[c][u].sectionId = n, e.modes[c][u].sceneId = s, e.modes[c][u].lineId = l[0].id, c === e.currentMode && (e.nextConfig = l[0].actions?.nextConfig), e.pendingEffects.push({ name: "render" });
  };
  var ln = ({ state: e, projectDataStore: t }, r) => {
    let { operations: n } = r;
    for (let s of n) {
      let { variableId: i3, op: o, value: a } = s;
      if (o === "set") e.variables[i3] = a;
      else if (o === "add") e.variables[i3] = (e.variables[i3] || 0) + a;
      else if (o === "subtract") e.variables[i3] = (e.variables[i3] || 0) - a;
      else if (o === "multiply") e.variables[i3] = (e.variables[i3] || 0) * a;
      else if (o === "divide") e.variables[i3] = (e.variables[i3] || 0) / a;
      else if (o === "increment") {
        let { max: l } = s, c = (e.variables[i3] || 0) + 1;
        (l === void 0 || c <= l) && (e.variables[i3] = (e.variables[i3] || 0) + 1);
      } else if (o === "decrement") {
        let { min: l } = s, c = (e.variables[i3] || 0) - 1;
        l !== void 0 && c >= l && (e.variables[i3] = (e.variables[i3] || 0) - 1);
      }
    }
    e.pendingEffects.push({ name: "render" }), e.pendingEffects.push({ name: "saveVariables" });
  };
  var un = ({ state: e }, t) => {
    e.modes[e.currentMode].currentPointer = t.mode, e.pendingEffects.push({ name: "render" });
  };
  var Bt = ({ state: e }) => {
    re({ state: e }) && (e.skipMode = false, e.pendingEffects.push({ name: "clearSkipNextTimer" })), e.autoMode = true, e.pendingEffects.push({ name: "clearAutoNextTimer" }), e.pendingEffects.push({ name: "startAutoNextTimer" }), e.pendingEffects.push({ name: "render" });
  };
  var Ft = ({ state: e }) => {
    e.autoMode = false, e.pendingEffects.push({ name: "render" }), e.pendingEffects.push({ name: "clearAutoNextTimer" });
  };
  var fn = ({ state: e }) => {
    ne({ state: e }) ? Ft({ state: e }) : Bt({ state: e });
  };
  var Wt = ({ state: e }) => {
    ne({ state: e }) && (e.autoMode = false, e.pendingEffects.push({ name: "clearAutoNextTimer" })), e.skipMode = true, e.pendingEffects.push({ name: "clearSkipNextTimer" }), e.pendingEffects.push({ name: "startSkipNextTimer" }), e.pendingEffects.push({ name: "render" });
  };
  var Ut = ({ state: e }) => {
    e.skipMode = false, e.pendingEffects.push({ name: "clearSkipNextTimer" }), e.pendingEffects.push({ name: "render" });
  };
  var dn = ({ state: e }) => {
    re({ state: e }) ? Ut({ state: e }) : Wt({ state: e });
  };
  var pn = ({ state: e }) => {
    e.dialogueUIHidden = !e.dialogueUIHidden, e.pendingEffects.push({ name: "render" });
  };
  var hn = ({ state: e }, t) => {
    e.nextConfig = t;
  };
  var yn = ({ state: e }, t) => {
    let { saveData: r } = t;
    e.saveData = r;
  };
  var mn = ({ state: e }, t) => {
    let { variables: r } = t;
    Object.entries(r).forEach(([n, s]) => {
      e.variables[n] = s;
    });
  };
  var gn = ({ state: e }, t) => {
    let { slotIndex: r } = t;
    e.saveData[r] = { id: String(r), pointer: Mt({ state: e, mode: "read" }), history: Dt({ state: e }), date: Date.now() }, e.pendingEffects.push({ name: "saveVnData", options: { saveData: { ...e.saveData }, slotIndex: r } });
  };
  var In = ({ state: e }, t) => {
    let { slotIndex: r } = t, s = Vt({ state: e })[r];
    if (!s) {
      console.warn(`No save data found for slot index ${r}`);
      return;
    }
    let { pointer: i3, history: o } = s;
    e.modes[e.currentMode].currentPointer = "read", e.modes[e.currentMode].read = i3, e.history = o, e.modes[e.currentMode].modals = [], e.pendingEffects.push({ name: "render" });
  };
  var vn = ({ state: e }) => {
    e.pendingEffects.push({ name: "render" });
  };
  var _n = ({ state: e }, t) => {
    let { fileId: r } = t;
    e.globalAudios.push({ fileId: r }), e.pendingEffects.push({ name: "render" });
  };
  var An = ({ state: e }) => {
    e.globalAudios = [], e.pendingEffects.push({ name: "render" });
  };
  var bn = ({ state: e }, t) => {
    let r = e.currentMode;
    e.modes[r].modals.push({ resourceId: t.resourceId, resourceType: "layout" }), e.pendingEffects.push({ name: "render" });
  };
  var En = ({ state: e }, t) => {
    let r = e.modes[e.currentMode].modals;
    r.length > 0 && (r.pop(), e.pendingEffects.push({ name: "render" }));
  };
  var xn = ({ state: e }, t) => {
    let { languagePackId: r } = t;
    e.currentLanguagePackId = r, e.pendingEffects.push({ name: "render" });
  };
  var wn = ({ state: e }) => {
    let t = he({ state: e });
    if (t) {
      t.auto && t.auto.trigger === "fromComplete" && e.pendingEffects.push({ name: "startTimer", options: { timerId: "nextConfig", payload: { nextLine: { forceSkipAutonext: true } }, delay: t.auto.delay ?? 1e3 } });
      return;
    }
    ne({ state: e }) ? e.pendingEffects.push({ name: "startTimer", options: { timerId: "autoMode", payload: { nextLine: { forceSkipAutonext: true } }, delay: 1e3 } }) : re({ state: e }) && e.pendingEffects.push({ name: "startTimer", options: { timerId: "skipMode", payload: { nextLine: { forceSkipAutonext: true } }, delay: 300 } });
  };
  var Me = {};
  K(Me, { createInitialState: () => Tn, selectI18n: () => Ln, selectInitialIds: () => jt, selectLayout: () => On, selectResources: () => kn, selectScreen: () => Pn, selectSectionLines: () => Rn, selectUi: () => $n, selectVariables: () => Cn });
  var Pn = (e) => e.screen;
  var kn = (e) => e.resources;
  var $n = (e) => e.ui;
  var On = (e) => e.layout;
  var Ln = (e) => e.i18n;
  var jt = (e) => {
    let t = e.story.scenes[e.story.initialSceneId], r = t.sections[t.initialSectionId];
    return { sceneId: e.story.initialSceneId, sectionId: t.initialSectionId, lineId: r.lines[0].id };
  };
  var Cn = (e) => e.resources.variables || {};
  var Rn = (e, t, r) => {
    let s = Object.values(e.story.scenes).flatMap((i3) => Object.entries(i3.sections).map(([o, a]) => ({ ...a, id: o }))).find((i3) => i3.id === t);
    if (r) {
      let i3 = s.lines.findIndex((o) => o.id === r);
      return s.lines.slice(0, i3 + 1);
    }
    return s.lines;
  };
  var Tn = (e) => {
    let t = jt(e), { sectionId: r, lineId: n } = t;
    if (!r || !n) throw new Error("No initial sectionId found");
    return e;
  };
  var { createInitialState: Sn } = te;
  var { createInitialState: Nn } = Se;
  var { createInitialState: Dn, ...Mn } = ie;
  var { createInitialState: Li, ...Vn } = Me;
  var zt = (e) => Pe(e, Vn);
  var Kt = (e, t) => {
    let r = t.selectVariables(), n = {};
    return Object.entries(r).forEach(([s, i3]) => {
      i3.hasOwnProperty("default") && (n[s] = i3.default);
    }), Pe(Dn({ sectionId: e.sectionId, lineId: e.lineId, saveData: {}, variables: n, projectDataStore: t }), Mn, { transformActionFirstArgument: (s) => ({ state: s, projectDataStore: t }), transformSelectorFirstArgument: (s) => ({ state: s, projectDataStore: t }) });
  };
  var Ve = ke(Sn, Ne);
  var Be = ke(Nn, Te);
  var Bn = (e) => {
    let t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = (i3, o) => {
      let a = { eventType: i3, payload: o, timestamp: performance.now() };
      r.forEach((l) => l(a));
    }, s = (i3) => {
      let o = i3.deltaMS;
      t.forEach((a, l) => {
        if (!a.paused && (a.elapsed += o, a.elapsed >= a.delay)) {
          let c = { id: l, elapsed: a.elapsed, delay: a.delay, type: a.type, triggerCount: a.triggerCount + 1, overshoot: a.elapsed - a.delay, payload: a.payload };
          n(l, c), a.triggerCount++, a.type === "timeout" ? t.delete(l) : a.type === "interval" && (a.elapsed = a.elapsed - a.delay);
        }
      });
    };
    return e.add(s), { setTimeout: (i3, o, a) => (t.has(i3) && console.warn(`Timer '${i3}' already exists, replacing it`), t.set(i3, { type: "timeout", delay: a, payload: o, elapsed: 0, triggerCount: 0, paused: false }), i3), setInterval: (i3, o, a) => (t.has(i3) && console.warn(`Timer '${i3}' already exists, replacing it`), t.set(i3, { type: "interval", delay: a, payload: o, elapsed: 0, triggerCount: 0, paused: false }), i3), clear: (i3) => {
      t.delete(i3);
    }, pause: (i3) => {
      let o = t.get(i3);
      o && (o.paused = true);
    }, resume: (i3) => {
      let o = t.get(i3);
      o && o.paused && (o.paused = false);
    }, pauseAll: () => {
      t.forEach((i3, o) => {
        i3.paused = true;
      });
    }, resumeAll: () => {
      t.forEach((i3, o) => {
        i3.paused = false;
      });
    }, clearAll: () => {
      t.clear();
    }, onEvent: (i3) => (r.add(i3), () => r.delete(i3)), getTimer: (i3) => {
      let o = t.get(i3);
      return o ? { id: i3, ...o } : null;
    }, getActiveTimers: () => Array.from(t.keys()), destroy: () => {
      t.clear(), r.clear(), e.remove(s);
    } };
  };
  var Jt = Bn;
  var Fe = {};
  K(Fe, { clearAutoNextTimer: () => zn, clearSkipNextTimer: () => Jn, render: () => Fn, saveVariables: () => Un, saveVnData: () => Wn, startAutoNextTimer: () => jn, startSkipNextTimer: () => Kn, startTimer: () => Yn });
  var Fn = ({ processAndRender: e }) => {
    e();
  };
  var Wn = async ({ timer: e, localStorage: t, captureElement: r, loadAssets: n }, s) => {
    let { saveData: i3, slotIndex: o } = s.options, a = structuredClone(i3), l = await r("story");
    console.log("saveData", a), console.log("slotindex", o), a[o].image = l;
    let c = { [`saveImage:${o}`]: { buffer: de(l), type: "image/png" } };
    await n(c), t.setItem("saveData", JSON.stringify(a)), e.setTimeout("saveData", { render: {} }, 100);
  };
  var Un = ({ localStorage: e, systemStore: t }) => {
    let r = t.selectDeviceVariables();
    e.setItem("deviceVariables", JSON.stringify(r));
  };
  var jn = ({ timer: e }) => {
    e.setTimeout("autoMode", { nextLine: { forceSkipAutonext: true } }, 1e3);
  };
  var zn = ({ timer: e }) => {
    e.clear("autoMode");
  };
  var Kn = ({ timer: e }) => {
    e.setTimeout("skipMode", { nextLine: { forceSkipAutonext: true } }, 300);
  };
  var Jn = ({ timer: e }) => {
    e.clear("skipMode");
  };
  var Yn = ({ timer: e }, t) => {
    let { timerId: r, payload: n, delay: s } = t.options;
    e.setTimeout(r, n, s);
  };
  var Yt = Object.keys(te).filter((e) => e !== "default" && e !== "createInitialState");
  var Gn = Object.keys(ie).filter((e) => !e.startsWith("select") && e !== "createInitialState");
  function We() {
    let e, t, r, n, s, i3 = () => {
    }, o, a, l = ({ projectData: v, ticker: m, captureElement: I2, loadAssets: b }) => {
      e = zt(v);
      let E2 = e.selectInitialIds();
      t = Kt(E2, e), n = Ve, r = Be, o = I2, a = b, s = Jt(m), s.onEvent(c);
      let w = localStorage.getItem("saveData") || "{}", N2 = JSON.parse(w), H = Object.entries(N2).filter(([$2, P]) => !!P.image).map(([$2, P]) => {
        let z2 = `saveImage:${$2}`, X = de(P.image);
        return { [z2]: { buffer: X, type: "image/png" } };
      }).reduce(($2, P) => ({ ...$2, ...P }), {});
      b(H).then(() => {
        console.log("All save images loaded");
      }).catch(($2) => {
        console.log("Error loading save images", $2);
      }), t.setSaveData({ saveData: N2 });
      let B2 = e.selectVariables(), C = {};
      Object.entries(B2).forEach(([$2, P]) => {
        P.persistence === "device" && P.hasOwnProperty("default") && (C[$2] = P.default);
      });
      let D = localStorage.getItem("deviceVariables");
      if (D) try {
        let $2 = JSON.parse(D);
        Object.entries($2).forEach(([P, z2]) => {
          B2[P] && B2[P].persistence === "device" && (C[P] = z2);
        });
      } catch ($2) {
        console.error("Failed to load device variables:", $2);
      }
      Object.keys(C).length > 0 && (t.setDeviceVariables({ variables: C }), localStorage.setItem("deviceVariables", JSON.stringify(C))), y();
    }, c = ({ eventType: v, payload: m }) => {
      Object.keys(m.payload).forEach((I2) => {
        if (typeof t[I2] == "function") t[I2](m.payload[I2]);
        else throw new Error(`System action ${I2} not found on system store`);
      }), y();
    }, u = (v) => {
      i3 = v;
    }, f = () => {
      i3 = () => {
      };
    }, p2 = (v) => {
      let { payload: m } = v, I2 = m.actions;
      Object.keys(I2).forEach((E2) => {
        if (typeof t[E2] == "function") {
          let w = I2[E2];
          E2 === "nextLine" && !w.targetMode && t.selectState().modes.replay.read.sectionId && (w = { ...w, targetMode: "replay" }), t[E2](w);
        } else throw new Error(`System action ${E2} not found on system store`);
      });
      let b = t.selectSortedPendingEffects();
      if (b.length > 0) {
        let E2 = { processAndRender: y, timer: s, localStorage, systemStore: t, captureElement: o, loadAssets: a };
        b.forEach((w) => {
          let N2 = Fe[w.name];
          if (!N2) throw new Error(`No handler found for effect: ${w.name}`);
          N2(E2, w);
        }), t.clearPendingEffects();
      }
    }, y = () => {
      h(), g();
    }, h = () => {
      let v = t.selectCurrentPointer(), m = e.selectSectionLines(v.sectionId, v.lineId);
      m.length && m.forEach((I2) => {
        let b = I2.actions || {};
        Gn.filter((w) => w in b).forEach((w) => {
          t[w](b[w]);
        });
      });
    }, g = () => {
      let v = t.selectCurrentPointer(), m = e.selectSectionLines(v.sectionId, v.lineId);
      if (!m.length) throw new Error(`No lines found for section: ${v.sectionId}, line: ${v.lineId}`);
      let I2 = m.map((C) => {
        let D = C.actions || {}, $2 = {};
        return Object.keys(D).forEach((P) => {
          Yt.includes(P) && ($2[P] = D[P]);
        }), $2;
      }), b = n(I2), E2 = null, w = t.selectCurrentReplayPointer();
      if (w && w.sectionId && w.lineId) {
        let C = e.selectSectionLines(w.sectionId, w.lineId);
        if (C.length) {
          let D = C.map(($2) => {
            let P = $2.actions || {}, z2 = {};
            return Object.keys(P).forEach((X) => {
              Yt.includes(X) && (z2[X] = P[X]);
            }), z2;
          });
          E2 = n(D);
        }
      }
      let N2 = t.selectState(), H = r({ presentationState: b, systemState: N2, systemStore: t, screen: e.selectScreen(), resolveFile: (C) => `file:${C}`, resources: e.selectResources(), ui: e.selectUi(), i18n: e.selectI18n() }), B2 = null;
      if (E2) {
        let C = structuredClone(N2);
        B2 = r({ presentationState: E2, systemState: C, systemStore: t, screen: e.selectScreen(), resolveFile: (D) => `file:${D}`, resources: e.selectResources(), ui: e.selectUi(), i18n: e.selectI18n() });
      }
      console.log({ systemState: N2, mainPresentationState: b, mainRenderState: H, replayPresentationState: E2, replayRenderState: B2 }), i3({ eventType: "render", payload: B2 || H });
    };
    return { init: l, onEvent: u, offEvent: f, handleEvent: p2 };
  }
  var Fi = We;

  // node_modules/route-graphics/dist/RouteGraphics.js
  var w0 = Object.create;
  var Ya = Object.defineProperty;
  var P0 = Object.getOwnPropertyDescriptor;
  var A0 = Object.getOwnPropertyNames;
  var C0 = Object.getPrototypeOf;
  var E0 = Object.prototype.hasOwnProperty;
  var p = (i3, t) => () => (i3 && (t = i3(i3 = 0)), t);
  var $a = (i3, t) => () => (t || i3((t = { exports: {} }).exports, t), t.exports);
  var Yu = (i3, t) => {
    for (var e in t) Ya(i3, e, { get: t[e], enumerable: true });
  };
  var M0 = (i3, t, e, r) => {
    if (t && typeof t == "object" || typeof t == "function") for (let s of A0(t)) !E0.call(i3, s) && s !== e && Ya(i3, s, { get: () => t[s], enumerable: !(r = P0(t, s)) || r.enumerable });
    return i3;
  };
  var Io = (i3, t, e) => (e = i3 != null ? w0(C0(i3)) : {}, M0(t || !i3 || !i3.__esModule ? Ya(e, "default", { value: i3, enumerable: true }) : e, i3));
  var _2;
  var ja;
  var Di;
  var U2;
  var E = p(() => {
    "use strict";
    _2 = ((i3) => (i3.Application = "application", i3.WebGLPipes = "webgl-pipes", i3.WebGLPipesAdaptor = "webgl-pipes-adaptor", i3.WebGLSystem = "webgl-system", i3.WebGPUPipes = "webgpu-pipes", i3.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i3.WebGPUSystem = "webgpu-system", i3.CanvasSystem = "canvas-system", i3.CanvasPipesAdaptor = "canvas-pipes-adaptor", i3.CanvasPipes = "canvas-pipes", i3.Asset = "asset", i3.LoadParser = "load-parser", i3.ResolveParser = "resolve-parser", i3.CacheParser = "cache-parser", i3.DetectionParser = "detection-parser", i3.MaskEffect = "mask-effect", i3.BlendMode = "blend-mode", i3.TextureSource = "texture-source", i3.Environment = "environment", i3.ShapeBuilder = "shape-builder", i3.Batcher = "batcher", i3))(_2 || {}), ja = (i3) => {
      if (typeof i3 == "function" || typeof i3 == "object" && i3.extension) {
        if (!i3.extension) throw new Error("Extension class must have an extension object");
        i3 = { ...typeof i3.extension != "object" ? { type: i3.extension } : i3.extension, ref: i3 };
      }
      if (typeof i3 == "object") i3 = { ...i3 };
      else throw new Error("Invalid extension type");
      return typeof i3.type == "string" && (i3.type = [i3.type]), i3;
    }, Di = (i3, t) => ja(i3).priority ?? t, U2 = { _addHandlers: {}, _removeHandlers: {}, _queue: {}, remove(...i3) {
      return i3.map(ja).forEach((t) => {
        t.type.forEach((e) => this._removeHandlers[e]?.(t));
      }), this;
    }, add(...i3) {
      return i3.map(ja).forEach((t) => {
        t.type.forEach((e) => {
          let r = this._addHandlers, s = this._queue;
          r[e] ? r[e]?.(t) : (s[e] = s[e] || [], s[e]?.push(t));
        });
      }), this;
    }, handle(i3, t, e) {
      let r = this._addHandlers, s = this._removeHandlers;
      if (r[i3] || s[i3]) throw new Error(`Extension type ${i3} already has a handler`);
      r[i3] = t, s[i3] = e;
      let o = this._queue;
      return o[i3] && (o[i3]?.forEach((n) => t(n)), delete o[i3]), this;
    }, handleByMap(i3, t) {
      return this.handle(i3, (e) => {
        e.name && (t[e.name] = e.ref);
      }, (e) => {
        e.name && delete t[e.name];
      });
    }, handleByNamedList(i3, t, e = -1) {
      return this.handle(i3, (r) => {
        t.findIndex((o) => o.name === r.name) >= 0 || (t.push({ name: r.name, value: r.ref }), t.sort((o, n) => Di(n.value, e) - Di(o.value, e)));
      }, (r) => {
        let s = t.findIndex((o) => o.name === r.name);
        s !== -1 && t.splice(s, 1);
      });
    }, handleByList(i3, t, e = -1) {
      return this.handle(i3, (r) => {
        t.includes(r.ref) || (t.push(r.ref), t.sort((s, o) => Di(o, e) - Di(s, e)));
      }, (r) => {
        let s = t.indexOf(r.ref);
        s !== -1 && t.splice(s, 1);
      });
    }, mixin(i3, ...t) {
      for (let e of t) Object.defineProperties(i3.prototype, Object.getOwnPropertyDescriptors(e));
    } };
  });
  var ju = $a((tP, Ka) => {
    "use strict";
    var B0 = Object.prototype.hasOwnProperty, Lt2 = "~";
    function Oi() {
    }
    Object.create && (Oi.prototype = /* @__PURE__ */ Object.create(null), new Oi().__proto__ || (Lt2 = false));
    function R0(i3, t, e) {
      this.fn = i3, this.context = t, this.once = e || false;
    }
    function $u(i3, t, e, r, s) {
      if (typeof e != "function") throw new TypeError("The listener must be a function");
      var o = new R0(e, r || i3, s), n = Lt2 ? Lt2 + t : t;
      return i3._events[n] ? i3._events[n].fn ? i3._events[n] = [i3._events[n], o] : i3._events[n].push(o) : (i3._events[n] = o, i3._eventsCount++), i3;
    }
    function Fo(i3, t) {
      --i3._eventsCount === 0 ? i3._events = new Oi() : delete i3._events[t];
    }
    function Ut2() {
      this._events = new Oi(), this._eventsCount = 0;
    }
    Ut2.prototype.eventNames = function() {
      var t = [], e, r;
      if (this._eventsCount === 0) return t;
      for (r in e = this._events) B0.call(e, r) && t.push(Lt2 ? r.slice(1) : r);
      return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(e)) : t;
    };
    Ut2.prototype.listeners = function(t) {
      var e = Lt2 ? Lt2 + t : t, r = this._events[e];
      if (!r) return [];
      if (r.fn) return [r.fn];
      for (var s = 0, o = r.length, n = new Array(o); s < o; s++) n[s] = r[s].fn;
      return n;
    };
    Ut2.prototype.listenerCount = function(t) {
      var e = Lt2 ? Lt2 + t : t, r = this._events[e];
      return r ? r.fn ? 1 : r.length : 0;
    };
    Ut2.prototype.emit = function(t, e, r, s, o, n) {
      var a = Lt2 ? Lt2 + t : t;
      if (!this._events[a]) return false;
      var c = this._events[a], l = arguments.length, h, u;
      if (c.fn) {
        switch (c.once && this.removeListener(t, c.fn, void 0, true), l) {
          case 1:
            return c.fn.call(c.context), true;
          case 2:
            return c.fn.call(c.context, e), true;
          case 3:
            return c.fn.call(c.context, e, r), true;
          case 4:
            return c.fn.call(c.context, e, r, s), true;
          case 5:
            return c.fn.call(c.context, e, r, s, o), true;
          case 6:
            return c.fn.call(c.context, e, r, s, o, n), true;
        }
        for (u = 1, h = new Array(l - 1); u < l; u++) h[u - 1] = arguments[u];
        c.fn.apply(c.context, h);
      } else {
        var f = c.length, d2;
        for (u = 0; u < f; u++) switch (c[u].once && this.removeListener(t, c[u].fn, void 0, true), l) {
          case 1:
            c[u].fn.call(c[u].context);
            break;
          case 2:
            c[u].fn.call(c[u].context, e);
            break;
          case 3:
            c[u].fn.call(c[u].context, e, r);
            break;
          case 4:
            c[u].fn.call(c[u].context, e, r, s);
            break;
          default:
            if (!h) for (d2 = 1, h = new Array(l - 1); d2 < l; d2++) h[d2 - 1] = arguments[d2];
            c[u].fn.apply(c[u].context, h);
        }
      }
      return true;
    };
    Ut2.prototype.on = function(t, e, r) {
      return $u(this, t, e, r, false);
    };
    Ut2.prototype.once = function(t, e, r) {
      return $u(this, t, e, r, true);
    };
    Ut2.prototype.removeListener = function(t, e, r, s) {
      var o = Lt2 ? Lt2 + t : t;
      if (!this._events[o]) return this;
      if (!e) return Fo(this, o), this;
      var n = this._events[o];
      if (n.fn) n.fn === e && (!s || n.once) && (!r || n.context === r) && Fo(this, o);
      else {
        for (var a = 0, c = [], l = n.length; a < l; a++) (n[a].fn !== e || s && !n[a].once || r && n[a].context !== r) && c.push(n[a]);
        c.length ? this._events[o] = c.length === 1 ? c[0] : c : Fo(this, o);
      }
      return this;
    };
    Ut2.prototype.removeAllListeners = function(t) {
      var e;
      return t ? (e = Lt2 ? Lt2 + t : t, this._events[e] && Fo(this, e)) : (this._events = new Oi(), this._eventsCount = 0), this;
    };
    Ut2.prototype.off = Ut2.prototype.removeListener;
    Ut2.prototype.addListener = Ut2.prototype.on;
    Ut2.prefixed = Lt2;
    Ut2.EventEmitter = Ut2;
    typeof Ka < "u" && (Ka.exports = Ut2);
  });
  var Ku;
  var at2;
  var Dt2 = p(() => {
    Ku = Io(ju(), 1), at2 = Ku.default;
  });
  var G0;
  var Re2;
  var Ct2;
  var se2;
  var id;
  var qu;
  var qa;
  var k0;
  var Uo;
  var sd;
  var od;
  var Zu;
  var Qu;
  var Ju;
  var Li2;
  var I0;
  var F0;
  var U0;
  var D0;
  var Ja;
  var td2;
  var O0;
  var Za;
  var Qa;
  var ed;
  var tc;
  var de2;
  var rd;
  var nd;
  var ad = p(() => {
    G0 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, Re2 = function(i3) {
      return typeof i3 == "string" ? i3.length > 0 : typeof i3 == "number";
    }, Ct2 = function(i3, t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * i3) / e + 0;
    }, se2 = function(i3, t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = 1), i3 > e ? e : i3 > t ? i3 : t;
    }, id = function(i3) {
      return (i3 = isFinite(i3) ? i3 % 360 : 0) > 0 ? i3 : i3 + 360;
    }, qu = function(i3) {
      return { r: se2(i3.r, 0, 255), g: se2(i3.g, 0, 255), b: se2(i3.b, 0, 255), a: se2(i3.a) };
    }, qa = function(i3) {
      return { r: Ct2(i3.r), g: Ct2(i3.g), b: Ct2(i3.b), a: Ct2(i3.a, 3) };
    }, k0 = /^#([0-9a-f]{3,8})$/i, Uo = function(i3) {
      var t = i3.toString(16);
      return t.length < 2 ? "0" + t : t;
    }, sd = function(i3) {
      var t = i3.r, e = i3.g, r = i3.b, s = i3.a, o = Math.max(t, e, r), n = o - Math.min(t, e, r), a = n ? o === t ? (e - r) / n : o === e ? 2 + (r - t) / n : 4 + (t - e) / n : 0;
      return { h: 60 * (a < 0 ? a + 6 : a), s: o ? n / o * 100 : 0, v: o / 255 * 100, a: s };
    }, od = function(i3) {
      var t = i3.h, e = i3.s, r = i3.v, s = i3.a;
      t = t / 360 * 6, e /= 100, r /= 100;
      var o = Math.floor(t), n = r * (1 - e), a = r * (1 - (t - o) * e), c = r * (1 - (1 - t + o) * e), l = o % 6;
      return { r: 255 * [r, a, n, n, c, r][l], g: 255 * [c, r, r, a, n, n][l], b: 255 * [n, n, c, r, r, a][l], a: s };
    }, Zu = function(i3) {
      return { h: id(i3.h), s: se2(i3.s, 0, 100), l: se2(i3.l, 0, 100), a: se2(i3.a) };
    }, Qu = function(i3) {
      return { h: Ct2(i3.h), s: Ct2(i3.s), l: Ct2(i3.l), a: Ct2(i3.a, 3) };
    }, Ju = function(i3) {
      return od((e = (t = i3).s, { h: t.h, s: (e *= ((r = t.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * e / (r + e) * 100 : 0, v: r + e, a: t.a }));
      var t, e, r;
    }, Li2 = function(i3) {
      return { h: (t = sd(i3)).h, s: (s = (200 - (e = t.s)) * (r = t.v) / 100) > 0 && s < 200 ? e * r / 100 / (s <= 100 ? s : 200 - s) * 100 : 0, l: s / 2, a: t.a };
      var t, e, r, s;
    }, I0 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, F0 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, U0 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, D0 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Ja = { string: [[function(i3) {
      var t = k0.exec(i3);
      return t ? (i3 = t[1]).length <= 4 ? { r: parseInt(i3[0] + i3[0], 16), g: parseInt(i3[1] + i3[1], 16), b: parseInt(i3[2] + i3[2], 16), a: i3.length === 4 ? Ct2(parseInt(i3[3] + i3[3], 16) / 255, 2) : 1 } : i3.length === 6 || i3.length === 8 ? { r: parseInt(i3.substr(0, 2), 16), g: parseInt(i3.substr(2, 2), 16), b: parseInt(i3.substr(4, 2), 16), a: i3.length === 8 ? Ct2(parseInt(i3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
    }, "hex"], [function(i3) {
      var t = U0.exec(i3) || D0.exec(i3);
      return t ? t[2] !== t[4] || t[4] !== t[6] ? null : qu({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;
    }, "rgb"], [function(i3) {
      var t = I0.exec(i3) || F0.exec(i3);
      if (!t) return null;
      var e, r, s = Zu({ h: (e = t[1], r = t[2], r === void 0 && (r = "deg"), Number(e) * (G0[r] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
      return Ju(s);
    }, "hsl"]], object: [[function(i3) {
      var t = i3.r, e = i3.g, r = i3.b, s = i3.a, o = s === void 0 ? 1 : s;
      return Re2(t) && Re2(e) && Re2(r) ? qu({ r: Number(t), g: Number(e), b: Number(r), a: Number(o) }) : null;
    }, "rgb"], [function(i3) {
      var t = i3.h, e = i3.s, r = i3.l, s = i3.a, o = s === void 0 ? 1 : s;
      if (!Re2(t) || !Re2(e) || !Re2(r)) return null;
      var n = Zu({ h: Number(t), s: Number(e), l: Number(r), a: Number(o) });
      return Ju(n);
    }, "hsl"], [function(i3) {
      var t = i3.h, e = i3.s, r = i3.v, s = i3.a, o = s === void 0 ? 1 : s;
      if (!Re2(t) || !Re2(e) || !Re2(r)) return null;
      var n = (function(a) {
        return { h: id(a.h), s: se2(a.s, 0, 100), v: se2(a.v, 0, 100), a: se2(a.a) };
      })({ h: Number(t), s: Number(e), v: Number(r), a: Number(o) });
      return od(n);
    }, "hsv"]] }, td2 = function(i3, t) {
      for (var e = 0; e < t.length; e++) {
        var r = t[e][0](i3);
        if (r) return [r, t[e][1]];
      }
      return [null, void 0];
    }, O0 = function(i3) {
      return typeof i3 == "string" ? td2(i3.trim(), Ja.string) : typeof i3 == "object" && i3 !== null ? td2(i3, Ja.object) : [null, void 0];
    }, Za = function(i3, t) {
      var e = Li2(i3);
      return { h: e.h, s: se2(e.s + 100 * t, 0, 100), l: e.l, a: e.a };
    }, Qa = function(i3) {
      return (299 * i3.r + 587 * i3.g + 114 * i3.b) / 1e3 / 255;
    }, ed = function(i3, t) {
      var e = Li2(i3);
      return { h: e.h, s: e.s, l: se2(e.l + 100 * t, 0, 100), a: e.a };
    }, tc = (function() {
      function i3(t) {
        this.parsed = O0(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
      }
      return i3.prototype.isValid = function() {
        return this.parsed !== null;
      }, i3.prototype.brightness = function() {
        return Ct2(Qa(this.rgba), 2);
      }, i3.prototype.isDark = function() {
        return Qa(this.rgba) < 0.5;
      }, i3.prototype.isLight = function() {
        return Qa(this.rgba) >= 0.5;
      }, i3.prototype.toHex = function() {
        return t = qa(this.rgba), e = t.r, r = t.g, s = t.b, n = (o = t.a) < 1 ? Uo(Ct2(255 * o)) : "", "#" + Uo(e) + Uo(r) + Uo(s) + n;
        var t, e, r, s, o, n;
      }, i3.prototype.toRgb = function() {
        return qa(this.rgba);
      }, i3.prototype.toRgbString = function() {
        return t = qa(this.rgba), e = t.r, r = t.g, s = t.b, (o = t.a) < 1 ? "rgba(" + e + ", " + r + ", " + s + ", " + o + ")" : "rgb(" + e + ", " + r + ", " + s + ")";
        var t, e, r, s, o;
      }, i3.prototype.toHsl = function() {
        return Qu(Li2(this.rgba));
      }, i3.prototype.toHslString = function() {
        return t = Qu(Li2(this.rgba)), e = t.h, r = t.s, s = t.l, (o = t.a) < 1 ? "hsla(" + e + ", " + r + "%, " + s + "%, " + o + ")" : "hsl(" + e + ", " + r + "%, " + s + "%)";
        var t, e, r, s, o;
      }, i3.prototype.toHsv = function() {
        return t = sd(this.rgba), { h: Ct2(t.h), s: Ct2(t.s), v: Ct2(t.v), a: Ct2(t.a, 3) };
        var t;
      }, i3.prototype.invert = function() {
        return de2({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a });
        var t;
      }, i3.prototype.saturate = function(t) {
        return t === void 0 && (t = 0.1), de2(Za(this.rgba, t));
      }, i3.prototype.desaturate = function(t) {
        return t === void 0 && (t = 0.1), de2(Za(this.rgba, -t));
      }, i3.prototype.grayscale = function() {
        return de2(Za(this.rgba, -1));
      }, i3.prototype.lighten = function(t) {
        return t === void 0 && (t = 0.1), de2(ed(this.rgba, t));
      }, i3.prototype.darken = function(t) {
        return t === void 0 && (t = 0.1), de2(ed(this.rgba, -t));
      }, i3.prototype.rotate = function(t) {
        return t === void 0 && (t = 15), this.hue(this.hue() + t);
      }, i3.prototype.alpha = function(t) {
        return typeof t == "number" ? de2({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t }) : Ct2(this.rgba.a, 3);
        var e;
      }, i3.prototype.hue = function(t) {
        var e = Li2(this.rgba);
        return typeof t == "number" ? de2({ h: t, s: e.s, l: e.l, a: e.a }) : Ct2(e.h);
      }, i3.prototype.isEqual = function(t) {
        return this.toHex() === de2(t).toHex();
      }, i3;
    })(), de2 = function(i3) {
      return i3 instanceof tc ? i3 : new tc(i3);
    }, rd = [], nd = function(i3) {
      i3.forEach(function(t) {
        rd.indexOf(t) < 0 && (t(tc, Ja), rd.push(t));
      });
    };
  });
  function cd(i3, t) {
    var e = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r = {};
    for (var s in e) r[e[s]] = s;
    var o = {};
    i3.prototype.toName = function(n) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var a, c, l = r[this.toHex()];
      if (l) return l;
      if (n?.closest) {
        var h = this.toRgb(), u = 1 / 0, f = "black";
        if (!o.length) for (var d2 in e) o[d2] = new i3(e[d2]).toRgb();
        for (var m in e) {
          var g = (a = h, c = o[m], Math.pow(a.r - c.r, 2) + Math.pow(a.g - c.g, 2) + Math.pow(a.b - c.b, 2));
          g < u && (u = g, f = m);
        }
        return f;
      }
    }, t.string.push([function(n) {
      var a = n.toLowerCase(), c = a === "transparent" ? "#0000" : e[a];
      return c ? new i3(c).toRgb() : null;
    }, "name"]);
  }
  var ld = p(() => {
  });
  var Ir2;
  var $;
  var Gt2 = p(() => {
    ad();
    ld();
    nd([cd]);
    Ir2 = class Ni {
      constructor(t = 16777215) {
        this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
      }
      get red() {
        return this._components[0];
      }
      get green() {
        return this._components[1];
      }
      get blue() {
        return this._components[2];
      }
      get alpha() {
        return this._components[3];
      }
      setValue(t) {
        return this.value = t, this;
      }
      set value(t) {
        if (t instanceof Ni) this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
        else {
          if (t === null) throw new Error("Cannot set Color#value to null");
          (this._value === null || !this._isSourceEqual(this._value, t)) && (this._value = this._cloneSource(t), this._normalize(this._value));
        }
      }
      get value() {
        return this._value;
      }
      _cloneSource(t) {
        return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? { ...t } : t;
      }
      _isSourceEqual(t, e) {
        let r = typeof t;
        if (r !== typeof e) return false;
        if (r === "number" || r === "string" || t instanceof Number) return t === e;
        if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) return t.length !== e.length ? false : t.every((o, n) => o === e[n]);
        if (t !== null && e !== null) {
          let o = Object.keys(t), n = Object.keys(e);
          return o.length !== n.length ? false : o.every((a) => t[a] === e[a]);
        }
        return t === e;
      }
      toRgba() {
        let [t, e, r, s] = this._components;
        return { r: t, g: e, b: r, a: s };
      }
      toRgb() {
        let [t, e, r] = this._components;
        return { r: t, g: e, b: r };
      }
      toRgbaString() {
        let [t, e, r] = this.toUint8RgbArray();
        return `rgba(${t},${e},${r},${this.alpha})`;
      }
      toUint8RgbArray(t) {
        let [e, r, s] = this._components;
        return this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb), t[0] = Math.round(e * 255), t[1] = Math.round(r * 255), t[2] = Math.round(s * 255), t;
      }
      toArray(t) {
        this._arrayRgba || (this._arrayRgba = []), t || (t = this._arrayRgba);
        let [e, r, s, o] = this._components;
        return t[0] = e, t[1] = r, t[2] = s, t[3] = o, t;
      }
      toRgbArray(t) {
        this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb);
        let [e, r, s] = this._components;
        return t[0] = e, t[1] = r, t[2] = s, t;
      }
      toNumber() {
        return this._int;
      }
      toBgrNumber() {
        let [t, e, r] = this.toUint8RgbArray();
        return (r << 16) + (e << 8) + t;
      }
      toLittleEndianNumber() {
        let t = this._int;
        return (t >> 16) + (t & 65280) + ((t & 255) << 16);
      }
      multiply(t) {
        let [e, r, s, o] = Ni._temp.setValue(t)._components;
        return this._components[0] *= e, this._components[1] *= r, this._components[2] *= s, this._components[3] *= o, this._refreshInt(), this._value = null, this;
      }
      premultiply(t, e = true) {
        return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
      }
      toPremultiplied(t, e = true) {
        if (t === 1) return (255 << 24) + this._int;
        if (t === 0) return e ? 0 : this._int;
        let r = this._int >> 16 & 255, s = this._int >> 8 & 255, o = this._int & 255;
        return e && (r = r * t + 0.5 | 0, s = s * t + 0.5 | 0, o = o * t + 0.5 | 0), (t * 255 << 24) + (r << 16) + (s << 8) + o;
      }
      toHex() {
        let t = this._int.toString(16);
        return `#${"000000".substring(0, 6 - t.length) + t}`;
      }
      toHexa() {
        let e = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - e.length) + e;
      }
      setAlpha(t) {
        return this._components[3] = this._clamp(t), this;
      }
      _normalize(t) {
        let e, r, s, o;
        if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
          let n = t;
          e = (n >> 16 & 255) / 255, r = (n >> 8 & 255) / 255, s = (n & 255) / 255, o = 1;
        } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4) t = this._clamp(t), [e, r, s, o = 1] = t;
        else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4) t = this._clamp(t, 0, 255), [e, r, s, o = 255] = t, e /= 255, r /= 255, s /= 255, o /= 255;
        else if (typeof t == "string" || typeof t == "object") {
          if (typeof t == "string") {
            let a = Ni.HEX_PATTERN.exec(t);
            a && (t = `#${a[2]}`);
          }
          let n = de2(t);
          n.isValid() && ({ r: e, g: r, b: s, a: o } = n.rgba, e /= 255, r /= 255, s /= 255);
        }
        if (e !== void 0) this._components[0] = e, this._components[1] = r, this._components[2] = s, this._components[3] = o, this._refreshInt();
        else throw new Error(`Unable to convert color ${t}`);
      }
      _refreshInt() {
        this._clamp(this._components);
        let [t, e, r] = this._components;
        this._int = (t * 255 << 16) + (e * 255 << 8) + (r * 255 | 0);
      }
      _clamp(t, e = 0, r = 1) {
        return typeof t == "number" ? Math.min(Math.max(t, e), r) : (t.forEach((s, o) => {
          t[o] = Math.min(Math.max(s, e), r);
        }), t);
      }
      static isColorLike(t) {
        return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof Ni || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
      }
    };
    Ir2.shared = new Ir2();
    Ir2._temp = new Ir2();
    Ir2.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    $ = Ir2;
  });
  var hd;
  var ud = p(() => {
    "use strict";
    hd = { cullArea: null, cullable: false, cullableChildren: true };
  });
  var dd;
  var fd2;
  var pd;
  var ec2 = p(() => {
    "use strict";
    dd = Math.PI * 2, fd2 = 180 / Math.PI, pd = Math.PI / 180;
  });
  var Z2;
  var rc;
  var oe2 = p(() => {
    "use strict";
    Z2 = class i3 {
      constructor(t = 0, e = 0) {
        this.x = 0, this.y = 0, this.x = t, this.y = e;
      }
      clone() {
        return new i3(this.x, this.y);
      }
      copyFrom(t) {
        return this.set(t.x, t.y), this;
      }
      copyTo(t) {
        return t.set(this.x, this.y), t;
      }
      equals(t) {
        return t.x === this.x && t.y === this.y;
      }
      set(t = 0, e = t) {
        return this.x = t, this.y = e, this;
      }
      toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
      }
      static get shared() {
        return rc.x = 0, rc.y = 0, rc;
      }
    }, rc = new Z2();
  });
  var I;
  var L0;
  var N0;
  var Q2 = p(() => {
    ec2();
    oe2();
    I = class i3 {
      constructor(t = 1, e = 0, r = 0, s = 1, o = 0, n = 0) {
        this.array = null, this.a = t, this.b = e, this.c = r, this.d = s, this.tx = o, this.ty = n;
      }
      fromArray(t) {
        this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
      }
      set(t, e, r, s, o, n) {
        return this.a = t, this.b = e, this.c = r, this.d = s, this.tx = o, this.ty = n, this;
      }
      toArray(t, e) {
        this.array || (this.array = new Float32Array(9));
        let r = e || this.array;
        return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
      }
      apply(t, e) {
        e = e || new Z2();
        let r = t.x, s = t.y;
        return e.x = this.a * r + this.c * s + this.tx, e.y = this.b * r + this.d * s + this.ty, e;
      }
      applyInverse(t, e) {
        e = e || new Z2();
        let r = this.a, s = this.b, o = this.c, n = this.d, a = this.tx, c = this.ty, l = 1 / (r * n + o * -s), h = t.x, u = t.y;
        return e.x = n * l * h + -o * l * u + (c * o - a * n) * l, e.y = r * l * u + -s * l * h + (-c * r + a * s) * l, e;
      }
      translate(t, e) {
        return this.tx += t, this.ty += e, this;
      }
      scale(t, e) {
        return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
      }
      rotate(t) {
        let e = Math.cos(t), r = Math.sin(t), s = this.a, o = this.c, n = this.tx;
        return this.a = s * e - this.b * r, this.b = s * r + this.b * e, this.c = o * e - this.d * r, this.d = o * r + this.d * e, this.tx = n * e - this.ty * r, this.ty = n * r + this.ty * e, this;
      }
      append(t) {
        let e = this.a, r = this.b, s = this.c, o = this.d;
        return this.a = t.a * e + t.b * s, this.b = t.a * r + t.b * o, this.c = t.c * e + t.d * s, this.d = t.c * r + t.d * o, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * r + t.ty * o + this.ty, this;
      }
      appendFrom(t, e) {
        let r = t.a, s = t.b, o = t.c, n = t.d, a = t.tx, c = t.ty, l = e.a, h = e.b, u = e.c, f = e.d;
        return this.a = r * l + s * u, this.b = r * h + s * f, this.c = o * l + n * u, this.d = o * h + n * f, this.tx = a * l + c * u + e.tx, this.ty = a * h + c * f + e.ty, this;
      }
      setTransform(t, e, r, s, o, n, a, c, l) {
        return this.a = Math.cos(a + l) * o, this.b = Math.sin(a + l) * o, this.c = -Math.sin(a - c) * n, this.d = Math.cos(a - c) * n, this.tx = t - (r * this.a + s * this.c), this.ty = e - (r * this.b + s * this.d), this;
      }
      prepend(t) {
        let e = this.tx;
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
          let r = this.a, s = this.c;
          this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = s * t.a + this.d * t.c, this.d = s * t.b + this.d * t.d;
        }
        return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
      }
      decompose(t) {
        let e = this.a, r = this.b, s = this.c, o = this.d, n = t.pivot, a = -Math.atan2(-s, o), c = Math.atan2(r, e), l = Math.abs(a + c);
        return l < 1e-5 || Math.abs(dd - l) < 1e-5 ? (t.rotation = c, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = c), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(s * s + o * o), t.position.x = this.tx + (n.x * e + n.y * s), t.position.y = this.ty + (n.x * r + n.y * o), t;
      }
      invert() {
        let t = this.a, e = this.b, r = this.c, s = this.d, o = this.tx, n = t * s - e * r;
        return this.a = s / n, this.b = -e / n, this.c = -r / n, this.d = t / n, this.tx = (r * this.ty - s * o) / n, this.ty = -(t * this.ty - e * o) / n, this;
      }
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      identity() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
      }
      clone() {
        let t = new i3();
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
      }
      copyTo(t) {
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
      }
      copyFrom(t) {
        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
      }
      equals(t) {
        return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      static get IDENTITY() {
        return N0.identity();
      }
      static get shared() {
        return L0.identity();
      }
    }, L0 = new I(), N0 = new I();
  });
  var kt2;
  var Do = p(() => {
    "use strict";
    kt2 = class i3 {
      constructor(t, e, r) {
        this._x = e || 0, this._y = r || 0, this._observer = t;
      }
      clone(t) {
        return new i3(t ?? this._observer, this._x, this._y);
      }
      set(t = 0, e = t) {
        return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
      }
      copyFrom(t) {
        return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
      }
      copyTo(t) {
        return t.set(this._x, this._y), t;
      }
      equals(t) {
        return t.x === this._x && t.y === this._y;
      }
      toString() {
        return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
      }
      get x() {
        return this._x;
      }
      set x(t) {
        this._x !== t && (this._x = t, this._observer._onUpdate(this));
      }
      get y() {
        return this._y;
      }
      set y(t) {
        this._y !== t && (this._y = t, this._observer._onUpdate(this));
      }
    };
  });
  function q2(i3 = "default") {
    return ic[i3] === void 0 && (ic[i3] = -1), ++ic[i3];
  }
  var ic;
  var It2 = p(() => {
    "use strict";
    ic = { default: -1 };
  });
  function L2(i3, t, e = 3) {
    if (md[t]) return;
    let r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i3}`) : (r = r.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${i3}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i3}`), console.warn(r))), md[t] = true;
  }
  var md;
  var z;
  var gd;
  var ft2 = p(() => {
    "use strict";
    md = {}, z = "8.0.0", gd = "8.3.4";
  });
  var dr2;
  var sc = p(() => {
    "use strict";
    dr2 = class {
      constructor(t, e) {
        this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
      }
      prepopulate(t) {
        for (let e = 0; e < t; e++) this._pool[this._index++] = new this._classType();
        this._count += t;
      }
      get(t) {
        let e;
        return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType(), e.init?.(t), e;
      }
      return(t) {
        t.reset?.(), this._pool[this._index++] = t;
      }
      get totalSize() {
        return this._count;
      }
      get totalFree() {
        return this._index;
      }
      get totalUsed() {
        return this._count - this._index;
      }
      clear() {
        this._pool.length = 0, this._index = 0;
      }
    };
  });
  var oc;
  var V2;
  var Nt2 = p(() => {
    sc();
    oc = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      prepopulate(t, e) {
        this.getPool(t).prepopulate(e);
      }
      get(t, e) {
        return this.getPool(t).get(e);
      }
      return(t) {
        this.getPool(t.constructor).return(t);
      }
      getPool(t) {
        return this._poolsByClass.has(t) || this._poolsByClass.set(t, new dr2(t)), this._poolsByClass.get(t);
      }
      stats() {
        let t = {};
        return this._poolsByClass.forEach((e) => {
          let r = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
          t[r] = { free: e.totalFree, used: e.totalUsed, size: e.totalSize };
        }), t;
      }
    }, V2 = new oc();
  });
  var xd;
  var _d = p(() => {
    ft2();
    xd = { get isCachedAsTexture() {
      return !!this.renderGroup?.isCachedAsTexture;
    }, cacheAsTexture(i3) {
      typeof i3 == "boolean" && i3 === false ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(i3 === true ? {} : i3));
    }, updateCacheTexture() {
      this.renderGroup?.updateCacheTexture();
    }, get cacheAsBitmap() {
      return this.isCachedAsTexture;
    }, set cacheAsBitmap(i3) {
      L2("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(i3);
    } };
  });
  function Oo(i3, t, e) {
    let r = i3.length, s;
    if (t >= r || e === 0) return;
    e = t + e > r ? r - t : e;
    let o = r - e;
    for (s = t; s < o; ++s) i3[s] = i3[s + e];
    i3.length = o;
  }
  var nc = p(() => {
    "use strict";
  });
  var yd;
  var bd = p(() => {
    nc();
    ft2();
    yd = { allowChildren: true, removeChildren(i3 = 0, t) {
      let e = t ?? this.children.length, r = e - i3, s = [];
      if (r > 0 && r <= e) {
        for (let n = e - 1; n >= i3; n--) {
          let a = this.children[n];
          a && (s.push(a), a.parent = null);
        }
        Oo(this.children, i3, e);
        let o = this.renderGroup || this.parentRenderGroup;
        o && o.removeChildren(s);
        for (let n = 0; n < s.length; ++n) {
          let a = s[n];
          a.parentRenderLayer?.detach(a), this.emit("childRemoved", a, this, n), s[n].emit("removed", this);
        }
        return s.length > 0 && this._didViewChangeTick++, s;
      } else if (r === 0 && this.children.length === 0) return s;
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, removeChildAt(i3) {
      let t = this.getChildAt(i3);
      return this.removeChild(t);
    }, getChildAt(i3) {
      if (i3 < 0 || i3 >= this.children.length) throw new Error(`getChildAt: Index (${i3}) does not exist.`);
      return this.children[i3];
    }, setChildIndex(i3, t) {
      if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
      this.getChildIndex(i3), this.addChildAt(i3, t);
    }, getChildIndex(i3) {
      let t = this.children.indexOf(i3);
      if (t === -1) throw new Error("The supplied Container must be a child of the caller");
      return t;
    }, addChildAt(i3, t) {
      this.allowChildren || L2(z, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      let { children: e } = this;
      if (t < 0 || t > e.length) throw new Error(`${i3}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
      if (i3.parent) {
        let s = i3.parent.children.indexOf(i3);
        if (i3.parent === this && s === t) return i3;
        s !== -1 && i3.parent.children.splice(s, 1);
      }
      t === e.length ? e.push(i3) : e.splice(t, 0, i3), i3.parent = this, i3.didChange = true, i3._updateFlags = 15;
      let r = this.renderGroup || this.parentRenderGroup;
      return r && r.addChild(i3), this.sortableChildren && (this.sortDirty = true), this.emit("childAdded", i3, this, t), i3.emit("added", this), i3;
    }, swapChildren(i3, t) {
      if (i3 === t) return;
      let e = this.getChildIndex(i3), r = this.getChildIndex(t);
      this.children[e] = t, this.children[r] = i3;
      let s = this.renderGroup || this.parentRenderGroup;
      s && (s.structureDidChange = true), this._didContainerChangeTick++;
    }, removeFromParent() {
      this.parent?.removeChild(this);
    }, reparentChild(...i3) {
      return i3.length === 1 ? this.reparentChildAt(i3[0], this.children.length) : (i3.forEach((t) => this.reparentChildAt(t, this.children.length)), i3[0]);
    }, reparentChildAt(i3, t) {
      if (i3.parent === this) return this.setChildIndex(i3, t), i3;
      let e = i3.worldTransform.clone();
      i3.removeFromParent(), this.addChildAt(i3, t);
      let r = this.worldTransform.clone();
      return r.invert(), e.prepend(r), i3.setFromMatrix(e), i3;
    } };
  });
  var vd;
  var Td = p(() => {
    "use strict";
    vd = { collectRenderables(i3, t, e) {
      this.parentRenderLayer && this.parentRenderLayer !== e || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(i3, t, e) : this.renderGroup ? t.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i3) : this.collectRenderablesWithEffects(i3, t, e));
    }, collectRenderablesSimple(i3, t, e) {
      let r = this.children, s = r.length;
      for (let o = 0; o < s; o++) r[o].collectRenderables(i3, t, e);
    }, collectRenderablesWithEffects(i3, t, e) {
      let { renderPipes: r } = t;
      for (let s = 0; s < this.effects.length; s++) {
        let o = this.effects[s];
        r[o.pipe].push(o, this, i3);
      }
      this.collectRenderablesSimple(i3, t, e);
      for (let s = this.effects.length - 1; s >= 0; s--) {
        let o = this.effects[s];
        r[o.pipe].pop(o, this, i3);
      }
    } };
  });
  var Ge2;
  var Lo = p(() => {
    "use strict";
    Ge2 = class {
      constructor() {
        this.pipe = "filter", this.priority = 1;
      }
      destroy() {
        for (let t = 0; t < this.filters.length; t++) this.filters[t].destroy();
        this.filters = null, this.filterArea = null;
      }
    };
  });
  var ac;
  var No;
  var Sd = p(() => {
    E();
    Nt2();
    ac = class {
      constructor() {
        this._effectClasses = [], this._tests = [], this._initialized = false;
      }
      init() {
        this._initialized || (this._initialized = true, this._effectClasses.forEach((t) => {
          this.add({ test: t.test, maskClass: t });
        }));
      }
      add(t) {
        this._tests.push(t);
      }
      getMaskEffect(t) {
        this._initialized || this.init();
        for (let e = 0; e < this._tests.length; e++) {
          let r = this._tests[e];
          if (r.test(t)) return V2.get(r.maskClass, t);
        }
        return t;
      }
      returnMaskEffect(t) {
        V2.return(t);
      }
    }, No = new ac();
    U2.handleByList(_2.MaskEffect, No._effectClasses);
  });
  var wd;
  var Pd = p(() => {
    Lo();
    Sd();
    wd = { _maskEffect: null, _maskOptions: { inverse: false }, _filterEffect: null, effects: [], _markStructureAsChanged() {
      let i3 = this.renderGroup || this.parentRenderGroup;
      i3 && (i3.structureDidChange = true);
    }, addEffect(i3) {
      this.effects.indexOf(i3) === -1 && (this.effects.push(i3), this.effects.sort((e, r) => e.priority - r.priority), this._markStructureAsChanged(), this._updateIsSimple());
    }, removeEffect(i3) {
      let t = this.effects.indexOf(i3);
      t !== -1 && (this.effects.splice(t, 1), this._markStructureAsChanged(), this._updateIsSimple());
    }, set mask(i3) {
      let t = this._maskEffect;
      t?.mask !== i3 && (t && (this.removeEffect(t), No.returnMaskEffect(t), this._maskEffect = null), i3 != null && (this._maskEffect = No.getMaskEffect(i3), this.addEffect(this._maskEffect)));
    }, setMask(i3) {
      this._maskOptions = { ...this._maskOptions, ...i3 }, i3.mask && (this.mask = i3.mask), this._markStructureAsChanged();
    }, get mask() {
      return this._maskEffect?.mask;
    }, set filters(i3) {
      !Array.isArray(i3) && i3 && (i3 = [i3]);
      let t = this._filterEffect || (this._filterEffect = new Ge2());
      i3 = i3;
      let e = i3?.length > 0, r = t.filters?.length > 0, s = e !== r;
      i3 = Array.isArray(i3) ? i3.slice(0) : i3, t.filters = Object.freeze(i3), s && (e ? this.addEffect(t) : (this.removeEffect(t), t.filters = i3 ?? null));
    }, get filters() {
      return this._filterEffect?.filters;
    }, set filterArea(i3) {
      this._filterEffect || (this._filterEffect = new Ge2()), this._filterEffect.filterArea = i3;
    }, get filterArea() {
      return this._filterEffect?.filterArea;
    } };
  });
  var Ad;
  var Cd = p(() => {
    ft2();
    Ad = { label: null, get name() {
      return L2(z, "Container.name property has been removed, use Container.label instead"), this.label;
    }, set name(i3) {
      L2(z, "Container.name property has been removed, use Container.label instead"), this.label = i3;
    }, getChildByName(i3, t = false) {
      return this.getChildByLabel(i3, t);
    }, getChildByLabel(i3, t = false) {
      let e = this.children;
      for (let r = 0; r < e.length; r++) {
        let s = e[r];
        if (s.label === i3 || i3 instanceof RegExp && i3.test(s.label)) return s;
      }
      if (t) for (let r = 0; r < e.length; r++) {
        let o = e[r].getChildByLabel(i3, true);
        if (o) return o;
      }
      return null;
    }, getChildrenByLabel(i3, t = false, e = []) {
      let r = this.children;
      for (let s = 0; s < r.length; s++) {
        let o = r[s];
        (o.label === i3 || i3 instanceof RegExp && i3.test(o.label)) && e.push(o);
      }
      if (t) for (let s = 0; s < r.length; s++) r[s].getChildrenByLabel(i3, true, e);
      return e;
    } };
  });
  var Ho;
  var Y2;
  var St2 = p(() => {
    oe2();
    Ho = [new Z2(), new Z2(), new Z2(), new Z2()], Y2 = class i3 {
      constructor(t = 0, e = 0, r = 0, s = 0) {
        this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(s);
      }
      get left() {
        return this.x;
      }
      get right() {
        return this.x + this.width;
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.height;
      }
      isEmpty() {
        return this.left === this.right || this.top === this.bottom;
      }
      static get EMPTY() {
        return new i3(0, 0, 0, 0);
      }
      clone() {
        return new i3(this.x, this.y, this.width, this.height);
      }
      copyFromBounds(t) {
        return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
      }
      copyFrom(t) {
        return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
      }
      copyTo(t) {
        return t.copyFrom(this), t;
      }
      contains(t, e) {
        return this.width <= 0 || this.height <= 0 ? false : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
      }
      strokeContains(t, e, r, s = 0.5) {
        let { width: o, height: n } = this;
        if (o <= 0 || n <= 0) return false;
        let a = this.x, c = this.y, l = r * (1 - s), h = r - l, u = a - l, f = a + o + l, d2 = c - l, m = c + n + l, g = a + h, x2 = a + o - h, b = c + h, y = c + n - h;
        return t >= u && t <= f && e >= d2 && e <= m && !(t > g && t < x2 && e > b && e < y);
      }
      intersects(t, e) {
        if (!e) {
          let G2 = this.x < t.x ? t.x : this.x;
          if ((this.right > t.right ? t.right : this.right) <= G2) return false;
          let S2 = this.y < t.y ? t.y : this.y;
          return (this.bottom > t.bottom ? t.bottom : this.bottom) > S2;
        }
        let r = this.left, s = this.right, o = this.top, n = this.bottom;
        if (s <= r || n <= o) return false;
        let a = Ho[0].set(t.left, t.top), c = Ho[1].set(t.left, t.bottom), l = Ho[2].set(t.right, t.top), h = Ho[3].set(t.right, t.bottom);
        if (l.x <= a.x || c.y <= a.y) return false;
        let u = Math.sign(e.a * e.d - e.b * e.c);
        if (u === 0 || (e.apply(a, a), e.apply(c, c), e.apply(l, l), e.apply(h, h), Math.max(a.x, c.x, l.x, h.x) <= r || Math.min(a.x, c.x, l.x, h.x) >= s || Math.max(a.y, c.y, l.y, h.y) <= o || Math.min(a.y, c.y, l.y, h.y) >= n)) return false;
        let f = u * (c.y - a.y), d2 = u * (a.x - c.x), m = f * r + d2 * o, g = f * s + d2 * o, x2 = f * r + d2 * n, b = f * s + d2 * n;
        if (Math.max(m, g, x2, b) <= f * a.x + d2 * a.y || Math.min(m, g, x2, b) >= f * h.x + d2 * h.y) return false;
        let y = u * (a.y - l.y), v = u * (l.x - a.x), T2 = y * r + v * o, P = y * s + v * o, w = y * r + v * n, C = y * s + v * n;
        return !(Math.max(T2, P, w, C) <= y * a.x + v * a.y || Math.min(T2, P, w, C) >= y * h.x + v * h.y);
      }
      pad(t = 0, e = t) {
        return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
      }
      fit(t) {
        let e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), s = Math.max(this.y, t.y), o = Math.min(this.y + this.height, t.y + t.height);
        return this.x = e, this.width = Math.max(r - e, 0), this.y = s, this.height = Math.max(o - s, 0), this;
      }
      ceil(t = 1, e = 1e-3) {
        let r = Math.ceil((this.x + this.width - e) * t) / t, s = Math.ceil((this.y + this.height - e) * t) / t;
        return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = s - this.y, this;
      }
      enlarge(t) {
        let e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), s = Math.min(this.y, t.y), o = Math.max(this.y + this.height, t.y + t.height);
        return this.x = e, this.width = r - e, this.y = s, this.height = o - s, this;
      }
      getBounds(t) {
        return t || (t = new i3()), t.copyFrom(this), t;
      }
      containsRect(t) {
        if (this.width <= 0 || this.height <= 0) return false;
        let e = t.x, r = t.y, s = t.x + t.width, o = t.y + t.height;
        return e >= this.x && e < this.x + this.width && r >= this.y && r < this.y + this.height && s >= this.x && s < this.x + this.width && o >= this.y && o < this.y + this.height;
      }
      toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  });
  var Ed;
  var st2;
  var $t2 = p(() => {
    Q2();
    St2();
    Ed = new I(), st2 = class i3 {
      constructor(t = 1 / 0, e = 1 / 0, r = -1 / 0, s = -1 / 0) {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Ed, this.minX = t, this.minY = e, this.maxX = r, this.maxY = s;
      }
      isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
      }
      get rectangle() {
        this._rectangle || (this._rectangle = new Y2());
        let t = this._rectangle;
        return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
      }
      clear() {
        return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Ed, this;
      }
      set(t, e, r, s) {
        this.minX = t, this.minY = e, this.maxX = r, this.maxY = s;
      }
      addFrame(t, e, r, s, o) {
        o || (o = this.matrix);
        let n = o.a, a = o.b, c = o.c, l = o.d, h = o.tx, u = o.ty, f = this.minX, d2 = this.minY, m = this.maxX, g = this.maxY, x2 = n * t + c * e + h, b = a * t + l * e + u;
        x2 < f && (f = x2), b < d2 && (d2 = b), x2 > m && (m = x2), b > g && (g = b), x2 = n * r + c * e + h, b = a * r + l * e + u, x2 < f && (f = x2), b < d2 && (d2 = b), x2 > m && (m = x2), b > g && (g = b), x2 = n * t + c * s + h, b = a * t + l * s + u, x2 < f && (f = x2), b < d2 && (d2 = b), x2 > m && (m = x2), b > g && (g = b), x2 = n * r + c * s + h, b = a * r + l * s + u, x2 < f && (f = x2), b < d2 && (d2 = b), x2 > m && (m = x2), b > g && (g = b), this.minX = f, this.minY = d2, this.maxX = m, this.maxY = g;
      }
      addRect(t, e) {
        this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
      }
      addBounds(t, e) {
        this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
      }
      addBoundsMask(t) {
        this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
      }
      applyMatrix(t) {
        let e = this.minX, r = this.minY, s = this.maxX, o = this.maxY, { a: n, b: a, c, d: l, tx: h, ty: u } = t, f = n * e + c * r + h, d2 = a * e + l * r + u;
        this.minX = f, this.minY = d2, this.maxX = f, this.maxY = d2, f = n * s + c * r + h, d2 = a * s + l * r + u, this.minX = f < this.minX ? f : this.minX, this.minY = d2 < this.minY ? d2 : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d2 > this.maxY ? d2 : this.maxY, f = n * e + c * o + h, d2 = a * e + l * o + u, this.minX = f < this.minX ? f : this.minX, this.minY = d2 < this.minY ? d2 : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d2 > this.maxY ? d2 : this.maxY, f = n * s + c * o + h, d2 = a * s + l * o + u, this.minX = f < this.minX ? f : this.minX, this.minY = d2 < this.minY ? d2 : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d2 > this.maxY ? d2 : this.maxY;
      }
      fit(t) {
        return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
      }
      fitBounds(t, e, r, s) {
        return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < r && (this.minY = r), this.maxY > s && (this.maxY = s), this;
      }
      pad(t, e = t) {
        return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
      }
      ceil() {
        return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
      }
      clone() {
        return new i3(this.minX, this.minY, this.maxX, this.maxY);
      }
      scale(t, e = t) {
        return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
      }
      get x() {
        return this.minX;
      }
      set x(t) {
        let e = this.maxX - this.minX;
        this.minX = t, this.maxX = t + e;
      }
      get y() {
        return this.minY;
      }
      set y(t) {
        let e = this.maxY - this.minY;
        this.minY = t, this.maxY = t + e;
      }
      get width() {
        return this.maxX - this.minX;
      }
      set width(t) {
        this.maxX = this.minX + t;
      }
      get height() {
        return this.maxY - this.minY;
      }
      set height(t) {
        this.maxY = this.minY + t;
      }
      get left() {
        return this.minX;
      }
      get right() {
        return this.maxX;
      }
      get top() {
        return this.minY;
      }
      get bottom() {
        return this.maxY;
      }
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== 1 / 0;
      }
      addVertexData(t, e, r, s) {
        let o = this.minX, n = this.minY, a = this.maxX, c = this.maxY;
        s || (s = this.matrix);
        let l = s.a, h = s.b, u = s.c, f = s.d, d2 = s.tx, m = s.ty;
        for (let g = e; g < r; g += 2) {
          let x2 = t[g], b = t[g + 1], y = l * x2 + u * b + d2, v = h * x2 + f * b + m;
          o = y < o ? y : o, n = v < n ? v : n, a = y > a ? y : a, c = v > c ? v : c;
        }
        this.minX = o, this.minY = n, this.maxX = a, this.maxY = c;
      }
      containsPoint(t, e) {
        return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
      }
      toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
      copyFrom(t) {
        return this.minX = t.minX, this.minY = t.minY, this.maxX = t.maxX, this.maxY = t.maxY, this;
      }
    };
  });
  var vt2;
  var ee2;
  var fr2 = p(() => {
    Q2();
    sc();
    $t2();
    vt2 = new dr2(I), ee2 = new dr2(st2);
  });
  var H0;
  var Md;
  var Bd = p(() => {
    Q2();
    $t2();
    fr2();
    H0 = new I(), Md = { getFastGlobalBounds(i3, t) {
      t || (t = new st2()), t.clear(), this._getGlobalBoundsRecursive(!!i3, t, this.parentRenderLayer), t.isValid || t.set(0, 0, 0, 0);
      let e = this.renderGroup || this.parentRenderGroup;
      return t.applyMatrix(e.worldTransform), t;
    }, _getGlobalBoundsRecursive(i3, t, e) {
      let r = t;
      if (i3 && this.parentRenderLayer && this.parentRenderLayer !== e || this.localDisplayStatus !== 7 || !this.measurable) return;
      let s = !!this.effects.length;
      if ((this.renderGroup || s) && (r = ee2.get().clear()), this.boundsArea) t.addRect(this.boundsArea, this.worldTransform);
      else {
        if (this.renderPipeId) {
          let n = this.bounds;
          r.addFrame(n.minX, n.minY, n.maxX, n.maxY, this.groupTransform);
        }
        let o = this.children;
        for (let n = 0; n < o.length; n++) o[n]._getGlobalBoundsRecursive(i3, r, e);
      }
      if (s) {
        let o = false, n = this.renderGroup || this.parentRenderGroup;
        for (let a = 0; a < this.effects.length; a++) this.effects[a].addBounds && (o || (o = true, r.applyMatrix(n.worldTransform)), this.effects[a].addBounds(r, true));
        o && (r.applyMatrix(n.worldTransform.copyTo(H0).invert()), t.addBounds(r, this.relativeGroupTransform)), t.addBounds(r), ee2.return(r);
      } else this.renderGroup && (t.addBounds(r, this.relativeGroupTransform), ee2.return(r));
    } };
  });
  function Fr2(i3, t, e) {
    e.clear();
    let r, s;
    return i3.parent ? t ? r = i3.parent.worldTransform : (s = vt2.get().identity(), r = Wo(i3, s)) : r = I.IDENTITY, Rd(i3, e, r, t), s && vt2.return(s), e.isValid || e.set(0, 0, 0, 0), e;
  }
  function Rd(i3, t, e, r) {
    if (!i3.visible || !i3.measurable) return;
    let s;
    r ? s = i3.worldTransform : (i3.updateLocalTransform(), s = vt2.get(), s.appendFrom(i3.localTransform, e));
    let o = t, n = !!i3.effects.length;
    if (n && (t = ee2.get().clear()), i3.boundsArea) t.addRect(i3.boundsArea, s);
    else {
      i3.bounds && (t.matrix = s, t.addBounds(i3.bounds));
      for (let a = 0; a < i3.children.length; a++) Rd(i3.children[a], t, s, r);
    }
    if (n) {
      for (let a = 0; a < i3.effects.length; a++) i3.effects[a].addBounds?.(t);
      o.addBounds(t, I.IDENTITY), ee2.return(t);
    }
    r || vt2.return(s);
  }
  function Wo(i3, t) {
    let e = i3.parent;
    return e && (Wo(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
  }
  var Hi = p(() => {
    Q2();
    fr2();
  });
  function zo(i3, t) {
    if (i3 === 16777215 || !t) return t;
    if (t === 16777215 || !i3) return i3;
    let e = i3 >> 16 & 255, r = i3 >> 8 & 255, s = i3 & 255, o = t >> 16 & 255, n = t >> 8 & 255, a = t & 255, c = e * o / 255 | 0, l = r * n / 255 | 0, h = s * a / 255 | 0;
    return (c << 16) + (l << 8) + h;
  }
  var cc = p(() => {
    "use strict";
  });
  function Ur2(i3, t) {
    return i3 === Gd ? t : t === Gd ? i3 : zo(i3, t);
  }
  var Gd;
  var lc = p(() => {
    cc();
    Gd = 16777215;
  });
  function Wi(i3) {
    return ((i3 & 255) << 16) + (i3 & 65280) + (i3 >> 16 & 255);
  }
  var kd;
  var Id = p(() => {
    Hi();
    fr2();
    lc();
    kd = { getGlobalAlpha(i3) {
      if (i3) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
      let t = this.alpha, e = this.parent;
      for (; e; ) t *= e.alpha, e = e.parent;
      return t;
    }, getGlobalTransform(i3, t) {
      if (t) return i3.copyFrom(this.worldTransform);
      this.updateLocalTransform();
      let e = Wo(this, vt2.get().identity());
      return i3.appendFrom(this.localTransform, e), vt2.return(e), i3;
    }, getGlobalTint(i3) {
      if (i3) return this.renderGroup ? Wi(this.renderGroup.worldColor) : this.parentRenderGroup ? Wi(Ur2(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
      let t = this.localColor, e = this.parent;
      for (; e; ) t = Ur2(t, e.localColor), e = e.parent;
      return Wi(t);
    } };
  });
  function O2(...i3) {
    hc !== Fd && (hc++, hc === Fd ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i3));
  }
  var hc;
  var Fd;
  var ot2 = p(() => {
    "use strict";
    hc = 0, Fd = 500;
  });
  function Dr2(i3, t, e) {
    return t.clear(), e || (e = I.IDENTITY), Ud(i3, t, e, i3, true), t.isValid || t.set(0, 0, 0, 0), t;
  }
  function Ud(i3, t, e, r, s) {
    let o;
    if (s) o = vt2.get(), o = e.copyTo(o);
    else {
      if (!i3.visible || !i3.measurable) return;
      i3.updateLocalTransform();
      let c = i3.localTransform;
      o = vt2.get(), o.appendFrom(c, e);
    }
    let n = t, a = !!i3.effects.length;
    if (a && (t = ee2.get().clear()), i3.boundsArea) t.addRect(i3.boundsArea, o);
    else {
      i3.renderPipeId && (t.matrix = o, t.addBounds(i3.bounds));
      let c = i3.children;
      for (let l = 0; l < c.length; l++) Ud(c[l], t, o, r, false);
    }
    if (a) {
      for (let c = 0; c < i3.effects.length; c++) i3.effects[c].addLocalBounds?.(t, r);
      n.addBounds(t, I.IDENTITY), ee2.return(t);
    }
    vt2.return(o);
  }
  var Vo = p(() => {
    Q2();
    fr2();
  });
  function uc(i3, t) {
    let e = i3.children;
    for (let r = 0; r < e.length; r++) {
      let s = e[r], o = s.uid, n = (s._didViewChangeTick & 65535) << 16 | s._didContainerChangeTick & 65535, a = t.index;
      (t.data[a] !== o || t.data[a + 1] !== n) && (t.data[t.index] = o, t.data[t.index + 1] = n, t.didChange = true), t.index = a + 2, s.children.length && uc(s, t);
    }
    return t.didChange;
  }
  var Dd = p(() => {
    "use strict";
  });
  var W0;
  var Od;
  var Ld = p(() => {
    Q2();
    $t2();
    Hi();
    Vo();
    Dd();
    W0 = new I(), Od = { _localBoundsCacheId: -1, _localBoundsCacheData: null, _setWidth(i3, t) {
      let e = Math.sign(this.scale.x) || 1;
      t !== 0 ? this.scale.x = i3 / t * e : this.scale.x = e;
    }, _setHeight(i3, t) {
      let e = Math.sign(this.scale.y) || 1;
      t !== 0 ? this.scale.y = i3 / t * e : this.scale.y = e;
    }, getLocalBounds() {
      this._localBoundsCacheData || (this._localBoundsCacheData = { data: [], index: 1, didChange: false, localBounds: new st2() });
      let i3 = this._localBoundsCacheData;
      return i3.index = 1, i3.didChange = false, i3.data[0] !== this._didViewChangeTick && (i3.didChange = true, i3.data[0] = this._didViewChangeTick), uc(this, i3), i3.didChange && Dr2(this, i3.localBounds, W0), i3.localBounds;
    }, getBounds(i3, t) {
      return Fr2(this, i3, t || new st2());
    } };
  });
  var Nd;
  var Hd = p(() => {
    "use strict";
    Nd = { _onRender: null, set onRender(i3) {
      let t = this.renderGroup || this.parentRenderGroup;
      if (!i3) {
        this._onRender && t?.removeOnRender(this), this._onRender = null;
        return;
      }
      this._onRender || t?.addOnRender(this), this._onRender = i3;
    }, get onRender() {
      return this._onRender;
    } };
  });
  function z0(i3, t) {
    return i3._zIndex - t._zIndex;
  }
  var Wd;
  var zd = p(() => {
    "use strict";
    Wd = { _zIndex: 0, sortDirty: false, sortableChildren: false, get zIndex() {
      return this._zIndex;
    }, set zIndex(i3) {
      this._zIndex !== i3 && (this._zIndex = i3, this.depthOfChildModified());
    }, depthOfChildModified() {
      this.parent && (this.parent.sortableChildren = true, this.parent.sortDirty = true), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true);
    }, sortChildren() {
      this.sortDirty && (this.sortDirty = false, this.children.sort(z0));
    } };
  });
  var Vd;
  var Xd = p(() => {
    oe2();
    fr2();
    Vd = { getGlobalPosition(i3 = new Z2(), t = false) {
      return this.parent ? this.parent.toGlobal(this._position, i3, t) : (i3.x = this._position.x, i3.y = this._position.y), i3;
    }, toGlobal(i3, t, e = false) {
      let r = this.getGlobalTransform(vt2.get(), e);
      return t = r.apply(i3, t), vt2.return(r), t;
    }, toLocal(i3, t, e, r) {
      t && (i3 = t.toGlobal(i3, e, r));
      let s = this.getGlobalTransform(vt2.get(), r);
      return e = s.applyInverse(i3, e), vt2.return(s), e;
    } };
  });
  var Or2;
  var dc = p(() => {
    It2();
    Or2 = class {
      constructor() {
        this.uid = q2("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
      }
      reset() {
        this.instructionSize = 0;
      }
      add(t) {
        this.instructions[this.instructionSize++] = t;
      }
      log() {
        this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]);
      }
    };
  });
  function ke2(i3) {
    return i3 += i3 === 0 ? 1 : 0, --i3, i3 |= i3 >>> 1, i3 |= i3 >>> 2, i3 |= i3 >>> 4, i3 |= i3 >>> 8, i3 |= i3 >>> 16, i3 + 1;
  }
  function fc(i3) {
    return !(i3 & i3 - 1) && !!i3;
  }
  var zi = p(() => {
    "use strict";
  });
  function Xo(i3) {
    let t = {};
    for (let e in i3) i3[e] !== void 0 && (t[e] = i3[e]);
    return t;
  }
  var pc = p(() => {
    "use strict";
  });
  function V0(i3) {
    let t = Yd[i3];
    return t === void 0 && (Yd[i3] = q2("resource")), t;
  }
  var Yd;
  var $d;
  var Yo;
  var mc = p(() => {
    Dt2();
    It2();
    ft2();
    Yd = /* @__PURE__ */ Object.create(null);
    $d = class jd extends at2 {
      constructor(t = {}) {
        super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = false, t = { ...jd.defaultOptions, ...t }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
      }
      set addressMode(t) {
        this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
      }
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(t) {
        L2(z, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(t) {
        this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
      }
      get scaleMode() {
        return this.magFilter;
      }
      set maxAnisotropy(t) {
        this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      get _resourceId() {
        return this._sharedResourceId || this._generateResourceId();
      }
      update() {
        this.emit("change", this), this._sharedResourceId = null;
      }
      _generateResourceId() {
        let t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        return this._sharedResourceId = V0(t), this._resourceId;
      }
      destroy() {
        this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
      }
    };
    $d.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" };
    Yo = $d;
  });
  var Kd;
  var et3;
  var jt2 = p(() => {
    Dt2();
    zi();
    pc();
    It2();
    mc();
    Kd = class qd extends at2 {
      constructor(t = {}) {
        super(), this.options = t, this.uid = q2("textureSource"), this._resourceType = "textureSource", this._resourceId = q2("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = false, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = false, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = { ...qd.defaultOptions, ...t }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new Yo(Xo(t)), this.destroyed = false, this._refreshPOT();
      }
      get source() {
        return this;
      }
      get style() {
        return this._style;
      }
      set style(t) {
        this.style !== t && (this._style?.off("change", this._onStyleChange, this), this._style = t, this._style?.on("change", this._onStyleChange, this), this._onStyleChange());
      }
      get addressMode() {
        return this._style.addressMode;
      }
      set addressMode(t) {
        this._style.addressMode = t;
      }
      get repeatMode() {
        return this._style.addressMode;
      }
      set repeatMode(t) {
        this._style.addressMode = t;
      }
      get magFilter() {
        return this._style.magFilter;
      }
      set magFilter(t) {
        this._style.magFilter = t;
      }
      get minFilter() {
        return this._style.minFilter;
      }
      set minFilter(t) {
        this._style.minFilter = t;
      }
      get mipmapFilter() {
        return this._style.mipmapFilter;
      }
      set mipmapFilter(t) {
        this._style.mipmapFilter = t;
      }
      get lodMinClamp() {
        return this._style.lodMinClamp;
      }
      set lodMinClamp(t) {
        this._style.lodMinClamp = t;
      }
      get lodMaxClamp() {
        return this._style.lodMaxClamp;
      }
      set lodMaxClamp(t) {
        this._style.lodMaxClamp = t;
      }
      _onStyleChange() {
        this.emit("styleChange", this);
      }
      update() {
        if (this.resource) {
          let t = this._resolution;
          if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return;
        }
        this.emit("update", this);
      }
      destroy() {
        this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
      }
      unload() {
        this._resourceId = q2("resource"), this.emit("change", this), this.emit("unload", this);
      }
      get resourceWidth() {
        let { resource: t } = this;
        return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
      }
      get resourceHeight() {
        let { resource: t } = this;
        return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(t) {
        this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
      }
      resize(t, e, r) {
        r || (r = this._resolution), t || (t = this.width), e || (e = this.height);
        let s = Math.round(t * r), o = Math.round(e * r);
        return this.width = s / r, this.height = o / r, this._resolution = r, this.pixelWidth === s && this.pixelHeight === o ? false : (this._refreshPOT(), this.pixelWidth = s, this.pixelHeight = o, this.emit("resize", this), this._resourceId = q2("resource"), this.emit("change", this), true);
      }
      updateMipmaps() {
        this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
      }
      set wrapMode(t) {
        this._style.wrapMode = t;
      }
      get wrapMode() {
        return this._style.wrapMode;
      }
      set scaleMode(t) {
        this._style.scaleMode = t;
      }
      get scaleMode() {
        return this._style.scaleMode;
      }
      _refreshPOT() {
        this.isPowerOfTwo = fc(this.pixelWidth) && fc(this.pixelHeight);
      }
      static test(t) {
        throw new Error("Unimplemented");
      }
    };
    Kd.defaultOptions = { resolution: 1, format: "bgra8unorm", alphaMode: "premultiply-alpha-on-upload", dimensions: "2d", mipLevelCount: 1, autoGenerateMipmaps: false, sampleCount: 1, antialias: false, autoGarbageCollect: false };
    et3 = Kd;
  });
  function X0() {
    for (let i3 = 0; i3 < 16; i3++) {
      let t = [];
      gc.push(t);
      for (let e = 0; e < 16; e++) {
        let r = $o(pr2[i3] * pr2[e] + gr2[i3] * mr2[e]), s = $o(mr2[i3] * pr2[e] + xr2[i3] * mr2[e]), o = $o(pr2[i3] * gr2[e] + gr2[i3] * xr2[e]), n = $o(mr2[i3] * gr2[e] + xr2[i3] * xr2[e]);
        for (let a = 0; a < 16; a++) if (pr2[a] === r && mr2[a] === s && gr2[a] === o && xr2[a] === n) {
          t.push(a);
          break;
        }
      }
    }
    for (let i3 = 0; i3 < 16; i3++) {
      let t = new I();
      t.set(pr2[i3], mr2[i3], gr2[i3], xr2[i3], 0, 0), Zd.push(t);
    }
  }
  var pr2;
  var mr2;
  var gr2;
  var xr2;
  var gc;
  var Zd;
  var $o;
  var ut2;
  var Qd = p(() => {
    Q2();
    pr2 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], mr2 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], gr2 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], xr2 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], gc = [], Zd = [], $o = Math.sign;
    X0();
    ut2 = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: (i3) => pr2[i3], uY: (i3) => mr2[i3], vX: (i3) => gr2[i3], vY: (i3) => xr2[i3], inv: (i3) => i3 & 8 ? i3 & 15 : -i3 & 7, add: (i3, t) => gc[i3][t], sub: (i3, t) => gc[i3][ut2.inv(t)], rotate180: (i3) => i3 ^ 4, isVertical: (i3) => (i3 & 3) === 2, byDirection: (i3, t) => Math.abs(i3) * 2 <= Math.abs(t) ? t >= 0 ? ut2.S : ut2.N : Math.abs(t) * 2 <= Math.abs(i3) ? i3 > 0 ? ut2.E : ut2.W : t > 0 ? i3 > 0 ? ut2.SE : ut2.SW : i3 > 0 ? ut2.NE : ut2.NW, matrixAppendRotationInv: (i3, t, e = 0, r = 0) => {
      let s = Zd[ut2.inv(t)];
      s.tx = e, s.ty = r, i3.append(s);
    } };
  });
  var xc;
  var Jd = p(() => {
    "use strict";
    xc = () => {
    };
  });
  var _r2;
  var _c = p(() => {
    E();
    jt2();
    _r2 = class extends et3 {
      constructor(t) {
        let e = t.resource || new Float32Array(t.width * t.height * 4), r = t.format;
        r || (e instanceof Float32Array ? r = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? r = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? r = "rgba16uint" : (e instanceof Int8Array, r = "bgra8unorm")), super({ ...t, resource: e, format: r }), this.uploadMethodId = "buffer";
      }
      static test(t) {
        return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
      }
    };
    _r2.extension = _2.TextureSource;
  });
  var tf;
  var Lr2;
  var yc = p(() => {
    Q2();
    tf = new I(), Lr2 = class {
      constructor(t, e) {
        this.mapCoord = new I(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = false, this.texture = t;
      }
      get texture() {
        return this._texture;
      }
      set texture(t) {
        this.texture !== t && (this._texture?.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
      }
      multiplyUvs(t, e) {
        e === void 0 && (e = t);
        let r = this.mapCoord;
        for (let s = 0; s < t.length; s += 2) {
          let o = t[s], n = t[s + 1];
          e[s] = o * r.a + n * r.c + r.tx, e[s + 1] = o * r.b + n * r.d + r.ty;
        }
        return e;
      }
      update() {
        let t = this._texture;
        this._updateID++;
        let e = t.uvs;
        this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
        let r = t.orig, s = t.trim;
        s && (tf.set(r.width / s.width, 0, 0, r.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(tf));
        let o = t.source, n = this.uClampFrame, a = this.clampMargin / o._resolution, c = this.clampOffset / o._resolution;
        return n[0] = (t.frame.x + a + c) / o.width, n[1] = (t.frame.y + a + c) / o.height, n[2] = (t.frame.x + t.frame.width - a + c) / o.width, n[3] = (t.frame.y + t.frame.height - a + c) / o.height, this.uClampOffset[0] = this.clampOffset / o.pixelWidth, this.uClampOffset[1] = this.clampOffset / o.pixelHeight, this.isSimple = t.frame.width === o.width && t.frame.height === o.height && t.rotate === 0, true;
      }
    };
  });
  var B;
  var rt2 = p(() => {
    Dt2();
    Qd();
    St2();
    It2();
    ft2();
    Jd();
    _c();
    jt2();
    yc();
    B = class extends at2 {
      constructor({ source: t, label: e, frame: r, orig: s, trim: o, defaultAnchor: n, defaultBorders: a, rotate: c, dynamic: l } = {}) {
        if (super(), this.uid = q2("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new Y2(), this.noFrame = false, this.dynamic = false, this.isTexture = true, this.label = e, this.source = t?.source ?? new et3(), this.noFrame = !r, r) this.frame.copyFrom(r);
        else {
          let { width: h, height: u } = this._source;
          this.frame.width = h, this.frame.height = u;
        }
        this.orig = s || this.frame, this.trim = o, this.rotate = c ?? 0, this.defaultAnchor = n, this.defaultBorders = a, this.destroyed = false, this.dynamic = l || false, this.updateUvs();
      }
      set source(t) {
        this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
      }
      get source() {
        return this._source;
      }
      get textureMatrix() {
        return this._textureMatrix || (this._textureMatrix = new Lr2(this)), this._textureMatrix;
      }
      get width() {
        return this.orig.width;
      }
      get height() {
        return this.orig.height;
      }
      updateUvs() {
        let { uvs: t, frame: e } = this, { width: r, height: s } = this._source, o = e.x / r, n = e.y / s, a = e.width / r, c = e.height / s, l = this.rotate;
        if (l) {
          let h = a / 2, u = c / 2, f = o + h, d2 = n + u;
          l = ut2.add(l, ut2.NW), t.x0 = f + h * ut2.uX(l), t.y0 = d2 + u * ut2.uY(l), l = ut2.add(l, 2), t.x1 = f + h * ut2.uX(l), t.y1 = d2 + u * ut2.uY(l), l = ut2.add(l, 2), t.x2 = f + h * ut2.uX(l), t.y2 = d2 + u * ut2.uY(l), l = ut2.add(l, 2), t.x3 = f + h * ut2.uX(l), t.y3 = d2 + u * ut2.uY(l);
        } else t.x0 = o, t.y0 = n, t.x1 = o + a, t.y1 = n, t.x2 = o + a, t.y2 = n + c, t.x3 = o, t.y3 = n + c;
      }
      destroy(t = false) {
        this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = true, this.emit("destroy", this), this.removeAllListeners();
      }
      update() {
        this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
      }
      get baseTexture() {
        return L2(z, "Texture.baseTexture is now Texture.source"), this._source;
      }
    };
    B.EMPTY = new B({ label: "EMPTY", source: new et3({ label: "EMPTY" }) });
    B.EMPTY.destroy = xc;
    B.WHITE = new B({ source: new _r2({ resource: new Uint8Array([255, 255, 255, 255]), width: 1, height: 1, alphaMode: "premultiply-alpha-on-upload", label: "WHITE" }), label: "WHITE" });
    B.WHITE.destroy = xc;
  });
  var Y0;
  var bc;
  var pt2;
  var Ve2 = p(() => {
    zi();
    jt2();
    rt2();
    Y0 = 0, bc = class {
      constructor(t) {
        this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = false;
      }
      createTexture(t, e, r) {
        let s = new et3({ ...this.textureOptions, width: t, height: e, resolution: 1, antialias: r, autoGarbageCollect: false });
        return new B({ source: s, label: `texturePool_${Y0++}` });
      }
      getOptimalTexture(t, e, r = 1, s) {
        let o = Math.ceil(t * r - 1e-6), n = Math.ceil(e * r - 1e-6);
        o = ke2(o), n = ke2(n);
        let a = (o << 17) + (n << 1) + (s ? 1 : 0);
        this._texturePool[a] || (this._texturePool[a] = []);
        let c = this._texturePool[a].pop();
        return c || (c = this.createTexture(o, n, s)), c.source._resolution = r, c.source.width = o / r, c.source.height = n / r, c.source.pixelWidth = o, c.source.pixelHeight = n, c.frame.x = 0, c.frame.y = 0, c.frame.width = t, c.frame.height = e, c.updateUvs(), this._poolKeyHash[c.uid] = a, c;
      }
      getSameSizeTexture(t, e = false) {
        let r = t.source;
        return this.getOptimalTexture(t.width, t.height, r._resolution, e);
      }
      returnTexture(t) {
        let e = this._poolKeyHash[t.uid];
        this._texturePool[e].push(t);
      }
      clear(t) {
        if (t = t !== false, t) for (let e in this._texturePool) {
          let r = this._texturePool[e];
          if (r) for (let s = 0; s < r.length; s++) r[s].destroy(true);
        }
        this._texturePool = {};
      }
    }, pt2 = new bc();
  });
  var jo;
  var ef = p(() => {
    Q2();
    dc();
    Ve2();
    jo = class {
      constructor() {
        this.renderPipeId = "renderGroup", this.root = null, this.canBundle = false, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new I(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = true, this.instructionSet = new Or2(), this._onRenderContainers = [], this.textureNeedsUpdate = true, this.isCachedAsTexture = false, this._matrixDirty = 7;
      }
      init(t) {
        this.root = t, t._onRender && this.addOnRender(t), t.didChange = true;
        let e = t.children;
        for (let r = 0; r < e.length; r++) {
          let s = e[r];
          s._updateFlags = 15, this.addChild(s);
        }
      }
      enableCacheAsTexture(t = {}) {
        this.textureOptions = t, this.isCachedAsTexture = true, this.textureNeedsUpdate = true;
      }
      disableCacheAsTexture() {
        this.isCachedAsTexture = false, this.texture && (pt2.returnTexture(this.texture), this.texture = null);
      }
      updateCacheTexture() {
        this.textureNeedsUpdate = true;
      }
      reset() {
        this.renderGroupChildren.length = 0;
        for (let t in this.childrenToUpdate) {
          let e = this.childrenToUpdate[t];
          e.list.fill(null), e.index = 0;
        }
        this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = true, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
      }
      get localTransform() {
        return this.root.localTransform;
      }
      addRenderGroupChild(t) {
        t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
      }
      _removeRenderGroupChild(t) {
        let e = this.renderGroupChildren.indexOf(t);
        e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
      }
      addChild(t) {
        if (this.structureDidChange = true, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = true, this.onChildUpdate(t), t.renderGroup) {
          this.addRenderGroupChild(t.renderGroup);
          return;
        }
        t._onRender && this.addOnRender(t);
        let e = t.children;
        for (let r = 0; r < e.length; r++) this.addChild(e[r]);
      }
      removeChild(t) {
        if (this.structureDidChange = true, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
          this._removeRenderGroupChild(t.renderGroup);
          return;
        }
        let e = t.children;
        for (let r = 0; r < e.length; r++) this.removeChild(e[r]);
      }
      removeChildren(t) {
        for (let e = 0; e < t.length; e++) this.removeChild(t[e]);
      }
      onChildUpdate(t) {
        let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
        e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = { index: 0, list: [] }), e.list[e.index++] = t;
      }
      updateRenderable(t) {
        t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = false);
      }
      onChildViewUpdate(t) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
      }
      get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
      }
      addOnRender(t) {
        this._onRenderContainers.push(t);
      }
      removeOnRender(t) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
      }
      runOnRender(t) {
        for (let e = 0; e < this._onRenderContainers.length; e++) this._onRenderContainers[e]._onRender(t);
      }
      destroy() {
        this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
      }
      getChildren(t = []) {
        let e = this.root.children;
        for (let r = 0; r < e.length; r++) this._getChildren(e[r], t);
        return t;
      }
      _getChildren(t, e = []) {
        if (e.push(t), t.renderGroup) return e;
        let r = t.children;
        for (let s = 0; s < r.length; s++) this._getChildren(r[s], e);
        return e;
      }
      invalidateMatrices() {
        this._matrixDirty = 7;
      }
      get inverseWorldTransform() {
        return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new I()), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
      }
      get textureOffsetInverseTransform() {
        return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new I()), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y));
      }
      get inverseParentTextureTransform() {
        if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
        this._matrixDirty &= -5;
        let t = this._parentCacheAsTextureRenderGroup;
        return t ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new I()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(t.inverseWorldTransform).translate(-t._textureBounds.x, -t._textureBounds.y)) : this.worldTransform;
      }
      get cacheToLocalTransform() {
        return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
      }
    };
  });
  function rf(i3, t, e = {}) {
    for (let r in t) !e[r] && t[r] !== void 0 && (i3[r] = t[r]);
  }
  var sf = p(() => {
    "use strict";
  });
  var vc;
  var Tc;
  var Sc;
  var Nr2;
  var Vi;
  var yr2;
  var ct2;
  var fe2 = p(() => {
    Dt2();
    Gt2();
    ud();
    E();
    Q2();
    ec2();
    Do();
    It2();
    ft2();
    Nt2();
    _d();
    bd();
    Td();
    Pd();
    Cd();
    Bd();
    Id();
    Ld();
    Hd();
    zd();
    Xd();
    ef();
    sf();
    vc = new kt2(null), Tc = new kt2(null), Sc = new kt2(null, 1, 1), Nr2 = 1, Vi = 2, yr2 = 4, ct2 = class i3 extends at2 {
      constructor(t = {}) {
        super(), this.uid = q2("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = false, this.didViewUpdate = false, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = true, this.measurable = true, this.isSimple = true, this.updateTick = -1, this.localTransform = new I(), this.relativeGroupTransform = new I(), this.groupTransform = this.relativeGroupTransform, this.destroyed = false, this._position = new kt2(this, 0, 0), this._scale = Sc, this._pivot = Tc, this._skew = vc, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], rf(this, t, { children: true, parent: true, effects: true }), t.children?.forEach((e) => this.addChild(e)), t.parent?.addChild(this);
      }
      static mixin(t) {
        L2("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), U2.mixin(i3, t);
      }
      set _didChangeId(t) {
        this._didViewChangeTick = t >> 12 & 4095, this._didContainerChangeTick = t & 4095;
      }
      get _didChangeId() {
        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
      }
      addChild(...t) {
        if (this.allowChildren || L2(z, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
          for (let s = 0; s < t.length; s++) this.addChild(t[s]);
          return t[0];
        }
        let e = t[0], r = this.renderGroup || this.parentRenderGroup;
        return e.parent === this ? (this.children.splice(this.children.indexOf(e), 1), this.children.push(e), r && (r.structureDidChange = true), e) : (e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = true), e.parent = this, e.didChange = true, e._updateFlags = 15, r && r.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didViewChangeTick++, e._zIndex !== 0 && e.depthOfChildModified(), e);
      }
      removeChild(...t) {
        if (t.length > 1) {
          for (let s = 0; s < t.length; s++) this.removeChild(t[s]);
          return t[0];
        }
        let e = t[0], r = this.children.indexOf(e);
        return r > -1 && (this._didViewChangeTick++, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parentRenderLayer && e.parentRenderLayer.detach(e), e.parent = null, this.emit("childRemoved", e, this, r), e.emit("removed", this)), e;
      }
      _onUpdate(t) {
        t && t === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = true, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
      }
      set isRenderGroup(t) {
        !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
      }
      get isRenderGroup() {
        return !!this.renderGroup;
      }
      enableRenderGroup() {
        if (this.renderGroup) return;
        let t = this.parentRenderGroup;
        t?.removeChild(this), this.renderGroup = V2.get(jo, this), this.groupTransform = I.IDENTITY, t?.addChild(this), this._updateIsSimple();
      }
      disableRenderGroup() {
        if (!this.renderGroup) return;
        let t = this.parentRenderGroup;
        t?.removeChild(this), V2.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t?.addChild(this), this._updateIsSimple();
      }
      _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0;
      }
      get worldTransform() {
        return this._worldTransform || (this._worldTransform = new I()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
      }
      get x() {
        return this._position.x;
      }
      set x(t) {
        this._position.x = t;
      }
      get y() {
        return this._position.y;
      }
      set y(t) {
        this._position.y = t;
      }
      get position() {
        return this._position;
      }
      set position(t) {
        this._position.copyFrom(t);
      }
      get rotation() {
        return this._rotation;
      }
      set rotation(t) {
        this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
      }
      get angle() {
        return this.rotation * fd2;
      }
      set angle(t) {
        this.rotation = t * pd;
      }
      get pivot() {
        return this._pivot === Tc && (this._pivot = new kt2(this, 0, 0)), this._pivot;
      }
      set pivot(t) {
        this._pivot === Tc && (this._pivot = new kt2(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
      }
      get skew() {
        return this._skew === vc && (this._skew = new kt2(this, 0, 0)), this._skew;
      }
      set skew(t) {
        this._skew === vc && (this._skew = new kt2(this, 0, 0)), this._skew.copyFrom(t);
      }
      get scale() {
        return this._scale === Sc && (this._scale = new kt2(this, 1, 1)), this._scale;
      }
      set scale(t) {
        this._scale === Sc && (this._scale = new kt2(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
      }
      get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width);
      }
      set width(t) {
        let e = this.getLocalBounds().width;
        this._setWidth(t, e);
      }
      get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height);
      }
      set height(t) {
        let e = this.getLocalBounds().height;
        this._setHeight(t, e);
      }
      getSize(t) {
        t || (t = {});
        let e = this.getLocalBounds();
        return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
      }
      setSize(t, e) {
        let r = this.getLocalBounds();
        typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, r.width), e !== void 0 && this._setHeight(e, r.height);
      }
      _updateSkew() {
        let t = this._rotation, e = this._skew;
        this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
      }
      updateTransform(t) {
        return this.position.set(typeof t.x == "number" ? t.x : this.position.x, typeof t.y == "number" ? t.y : this.position.y), this.scale.set(typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x, typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(typeof t.skewX == "number" ? t.skewX : this.skew.x, typeof t.skewY == "number" ? t.skewY : this.skew.y), this.pivot.set(typeof t.pivotX == "number" ? t.pivotX : this.pivot.x, typeof t.pivotY == "number" ? t.pivotY : this.pivot.y), this;
      }
      setFromMatrix(t) {
        t.decompose(this);
      }
      updateLocalTransform() {
        let t = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === t) return;
        this._didLocalTransformChangeId = t;
        let e = this.localTransform, r = this._scale, s = this._pivot, o = this._position, n = r._x, a = r._y, c = s._x, l = s._y;
        e.a = this._cx * n, e.b = this._sx * n, e.c = this._cy * a, e.d = this._sy * a, e.tx = o._x - (c * e.a + l * e.c), e.ty = o._y - (c * e.b + l * e.d);
      }
      set alpha(t) {
        t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= Nr2, this._onUpdate());
      }
      get alpha() {
        return this.localAlpha;
      }
      set tint(t) {
        let r = $.shared.setValue(t ?? 16777215).toBgrNumber();
        r !== this.localColor && (this.localColor = r, this._updateFlags |= Nr2, this._onUpdate());
      }
      get tint() {
        return Wi(this.localColor);
      }
      set blendMode(t) {
        this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= Vi, this.localBlendMode = t, this._onUpdate());
      }
      get blendMode() {
        return this.localBlendMode;
      }
      get visible() {
        return !!(this.localDisplayStatus & 2);
      }
      set visible(t) {
        let e = t ? 2 : 0;
        (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= yr2, this.localDisplayStatus ^= 2, this._onUpdate());
      }
      get culled() {
        return !(this.localDisplayStatus & 4);
      }
      set culled(t) {
        let e = t ? 0 : 4;
        (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= yr2, this.localDisplayStatus ^= 4, this._onUpdate());
      }
      get renderable() {
        return !!(this.localDisplayStatus & 1);
      }
      set renderable(t) {
        let e = t ? 1 : 0;
        (this.localDisplayStatus & 1) !== e && (this._updateFlags |= yr2, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._onUpdate());
      }
      get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0;
      }
      destroy(t = false) {
        if (this.destroyed) return;
        this.destroyed = true;
        let e;
        if (this.children.length && (e = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof t == "boolean" ? t : t?.children) && e) for (let s = 0; s < e.length; ++s) e[s].destroy(t);
        this.renderGroup?.destroy(), this.renderGroup = null;
      }
    };
    U2.mixin(ct2, yd, Md, Vd, Nd, Od, wd, Ad, Wd, hd, xd, kd, vd);
  });
  var Xe2;
  var Ko = p(() => {
    oe2();
    Xe2 = class i3 {
      constructor(t) {
        this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = i3.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = new Z2(), this.page = new Z2(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t;
      }
      get layerX() {
        return this.layer.x;
      }
      get layerY() {
        return this.layer.y;
      }
      get pageX() {
        return this.page.x;
      }
      get pageY() {
        return this.page.y;
      }
      get data() {
        return this;
      }
      composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
      }
      initEvent(t, e, r) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      initUIEvent(t, e, r, s, o) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = true;
      }
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  });
  function $0(i3) {
    return function(t) {
      return t.test(i3);
    };
  }
  function Xi(i3) {
    var t = { userAgent: "", platform: "", maxTouchPoints: 0 };
    !i3 && typeof navigator < "u" ? t = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 } : typeof i3 == "string" ? t.userAgent = i3 : i3 && i3.userAgent && (t = { userAgent: i3.userAgent, platform: i3.platform, maxTouchPoints: i3.maxTouchPoints || 0 });
    var e = t.userAgent, r = e.split("[FBAN");
    typeof r[1] < "u" && (e = r[0]), r = e.split("Twitter"), typeof r[1] < "u" && (e = r[0]);
    var s = $0(e), o = { apple: { phone: s(wc) && !s(Ie2), ipod: s(of), tablet: !s(wc) && (s(nf) || mf(t)) && !s(Ie2), universal: s(af), device: (s(wc) || s(of) || s(nf) || s(af) || mf(t)) && !s(Ie2) }, amazon: { phone: s(Hr2), tablet: !s(Hr2) && s(qo), device: s(Hr2) || s(qo) }, android: { phone: !s(Ie2) && s(Hr2) || !s(Ie2) && s(Pc), tablet: !s(Ie2) && !s(Hr2) && !s(Pc) && (s(qo) || s(cf)), device: !s(Ie2) && (s(Hr2) || s(qo) || s(Pc) || s(cf)) || s(/\bokhttp\b/i) }, windows: { phone: s(Ie2), tablet: s(lf), device: s(Ie2) || s(lf) }, other: { blackberry: s(hf), blackberry10: s(uf), opera: s(df), firefox: s(pf), chrome: s(ff), device: s(hf) || s(uf) || s(df) || s(pf) || s(ff) }, any: false, phone: false, tablet: false };
    return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o;
  }
  var wc;
  var of;
  var nf;
  var af;
  var Pc;
  var cf;
  var Hr2;
  var qo;
  var Ie2;
  var lf;
  var hf;
  var uf;
  var df;
  var ff;
  var pf;
  var mf;
  var Ac = p(() => {
    wc = /iPhone/i, of = /iPod/i, nf = /iPad/i, af = /\biOS-universal(?:.+)Mac\b/i, Pc = /\bAndroid(?:.+)Mobile\b/i, cf = /Android/i, Hr2 = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, qo = /Silk/i, Ie2 = /Windows Phone/i, lf = /\bWindows(?:.+)ARM\b/i, hf = /BlackBerry/i, uf = /BB10/i, df = /Opera Mini/i, ff = /\b(CriOS|Chrome)(?:.+)Mobile/i, pf = /Mobile(?:.+)Firefox\b/i, mf = function(i3) {
      return typeof i3 < "u" && i3.platform === "MacIntel" && typeof i3.maxTouchPoints == "number" && i3.maxTouchPoints > 1 && typeof MSStream > "u";
    };
  });
  var gf = p(() => {
    Ac();
    Ac();
  });
  var j0;
  var xf;
  var _f = p(() => {
    gf();
    j0 = Xi.default ?? Xi, xf = j0(globalThis.navigator);
  });
  var K0;
  var Zo;
  var q0;
  var Z0;
  var yf;
  var bf;
  var Q0;
  var J0;
  var tT;
  var Cc;
  var Tf;
  var Sf = p(() => {
    Ko();
    E();
    _f();
    nc();
    K0 = 9, Zo = 100, q0 = 0, Z0 = 0, yf = 2, bf = 1, Q0 = -1e3, J0 = -1e3, tT = 2, Cc = class vf {
      constructor(t, e = xf) {
        this._mobileInfo = e, this.debug = false, this._activateOnTab = true, this._deactivateOnMouseMove = true, this._isActive = false, this._isMobileAccessibility = false, this._div = null, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (e.tablet || e.phone) && this._createTouchHook(), this._renderer = t;
      }
      get isActive() {
        return this._isActive;
      }
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      get hookDiv() {
        return this._hookDiv;
      }
      _createTouchHook() {
        let t = document.createElement("button");
        t.style.width = `${bf}px`, t.style.height = `${bf}px`, t.style.position = "absolute", t.style.top = `${Q0}px`, t.style.left = `${J0}px`, t.style.zIndex = tT.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
          this._isMobileAccessibility = true, this._activate(), this._destroyTouchHook();
        }), document.body.appendChild(t), this._hookDiv = t;
      }
      _destroyTouchHook() {
        this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
      }
      _activate() {
        if (this._isActive) return;
        this._isActive = true, this._div || (this._div = document.createElement("div"), this._div.style.width = `${Zo}px`, this._div.style.height = `${Zo}px`, this._div.style.position = "absolute", this._div.style.top = `${q0}px`, this._div.style.left = `${Z0}px`, this._div.style.zIndex = yf.toString(), this._div.style.pointerEvents = "none"), this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false)), this._deactivateOnMouseMove && (this._onMouseMove = this._onMouseMove.bind(this), globalThis.document.addEventListener("mousemove", this._onMouseMove, true));
        let t = this._renderer.view.canvas;
        if (t.parentNode) t.parentNode.appendChild(this._div), this._initAccessibilitySetup();
        else {
          let e = new MutationObserver(() => {
            t.parentNode && (t.parentNode.appendChild(this._div), e.disconnect(), this._initAccessibilitySetup());
          });
          e.observe(document.body, { childList: true, subtree: true });
        }
      }
      _initAccessibilitySetup() {
        this._renderer.runners.postrender.add(this), this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      }
      _deactivate() {
        if (!(!this._isActive || this._isMobileAccessibility)) {
          this._isActive = false, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, false), this._renderer.runners.postrender.remove(this);
          for (let t of this._children) t._accessibleDiv && t._accessibleDiv.parentNode && (t._accessibleDiv.parentNode.removeChild(t._accessibleDiv), t._accessibleDiv = null), t._accessibleActive = false;
          this._pool.forEach((t) => {
            t.parentNode && t.parentNode.removeChild(t);
          }), this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div), this._pool = [], this._children = [];
        }
      }
      _updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren) return;
        t.accessible && (t._accessibleActive || this._addChild(t), t._renderId = this._renderId);
        let e = t.children;
        if (e) for (let r = 0; r < e.length; r++) this._updateAccessibleObjects(e[r]);
      }
      init(t) {
        let r = { accessibilityOptions: { ...vf.defaultOptions, ...t?.accessibilityOptions || {} } };
        this.debug = r.accessibilityOptions.debug, this._activateOnTab = r.accessibilityOptions.activateOnTab, this._deactivateOnMouseMove = r.accessibilityOptions.deactivateOnMouseMove, r.accessibilityOptions.enabledByDefault ? this._activate() : this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false)), this._renderer.runners.postrender.remove(this);
      }
      postrender() {
        let t = performance.now();
        if (this._mobileInfo.android.device && t < this._androidUpdateCount || (this._androidUpdateCount = t + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas)) return;
        let e = /* @__PURE__ */ new Set();
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          for (let r of this._children) r._renderId === this._renderId && e.add(this._children.indexOf(r));
        }
        for (let r = this._children.length - 1; r >= 0; r--) {
          let s = this._children[r];
          e.has(r) || (s._accessibleDiv && s._accessibleDiv.parentNode && (s._accessibleDiv.parentNode.removeChild(s._accessibleDiv), this._pool.push(s._accessibleDiv), s._accessibleDiv = null), s._accessibleActive = false, Oo(this._children, r, 1));
        }
        if (this._renderer.renderingToScreen) {
          let { x: r, y: s, width: o, height: n } = this._renderer.screen, a = this._div;
          a.style.left = `${r}px`, a.style.top = `${s}px`, a.style.width = `${o}px`, a.style.height = `${n}px`;
        }
        for (let r = 0; r < this._children.length; r++) {
          let s = this._children[r];
          if (!s._accessibleActive || !s._accessibleDiv) continue;
          let o = s._accessibleDiv, n = s.hitArea || s.getBounds().rectangle;
          if (s.hitArea) {
            let a = s.worldTransform, c = this._renderer.resolution, l = this._renderer.resolution;
            o.style.left = `${(a.tx + n.x * a.a) * c}px`, o.style.top = `${(a.ty + n.y * a.d) * l}px`, o.style.width = `${n.width * a.a * c}px`, o.style.height = `${n.height * a.d * l}px`;
          } else {
            this._capHitArea(n);
            let a = this._renderer.resolution, c = this._renderer.resolution;
            o.style.left = `${n.x * a}px`, o.style.top = `${n.y * c}px`, o.style.width = `${n.width * a}px`, o.style.height = `${n.height * c}px`;
          }
        }
        this._renderId++;
      }
      _updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`;
      }
      _capHitArea(t) {
        t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
        let { width: e, height: r } = this._renderer;
        t.x + t.width > e && (t.width = e - t.x), t.y + t.height > r && (t.height = r - t.y);
      }
      _addChild(t) {
        let e = this._pool.pop();
        e || (t.accessibleType === "button" ? e = document.createElement("button") : (e = document.createElement(t.accessibleType), e.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `, t.accessibleText && (e.innerText = t.accessibleText)), e.style.width = `${Zo}px`, e.style.height = `${Zo}px`, e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = yf.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = `container ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this._updateDebugHTML(e), t._accessibleActive = true, t._accessibleDiv = e, e.container = t, this._children.push(t), this._div.appendChild(t._accessibleDiv), t.interactive && (t._accessibleDiv.tabIndex = t.tabIndex);
      }
      _dispatchEvent(t, e) {
        let { container: r } = t.target, s = this._renderer.events.rootBoundary, o = Object.assign(new Xe2(s), { target: r });
        s.rootTarget = this._renderer.lastObjectRendered, e.forEach((n) => s.dispatchEvent(o, n));
      }
      _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"]);
      }
      _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, ["mouseover"]);
      }
      _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, ["mouseout"]);
      }
      _onKeyDown(t) {
        t.keyCode !== K0 || !this._activateOnTab || this._activate();
      }
      _onMouseMove(t) {
        t.movementX === 0 && t.movementY === 0 || this._deactivate();
      }
      destroy() {
        this._deactivate(), this._destroyTouchHook(), this._div = null, this._pool = null, this._children = null, this._renderer = null, this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown);
      }
      setAccessibilityEnabled(t) {
        t ? this._activate() : this._deactivate();
      }
    };
    Cc.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem], name: "accessibility" };
    Cc.defaultOptions = { enabledByDefault: false, debug: false, activateOnTab: true, deactivateOnMouseMove: true };
    Tf = Cc;
  });
  var wf;
  var Pf = p(() => {
    "use strict";
    wf = { accessible: false, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: false, _accessibleDiv: null, accessibleType: "button", accessibleText: null, accessiblePointerEvents: "auto", accessibleChildren: true, _renderId: -1 };
  });
  var Af = p(() => {
    E();
    fe2();
    Sf();
    Pf();
    U2.add(Tf);
    U2.mixin(ct2, wf);
  });
  var Yi;
  var Cf = p(() => {
    E();
    Yi = class {
      static init(t) {
        Object.defineProperty(this, "resizeTo", { set(e) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = e, e && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        }, get() {
          return this._resizeTo;
        } }), this.queueResize = () => {
          this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));
        }, this._cancelResize = () => {
          this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);
        }, this.resize = () => {
          if (!this._resizeTo) return;
          this._cancelResize();
          let e, r;
          if (this._resizeTo === globalThis.window) e = globalThis.innerWidth, r = globalThis.innerHeight;
          else {
            let { clientWidth: s, clientHeight: o } = this._resizeTo;
            e = s, r = o;
          }
          this.renderer.resize(e, r), this.render();
        }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
      }
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
      }
    };
    Yi.extension = _2.Application;
  });
  var Ye2;
  var Qo = p(() => {
    "use strict";
    Ye2 = ((i3) => (i3[i3.INTERACTION = 50] = "INTERACTION", i3[i3.HIGH = 25] = "HIGH", i3[i3.NORMAL = 0] = "NORMAL", i3[i3.LOW = -25] = "LOW", i3[i3.UTILITY = -50] = "UTILITY", i3))(Ye2 || {});
  });
  var Wr2;
  var Ef = p(() => {
    "use strict";
    Wr2 = class {
      constructor(t, e = null, r = 0, s = false) {
        this.next = null, this.previous = null, this._destroyed = false, this._fn = t, this._context = e, this.priority = r, this._once = s;
      }
      match(t, e = null) {
        return this._fn === t && this._context === e;
      }
      emit(t) {
        this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
        let e = this.next;
        return this._once && this.destroy(true), this._destroyed && (this.next = null), e;
      }
      connect(t) {
        this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
      }
      destroy(t = false) {
        this._destroyed = true, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        let e = this.next;
        return this.next = t ? null : e, this.previous = null, e;
      }
    };
  });
  var Mf;
  var Kt2;
  var $i = p(() => {
    Qo();
    Ef();
    Mf = class re2 {
      constructor() {
        this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new Wr2(null, null, 1 / 0), this.deltaMS = 1 / re2.targetFPMS, this.elapsedMS = 1 / re2.targetFPMS, this._tick = (t) => {
          this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
        };
      }
      _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
      }
      _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
      }
      _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start();
      }
      add(t, e, r = Ye2.NORMAL) {
        return this._addListener(new Wr2(t, e, r));
      }
      addOnce(t, e, r = Ye2.NORMAL) {
        return this._addListener(new Wr2(t, e, r, true));
      }
      _addListener(t) {
        let e = this._head.next, r = this._head;
        if (!e) t.connect(r);
        else {
          for (; e; ) {
            if (t.priority > e.priority) {
              t.connect(r);
              break;
            }
            r = e, e = e.next;
          }
          t.previous || t.connect(r);
        }
        return this._startIfPossible(), this;
      }
      remove(t, e) {
        let r = this._head.next;
        for (; r; ) r.match(t, e) ? r = r.destroy() : r = r.next;
        return this._head.next || this._cancelIfNeeded(), this;
      }
      get count() {
        if (!this._head) return 0;
        let t = 0, e = this._head;
        for (; e = e.next; ) t++;
        return t;
      }
      start() {
        this.started || (this.started = true, this._requestIfNeeded());
      }
      stop() {
        this.started && (this.started = false, this._cancelIfNeeded());
      }
      destroy() {
        if (!this._protected) {
          this.stop();
          let t = this._head.next;
          for (; t; ) t = t.destroy(true);
          this._head.destroy(), this._head = null;
        }
      }
      update(t = performance.now()) {
        let e;
        if (t > this.lastTime) {
          if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
            let o = t - this._lastFrame | 0;
            if (o < this._minElapsedMS) return;
            this._lastFrame = t - o % this._minElapsedMS;
          }
          this.deltaMS = e, this.deltaTime = this.deltaMS * re2.targetFPMS;
          let r = this._head, s = r.next;
          for (; s; ) s = s.emit(this);
          r.next || this._cancelIfNeeded();
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = t;
      }
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(t) {
        let e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, re2.targetFPMS);
        this._maxElapsedMS = 1 / r;
      }
      get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      }
      set maxFPS(t) {
        if (t === 0) this._minElapsedMS = 0;
        else {
          let e = Math.max(this.minFPS, t);
          this._minElapsedMS = 1 / (e / 1e3);
        }
      }
      static get shared() {
        if (!re2._shared) {
          let t = re2._shared = new re2();
          t.autoStart = true, t._protected = true;
        }
        return re2._shared;
      }
      static get system() {
        if (!re2._system) {
          let t = re2._system = new re2();
          t.autoStart = true, t._protected = true;
        }
        return re2._system;
      }
    };
    Mf.targetFPMS = 0.06;
    Kt2 = Mf;
  });
  var ji;
  var Bf = p(() => {
    E();
    Qo();
    $i();
    ji = class {
      static init(t) {
        t = Object.assign({ autoStart: true, sharedTicker: false }, t), Object.defineProperty(this, "ticker", { set(e) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, Ye2.LOW);
        }, get() {
          return this._ticker;
        } }), this.stop = () => {
          this._ticker.stop();
        }, this.start = () => {
          this._ticker.start();
        }, this._ticker = null, this.ticker = t.sharedTicker ? Kt2.shared : new Kt2(), t.autoStart && this.start();
      }
      static destroy() {
        if (this._ticker) {
          let t = this._ticker;
          this.ticker = null, t.destroy();
        }
      }
    };
    ji.extension = _2.Application;
  });
  var Ec = p(() => {
    E();
    Cf();
    Bf();
    U2.add(Yi);
    U2.add(ji);
  });
  var Mc;
  var ye2;
  var Bc = p(() => {
    Qo();
    $i();
    Mc = class {
      constructor() {
        this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this._tickerAdded = false, this._pauseUpdate = true;
      }
      init(t) {
        this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this._tickerAdded = false, this._pauseUpdate = true;
      }
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(t) {
        this._pauseUpdate = t;
      }
      addTickerListener() {
        this._tickerAdded || !this.domElement || (Kt2.system.add(this._tickerUpdate, this, Ye2.INTERACTION), this._tickerAdded = true);
      }
      removeTickerListener() {
        this._tickerAdded && (Kt2.system.remove(this._tickerUpdate, this), this._tickerAdded = false);
      }
      pointerMoved() {
        this._didMove = true;
      }
      _update() {
        if (!this.domElement || this._pauseUpdate) return;
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        let t = this.events._rootPointerEvent;
        this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", { clientX: t.clientX, clientY: t.clientY, pointerType: t.pointerType, pointerId: t.pointerId }));
      }
      _tickerUpdate(t) {
        this._deltaTime += t.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update());
      }
    }, ye2 = new Mc();
  });
  var Fe2;
  var Jo = p(() => {
    oe2();
    Ko();
    Fe2 = class extends Xe2 {
      constructor() {
        super(...arguments), this.client = new Z2(), this.movement = new Z2(), this.offset = new Z2(), this.global = new Z2(), this.screen = new Z2();
      }
      get clientX() {
        return this.client.x;
      }
      get clientY() {
        return this.client.y;
      }
      get x() {
        return this.clientX;
      }
      get y() {
        return this.clientY;
      }
      get movementX() {
        return this.movement.x;
      }
      get movementY() {
        return this.movement.y;
      }
      get offsetX() {
        return this.offset.x;
      }
      get offsetY() {
        return this.offset.y;
      }
      get globalX() {
        return this.global.x;
      }
      get globalY() {
        return this.global.y;
      }
      get screenX() {
        return this.screen.x;
      }
      get screenY() {
        return this.screen.y;
      }
      getLocalPosition(t, e, r) {
        return t.worldTransform.applyInverse(r || this.global, e);
      }
      getModifierState(t) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t);
      }
      initMouseEvent(t, e, r, s, o, n, a, c, l, h, u, f, d2, m, g) {
        throw new Error("Method not implemented.");
      }
    };
  });
  var Ht2;
  var Rc = p(() => {
    Jo();
    Ht2 = class extends Fe2 {
      constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
      }
      getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [];
      }
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  });
  var be2;
  var Gc = p(() => {
    Jo();
    be2 = class extends Fe2 {
      constructor() {
        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
      }
    };
    be2.DOM_DELTA_PIXEL = 0;
    be2.DOM_DELTA_LINE = 1;
    be2.DOM_DELTA_PAGE = 2;
  });
  var eT;
  var rT;
  var Ki;
  var tn2;
  var Rf = p(() => {
    Dt2();
    oe2();
    ot2();
    Bc();
    Jo();
    Rc();
    Gc();
    eT = 2048, rT = new Z2(), Ki = new Z2(), tn2 = class {
      constructor(t) {
        this.dispatch = new at2(), this.moveOnAll = false, this.enableGlobalMoveEvents = true, this.mappingState = { trackingData: {} }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = false, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);
      }
      addEventMapping(t, e) {
        this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({ fn: e, priority: 0 }), this.mappingTable[t].sort((r, s) => r.priority - s.priority);
      }
      dispatchEvent(t, e) {
        t.propagationStopped = false, t.propagationImmediatelyStopped = false, this.propagate(t, e), this.dispatch.emit(e || t.type, t);
      }
      mapEvent(t) {
        if (!this.rootTarget) return;
        let e = this.mappingTable[t.type];
        if (e) for (let r = 0, s = e.length; r < s; r++) e[r].fn(t);
        else O2(`[EventBoundary]: Event mapping not defined for ${t.type}`);
      }
      hitTest(t, e) {
        ye2.pauseUpdate = true;
        let s = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", o = this[s](this.rootTarget, this.rootTarget.eventMode, rT.set(t, e), this.hitTestFn, this.hitPruneFn);
        return o && o[0];
      }
      propagate(t, e) {
        if (!t.target) return;
        let r = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let s = 0, o = r.length - 1; s < o; s++) if (t.currentTarget = r[s], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return;
        if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, e), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
          t.eventPhase = t.BUBBLING_PHASE;
          for (let s = r.length - 2; s >= 0; s--) if (t.currentTarget = r[s], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return;
        }
      }
      all(t, e, r = this._allInteractiveElements) {
        if (r.length === 0) return;
        t.eventPhase = t.BUBBLING_PHASE;
        let s = Array.isArray(e) ? e : [e];
        for (let o = r.length - 1; o >= 0; o--) s.forEach((n) => {
          t.currentTarget = r[o], this.notifyTarget(t, n);
        });
      }
      propagationPath(t) {
        let e = [t];
        for (let r = 0; r < eT && t !== this.rootTarget && t.parent; r++) {
          if (!t.parent) throw new Error("Cannot find propagation path to disconnected target");
          e.push(t.parent), t = t.parent;
        }
        return e.reverse(), e;
      }
      hitTestMoveRecursive(t, e, r, s, o, n = false) {
        let a = false;
        if (this._interactivePrune(t)) return null;
        if ((t.eventMode === "dynamic" || e === "dynamic") && (ye2.pauseUpdate = false), t.interactiveChildren && t.children) {
          let h = t.children;
          for (let u = h.length - 1; u >= 0; u--) {
            let f = h[u], d2 = this.hitTestMoveRecursive(f, this._isInteractive(e) ? e : f.eventMode, r, s, o, n || o(t, r));
            if (d2) {
              if (d2.length > 0 && !d2[d2.length - 1].parent) continue;
              let m = t.isInteractive();
              (d2.length > 0 || m) && (m && this._allInteractiveElements.push(t), d2.push(t)), this._hitElements.length === 0 && (this._hitElements = d2), a = true;
            }
          }
        }
        let c = this._isInteractive(e), l = t.isInteractive();
        return l && l && this._allInteractiveElements.push(t), n || this._hitElements.length > 0 ? null : a ? this._hitElements : c && !o(t, r) && s(t, r) ? l ? [t] : [] : null;
      }
      hitTestRecursive(t, e, r, s, o) {
        if (this._interactivePrune(t) || o(t, r)) return null;
        if ((t.eventMode === "dynamic" || e === "dynamic") && (ye2.pauseUpdate = false), t.interactiveChildren && t.children) {
          let c = t.children, l = r;
          for (let h = c.length - 1; h >= 0; h--) {
            let u = c[h], f = this.hitTestRecursive(u, this._isInteractive(e) ? e : u.eventMode, l, s, o);
            if (f) {
              if (f.length > 0 && !f[f.length - 1].parent) continue;
              let d2 = t.isInteractive();
              return (f.length > 0 || d2) && f.push(t), f;
            }
          }
        }
        let n = this._isInteractive(e), a = t.isInteractive();
        return n && s(t, r) ? a ? [t] : [] : null;
      }
      _isInteractive(t) {
        return t === "static" || t === "dynamic";
      }
      _interactivePrune(t) {
        return !t || !t.visible || !t.renderable || !t.measurable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren;
      }
      hitPruneFn(t, e) {
        if (t.hitArea && (t.worldTransform.applyInverse(e, Ki), !t.hitArea.contains(Ki.x, Ki.y))) return true;
        if (t.effects && t.effects.length) for (let r = 0; r < t.effects.length; r++) {
          let s = t.effects[r];
          if (s.containsPoint && !s.containsPoint(e, this.hitTestFn)) return true;
        }
        return false;
      }
      hitTestFn(t, e) {
        return t.hitArea ? true : t?.containsPoint ? (t.worldTransform.applyInverse(e, Ki), t.containsPoint(Ki)) : false;
      }
      notifyTarget(t, e) {
        if (!t.currentTarget.isInteractive()) return;
        e ?? (e = t.type);
        let r = `on${e}`;
        t.currentTarget[r]?.(t);
        let s = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
        this._notifyListeners(t, s), t.eventPhase === t.AT_TARGET && this._notifyListeners(t, e);
      }
      mapPointerDown(t) {
        if (!(t instanceof Ht2)) {
          O2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        let e = this.createPointerEvent(t);
        if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch") this.dispatchEvent(e, "touchstart");
        else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          let s = e.button === 2;
          this.dispatchEvent(e, s ? "rightdown" : "mousedown");
        }
        let r = this.trackingData(t.pointerId);
        r.pressTargetsByButton[t.button] = e.composedPath(), this.freeEvent(e);
      }
      mapPointerMove(t) {
        if (!(t instanceof Ht2)) {
          O2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = true;
        let e = this.createPointerEvent(t);
        this._isPointerMoveEvent = false;
        let r = e.pointerType === "mouse" || e.pointerType === "pen", s = this.trackingData(t.pointerId), o = this.findMountedTarget(s.overTargets);
        if (s.overTargets?.length > 0 && o !== e.target) {
          let c = t.type === "mousemove" ? "mouseout" : "pointerout", l = this.createPointerEvent(t, c, o);
          if (this.dispatchEvent(l, "pointerout"), r && this.dispatchEvent(l, "mouseout"), !e.composedPath().includes(o)) {
            let h = this.createPointerEvent(t, "pointerleave", o);
            for (h.eventPhase = h.AT_TARGET; h.target && !e.composedPath().includes(h.target); ) h.currentTarget = h.target, this.notifyTarget(h), r && this.notifyTarget(h, "mouseleave"), h.target = h.target.parent;
            this.freeEvent(h);
          }
          this.freeEvent(l);
        }
        if (o !== e.target) {
          let c = t.type === "mousemove" ? "mouseover" : "pointerover", l = this.clonePointerEvent(e, c);
          this.dispatchEvent(l, "pointerover"), r && this.dispatchEvent(l, "mouseover");
          let h = o?.parent;
          for (; h && h !== this.rootTarget.parent && h !== e.target; ) h = h.parent;
          if (!h || h === this.rootTarget.parent) {
            let f = this.clonePointerEvent(e, "pointerenter");
            for (f.eventPhase = f.AT_TARGET; f.target && f.target !== o && f.target !== this.rootTarget.parent; ) f.currentTarget = f.target, this.notifyTarget(f), r && this.notifyTarget(f, "mouseenter"), f.target = f.target.parent;
            this.freeEvent(f);
          }
          this.freeEvent(l);
        }
        let n = [], a = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? n.push("pointermove") : this.dispatchEvent(e, "pointermove"), a && n.push("globalpointermove"), e.pointerType === "touch" && (this.moveOnAll ? n.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), a && n.push("globaltouchmove")), r && (this.moveOnAll ? n.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), a && n.push("globalmousemove"), this.cursor = e.target?.cursor), n.length > 0 && this.all(e, n), this._allInteractiveElements.length = 0, this._hitElements.length = 0, s.overTargets = e.composedPath(), this.freeEvent(e);
      }
      mapPointerOver(t) {
        if (!(t instanceof Ht2)) {
          O2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        let e = this.trackingData(t.pointerId), r = this.createPointerEvent(t), s = r.pointerType === "mouse" || r.pointerType === "pen";
        this.dispatchEvent(r, "pointerover"), s && this.dispatchEvent(r, "mouseover"), r.pointerType === "mouse" && (this.cursor = r.target?.cursor);
        let o = this.clonePointerEvent(r, "pointerenter");
        for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; ) o.currentTarget = o.target, this.notifyTarget(o), s && this.notifyTarget(o, "mouseenter"), o.target = o.target.parent;
        e.overTargets = r.composedPath(), this.freeEvent(r), this.freeEvent(o);
      }
      mapPointerOut(t) {
        if (!(t instanceof Ht2)) {
          O2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        let e = this.trackingData(t.pointerId);
        if (e.overTargets) {
          let r = t.pointerType === "mouse" || t.pointerType === "pen", s = this.findMountedTarget(e.overTargets), o = this.createPointerEvent(t, "pointerout", s);
          this.dispatchEvent(o), r && this.dispatchEvent(o, "mouseout");
          let n = this.createPointerEvent(t, "pointerleave", s);
          for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent; ) n.currentTarget = n.target, this.notifyTarget(n), r && this.notifyTarget(n, "mouseleave"), n.target = n.target.parent;
          e.overTargets = null, this.freeEvent(o), this.freeEvent(n);
        }
        this.cursor = null;
      }
      mapPointerUp(t) {
        if (!(t instanceof Ht2)) {
          O2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        let e = performance.now(), r = this.createPointerEvent(t);
        if (this.dispatchEvent(r, "pointerup"), r.pointerType === "touch") this.dispatchEvent(r, "touchend");
        else if (r.pointerType === "mouse" || r.pointerType === "pen") {
          let a = r.button === 2;
          this.dispatchEvent(r, a ? "rightup" : "mouseup");
        }
        let s = this.trackingData(t.pointerId), o = this.findMountedTarget(s.pressTargetsByButton[t.button]), n = o;
        if (o && !r.composedPath().includes(o)) {
          let a = o;
          for (; a && !r.composedPath().includes(a); ) {
            if (r.currentTarget = a, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch") this.notifyTarget(r, "touchendoutside");
            else if (r.pointerType === "mouse" || r.pointerType === "pen") {
              let c = r.button === 2;
              this.notifyTarget(r, c ? "rightupoutside" : "mouseupoutside");
            }
            a = a.parent;
          }
          delete s.pressTargetsByButton[t.button], n = a;
        }
        if (n) {
          let a = this.clonePointerEvent(r, "click");
          a.target = n, a.path = null, s.clicksByButton[t.button] || (s.clicksByButton[t.button] = { clickCount: 0, target: a.target, timeStamp: e });
          let c = s.clicksByButton[t.button];
          if (c.target === a.target && e - c.timeStamp < 200 ? ++c.clickCount : c.clickCount = 1, c.target = a.target, c.timeStamp = e, a.detail = c.clickCount, a.pointerType === "mouse") {
            let l = a.button === 2;
            this.dispatchEvent(a, l ? "rightclick" : "click");
          } else a.pointerType === "touch" && this.dispatchEvent(a, "tap");
          this.dispatchEvent(a, "pointertap"), this.freeEvent(a);
        }
        this.freeEvent(r);
      }
      mapPointerUpOutside(t) {
        if (!(t instanceof Ht2)) {
          O2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        let e = this.trackingData(t.pointerId), r = this.findMountedTarget(e.pressTargetsByButton[t.button]), s = this.createPointerEvent(t);
        if (r) {
          let o = r;
          for (; o; ) s.currentTarget = o, this.notifyTarget(s, "pointerupoutside"), s.pointerType === "touch" ? this.notifyTarget(s, "touchendoutside") : (s.pointerType === "mouse" || s.pointerType === "pen") && this.notifyTarget(s, s.button === 2 ? "rightupoutside" : "mouseupoutside"), o = o.parent;
          delete e.pressTargetsByButton[t.button];
        }
        this.freeEvent(s);
      }
      mapWheel(t) {
        if (!(t instanceof be2)) {
          O2("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        let e = this.createWheelEvent(t);
        this.dispatchEvent(e), this.freeEvent(e);
      }
      findMountedTarget(t) {
        if (!t) return null;
        let e = t[0];
        for (let r = 1; r < t.length && t[r].parent === e; r++) e = t[r];
        return e;
      }
      createPointerEvent(t, e, r) {
        let s = this.allocateEvent(Ht2);
        return this.copyPointerData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.nativeEvent = t.nativeEvent, s.originalEvent = t, s.target = r ?? this.hitTest(s.global.x, s.global.y) ?? this._hitElements[0], typeof e == "string" && (s.type = e), s;
      }
      createWheelEvent(t) {
        let e = this.allocateEvent(be2);
        return this.copyWheelData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.nativeEvent = t.nativeEvent, e.originalEvent = t, e.target = this.hitTest(e.global.x, e.global.y), e;
      }
      clonePointerEvent(t, e) {
        let r = this.allocateEvent(Ht2);
        return r.nativeEvent = t.nativeEvent, r.originalEvent = t.originalEvent, this.copyPointerData(t, r), this.copyMouseData(t, r), this.copyData(t, r), r.target = t.target, r.path = t.composedPath().slice(), r.type = e ?? r.type, r;
      }
      copyWheelData(t, e) {
        e.deltaMode = t.deltaMode, e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ;
      }
      copyPointerData(t, e) {
        t instanceof Ht2 && e instanceof Ht2 && (e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist);
      }
      copyMouseData(t, e) {
        t instanceof Fe2 && e instanceof Fe2 && (e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.copyFrom(t.client), e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.copyFrom(t.movement), e.screen.copyFrom(t.screen), e.shiftKey = t.shiftKey, e.global.copyFrom(t.global));
      }
      copyData(t, e) {
        e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.detail = t.detail, e.view = t.view, e.which = t.which, e.layer.copyFrom(t.layer), e.page.copyFrom(t.page);
      }
      trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }), this.mappingState.trackingData[t];
      }
      allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        let e = this.eventPool.get(t).pop() || new t(this);
        return e.eventPhase = e.NONE, e.currentTarget = null, e.defaultPrevented = false, e.path = null, e.target = null, e;
      }
      freeEvent(t) {
        if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        let e = t.constructor;
        this.eventPool.has(e) || this.eventPool.set(e, []), this.eventPool.get(e).push(t);
      }
      _notifyListeners(t, e) {
        let r = t.currentTarget._events[e];
        if (r) if ("fn" in r) r.once && t.currentTarget.removeListener(e, r.fn, void 0, true), r.fn.call(r.context, t);
        else for (let s = 0, o = r.length; s < o && !t.propagationImmediatelyStopped; s++) r[s].once && t.currentTarget.removeListener(e, r[s].fn, void 0, true), r[s].fn.call(r[s].context, t);
      }
    };
  });
  var iT;
  var sT;
  var Ic;
  var en2;
  var Fc = p(() => {
    E();
    Rf();
    Bc();
    Rc();
    Gc();
    iT = 1, sT = { touchstart: "pointerdown", touchend: "pointerup", touchendoutside: "pointerupoutside", touchmove: "pointermove", touchcancel: "pointercancel" }, Ic = class kc {
      constructor(t) {
        this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new tn2(null), ye2.init(this), this.autoPreventDefault = true, this._eventsAdded = false, this._rootPointerEvent = new Ht2(null), this._rootWheelEvent = new be2(null), this.cursorStyles = { default: "inherit", pointer: "pointer" }, this.features = new Proxy({ ...kc.defaultEventFeatures }, { set: (e, r, s) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = s), e[r] = s, true) }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);
      }
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      init(t) {
        let { canvas: e, resolution: r } = this.renderer;
        this.setTargetElement(e), this.resolution = r, kc._defaultEventMode = t.eventMode ?? "passive", Object.assign(this.features, t.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      resolutionChange(t) {
        this.resolution = t;
      }
      destroy() {
        this.setTargetElement(null), this.renderer = null, this._currentCursor = null;
      }
      setCursor(t) {
        t || (t = "default");
        let e = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = false), this._currentCursor === t) return;
        this._currentCursor = t;
        let r = this.cursorStyles[t];
        if (r) switch (typeof r) {
          case "string":
            e && (this.domElement.style.cursor = r);
            break;
          case "function":
            r(t);
            break;
          case "object":
            e && Object.assign(this.domElement.style, r);
            break;
        }
        else e && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t);
      }
      get pointer() {
        return this._rootPointerEvent;
      }
      _onPointerDown(t) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let e = this._normalizeToPointerData(t);
        this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
        for (let r = 0, s = e.length; r < s; r++) {
          let o = e[r], n = this._bootstrapEvent(this._rootPointerEvent, o);
          this.rootBoundary.mapEvent(n);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      _onPointerMove(t) {
        if (!this.features.move) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, ye2.pointerMoved();
        let e = this._normalizeToPointerData(t);
        for (let r = 0, s = e.length; r < s; r++) {
          let o = this._bootstrapEvent(this._rootPointerEvent, e[r]);
          this.rootBoundary.mapEvent(o);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      _onPointerUp(t) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let e = t.target;
        t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
        let r = e !== this.domElement ? "outside" : "", s = this._normalizeToPointerData(t);
        for (let o = 0, n = s.length; o < n; o++) {
          let a = this._bootstrapEvent(this._rootPointerEvent, s[o]);
          a.type += r, this.rootBoundary.mapEvent(a);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      _onPointerOverOut(t) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let e = this._normalizeToPointerData(t);
        for (let r = 0, s = e.length; r < s; r++) {
          let o = this._bootstrapEvent(this._rootPointerEvent, e[r]);
          this.rootBoundary.mapEvent(o);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      onWheel(t) {
        if (!this.features.wheel) return;
        let e = this.normalizeWheelEvent(t);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(e);
      }
      setTargetElement(t) {
        this._removeEvents(), this.domElement = t, ye2.domElement = t, this._addEvents();
      }
      _addEvents() {
        if (this._eventsAdded || !this.domElement) return;
        ye2.addTickerListener();
        let t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, true), this.domElement.addEventListener("pointerdown", this._onPointerDown, true), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true), this.domElement.addEventListener("pointerover", this._onPointerOverOut, true), globalThis.addEventListener("pointerup", this._onPointerUp, true)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, true), this.domElement.addEventListener("mousedown", this._onPointerDown, true), this.domElement.addEventListener("mouseout", this._onPointerOverOut, true), this.domElement.addEventListener("mouseover", this._onPointerOverOut, true), globalThis.addEventListener("mouseup", this._onPointerUp, true), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, true), this.domElement.addEventListener("touchend", this._onPointerUp, true), this.domElement.addEventListener("touchmove", this._onPointerMove, true))), this.domElement.addEventListener("wheel", this.onWheel, { passive: true, capture: true }), this._eventsAdded = true;
      }
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) return;
        ye2.removeTickerListener();
        let t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, true), this.domElement.removeEventListener("pointerdown", this._onPointerDown, true), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true), globalThis.removeEventListener("pointerup", this._onPointerUp, true)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, true), this.domElement.removeEventListener("mousedown", this._onPointerDown, true), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true), globalThis.removeEventListener("mouseup", this._onPointerUp, true), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, true), this.domElement.removeEventListener("touchend", this._onPointerUp, true), this.domElement.removeEventListener("touchmove", this._onPointerMove, true))), this.domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this._eventsAdded = false;
      }
      mapPositionToPoint(t, e, r) {
        let s = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : { x: 0, y: 0, width: this.domElement.width, height: this.domElement.height, left: 0, top: 0 }, o = 1 / this.resolution;
        t.x = (e - s.left) * (this.domElement.width / s.width) * o, t.y = (r - s.top) * (this.domElement.height / s.height) * o;
      }
      _normalizeToPointerData(t) {
        let e = [];
        if (this.supportsTouchEvents && t instanceof TouchEvent) for (let r = 0, s = t.changedTouches.length; r < s; r++) {
          let o = t.changedTouches[r];
          typeof o.button > "u" && (o.button = 0), typeof o.buttons > "u" && (o.buttons = 1), typeof o.isPrimary > "u" && (o.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof o.width > "u" && (o.width = o.radiusX || 1), typeof o.height > "u" && (o.height = o.radiusY || 1), typeof o.tiltX > "u" && (o.tiltX = 0), typeof o.tiltY > "u" && (o.tiltY = 0), typeof o.pointerType > "u" && (o.pointerType = "touch"), typeof o.pointerId > "u" && (o.pointerId = o.identifier || 0), typeof o.pressure > "u" && (o.pressure = o.force || 0.5), typeof o.twist > "u" && (o.twist = 0), typeof o.tangentialPressure > "u" && (o.tangentialPressure = 0), typeof o.layerX > "u" && (o.layerX = o.offsetX = o.clientX), typeof o.layerY > "u" && (o.layerY = o.offsetY = o.clientY), o.isNormalized = true, o.type = t.type, e.push(o);
        }
        else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
          let r = t;
          typeof r.isPrimary > "u" && (r.isPrimary = true), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = iT), typeof r.pressure > "u" && (r.pressure = 0.5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = true, e.push(r);
        } else e.push(t);
        return e;
      }
      normalizeWheelEvent(t) {
        let e = this._rootWheelEvent;
        return this._transferMouseData(e, t), e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ, e.deltaMode = t.deltaMode, this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.nativeEvent = t, e.type = t.type, e;
      }
      _bootstrapEvent(t, e) {
        return t.originalEvent = null, t.nativeEvent = e, t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist, this._transferMouseData(t, e), this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = e.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = sT[t.type] || t.type), t;
      }
      _transferMouseData(t, e) {
        t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.x = e.clientX, t.client.y = e.clientY, t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.x = e.movementX, t.movement.y = e.movementY, t.page.x = e.pageX, t.page.y = e.pageY, t.relatedTarget = null, t.shiftKey = e.shiftKey;
      }
    };
    Ic.extension = { name: "events", type: [_2.WebGLSystem, _2.CanvasSystem, _2.WebGPUSystem], priority: -1 };
    Ic.defaultEventFeatures = { move: true, globalMove: true, click: true, wheel: true };
    en2 = Ic;
  });
  var Gf;
  var kf = p(() => {
    Fc();
    Ko();
    Gf = { onclick: null, onmousedown: null, onmouseenter: null, onmouseleave: null, onmousemove: null, onglobalmousemove: null, onmouseout: null, onmouseover: null, onmouseup: null, onmouseupoutside: null, onpointercancel: null, onpointerdown: null, onpointerenter: null, onpointerleave: null, onpointermove: null, onglobalpointermove: null, onpointerout: null, onpointerover: null, onpointertap: null, onpointerup: null, onpointerupoutside: null, onrightclick: null, onrightdown: null, onrightup: null, onrightupoutside: null, ontap: null, ontouchcancel: null, ontouchend: null, ontouchendoutside: null, ontouchmove: null, onglobaltouchmove: null, ontouchstart: null, onwheel: null, get interactive() {
      return this.eventMode === "dynamic" || this.eventMode === "static";
    }, set interactive(i3) {
      this.eventMode = i3 ? "static" : "passive";
    }, _internalEventMode: void 0, get eventMode() {
      return this._internalEventMode ?? en2.defaultEventMode;
    }, set eventMode(i3) {
      this._internalEventMode = i3;
    }, isInteractive() {
      return this.eventMode === "static" || this.eventMode === "dynamic";
    }, interactiveChildren: true, hitArea: null, addEventListener(i3, t, e) {
      let r = typeof e == "boolean" && e || typeof e == "object" && e.capture, s = typeof e == "object" ? e.signal : void 0, o = typeof e == "object" ? e.once === true : false, n = typeof t == "function" ? void 0 : t;
      i3 = r ? `${i3}capture` : i3;
      let a = typeof t == "function" ? t : t.handleEvent, c = this;
      s && s.addEventListener("abort", () => {
        c.off(i3, a, n);
      }), o ? c.once(i3, a, n) : c.on(i3, a, n);
    }, removeEventListener(i3, t, e) {
      let r = typeof e == "boolean" && e || typeof e == "object" && e.capture, s = typeof t == "function" ? void 0 : t;
      i3 = r ? `${i3}capture` : i3, t = typeof t == "function" ? t : t.handleEvent, this.off(i3, t, s);
    }, dispatchEvent(i3) {
      if (!(i3 instanceof Xe2)) throw new Error("Container cannot propagate events outside of the Federated Events API");
      return i3.defaultPrevented = false, i3.path = null, i3.target = this, i3.manager.dispatchEvent(i3), !i3.defaultPrevented;
    } };
  });
  var If = p(() => {
    E();
    fe2();
    Fc();
    kf();
    U2.add(en2);
    U2.mixin(ct2, Gf);
  });
  var qi;
  var Ff = p(() => {
    E();
    qi = class {
      constructor(t) {
        this._destroyRenderableBound = this.destroyRenderable.bind(this), this._attachedDomElements = [], this._renderer = t, this._renderer.runners.postrender.add(this), this._domElement = document.createElement("div"), this._domElement.style.position = "absolute", this._domElement.style.top = "0", this._domElement.style.left = "0", this._domElement.style.pointerEvents = "none", this._domElement.style.zIndex = "1000";
      }
      addRenderable(t, e) {
        this._attachedDomElements.includes(t) || (this._attachedDomElements.push(t), t.on("destroyed", this._destroyRenderableBound));
      }
      updateRenderable(t) {
      }
      validateRenderable(t) {
        return true;
      }
      destroyRenderable(t) {
        let e = this._attachedDomElements.indexOf(t);
        e !== -1 && this._attachedDomElements.splice(e, 1), t.off("destroyed", this._destroyRenderableBound);
      }
      postrender() {
        let t = this._attachedDomElements;
        if (t.length === 0) {
          this._domElement.remove();
          return;
        }
        let e = this._renderer.view.canvas;
        this._domElement.parentNode !== e.parentNode && e.parentNode?.appendChild(this._domElement), this._domElement.style.transform = `translate(${e.offsetLeft}px, ${e.offsetTop}px)`;
        for (let r = 0; r < t.length; r++) {
          let s = t[r], o = s.element;
          if (!s.parent || s.globalDisplayStatus < 7) o.remove(), t.splice(r, 1), r--;
          else {
            this._domElement.contains(o) || (o.style.position = "absolute", o.style.pointerEvents = "auto", this._domElement.appendChild(o));
            let n = s.worldTransform, a = s._anchor, c = s.width * a.x, l = s.height * a.y;
            o.style.transformOrigin = `${c}px ${l}px`, o.style.transform = `matrix(${n.a}, ${n.b}, ${n.c}, ${n.d}, ${n.tx - c}, ${n.ty - l})`, o.style.opacity = s.groupAlpha.toString();
          }
        }
      }
      destroy() {
        this._renderer.runners.postrender.remove(this);
        for (let t = 0; t < this._attachedDomElements.length; t++) {
          let e = this._attachedDomElements[t];
          e.off("destroyed", this._destroyRenderableBound), e.element.remove();
        }
        this._attachedDomElements.length = 0, this._domElement.remove(), this._renderer = null;
      }
    };
    qi.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "dom" };
  });
  var $e2;
  var rn2 = p(() => {
    $t2();
    fe2();
    $e2 = class extends ct2 {
      constructor(t) {
        super(t), this.canBundle = true, this.allowChildren = false, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new st2(0, 1, 0, 0), this._boundsDirty = true;
      }
      get bounds() {
        return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = false, this._bounds) : this._bounds;
      }
      get roundPixels() {
        return !!this._roundPixels;
      }
      set roundPixels(t) {
        this._roundPixels = t ? 1 : 0;
      }
      containsPoint(t) {
        let e = this.bounds, { x: r, y: s } = t;
        return r >= e.minX && r <= e.maxX && s >= e.minY && s <= e.maxY;
      }
      onViewUpdate() {
        if (this._didViewChangeTick++, this._boundsDirty = true, this.didViewUpdate) return;
        this.didViewUpdate = true;
        let t = this.renderGroup || this.parentRenderGroup;
        t && t.onChildViewUpdate(this);
      }
      destroy(t) {
        super.destroy(t), this._bounds = null;
      }
      collectRenderablesSimple(t, e, r) {
        let { renderPipes: s, renderableGC: o } = e;
        s.blendMode.setBlendMode(this, this.groupBlendMode, t), s[this.renderPipeId].addRenderable(this, t), o.addRenderable(this), this.didViewUpdate = false;
        let a = this.children, c = a.length;
        for (let l = 0; l < c; l++) a[l].collectRenderables(t, e, r);
      }
    };
  });
  var Uf = p(() => {
    E();
    Ff();
    U2.add(qi);
  });
  var Et2;
  var Ue2 = p(() => {
    "use strict";
    Et2 = ((i3) => (i3[i3.Low = 0] = "Low", i3[i3.Normal = 1] = "Normal", i3[i3.High = 2] = "High", i3))(Et2 || {});
  });
  var Df;
  var Of = p(() => {
    "use strict";
    Df = { createCanvas: (i3, t) => {
      let e = document.createElement("canvas");
      return e.width = i3, e.height = t, e;
    }, getCanvasRenderingContext2D: () => CanvasRenderingContext2D, getWebGLRenderingContext: () => WebGLRenderingContext, getNavigator: () => navigator, getBaseUrl: () => document.baseURI ?? window.location.href, getFontFaceSet: () => document.fonts, fetch: (i3, t) => fetch(i3, t), parseXML: (i3) => new DOMParser().parseFromString(i3, "text/xml") };
  });
  var Lf;
  var N;
  var lt2 = p(() => {
    Of();
    Lf = Df, N = { get() {
      return Lf;
    }, set(i3) {
      Lf = i3;
    } };
  });
  function pe2(i3) {
    if (typeof i3 != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(i3)}`);
  }
  function Zi(i3) {
    return i3.split("?")[0].split("#")[0];
  }
  function oT(i3) {
    return i3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function nT(i3, t, e) {
    return i3.replace(new RegExp(oT(t), "g"), e);
  }
  function aT(i3, t) {
    let e = "", r = 0, s = -1, o = 0, n = -1;
    for (let a = 0; a <= i3.length; ++a) {
      if (a < i3.length) n = i3.charCodeAt(a);
      else {
        if (n === 47) break;
        n = 47;
      }
      if (n === 47) {
        if (!(s === a - 1 || o === 1)) if (s !== a - 1 && o === 2) {
          if (e.length < 2 || r !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
            if (e.length > 2) {
              let c = e.lastIndexOf("/");
              if (c !== e.length - 1) {
                c === -1 ? (e = "", r = 0) : (e = e.slice(0, c), r = e.length - 1 - e.lastIndexOf("/")), s = a, o = 0;
                continue;
              }
            } else if (e.length === 2 || e.length === 1) {
              e = "", r = 0, s = a, o = 0;
              continue;
            }
          }
          t && (e.length > 0 ? e += "/.." : e = "..", r = 2);
        } else e.length > 0 ? e += `/${i3.slice(s + 1, a)}` : e = i3.slice(s + 1, a), r = a - s - 1;
        s = a, o = 0;
      } else n === 46 && o !== -1 ? ++o : o = -1;
    }
    return e;
  }
  var wt2;
  var br2 = p(() => {
    lt2();
    wt2 = { toPosix(i3) {
      return nT(i3, "\\", "/");
    }, isUrl(i3) {
      return /^https?:/.test(this.toPosix(i3));
    }, isDataUrl(i3) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i3);
    }, isBlobUrl(i3) {
      return i3.startsWith("blob:");
    }, hasProtocol(i3) {
      return /^[^/:]+:/.test(this.toPosix(i3));
    }, getProtocol(i3) {
      pe2(i3), i3 = this.toPosix(i3);
      let t = /^file:\/\/\//.exec(i3);
      if (t) return t[0];
      let e = /^[^/:]+:\/{0,2}/.exec(i3);
      return e ? e[0] : "";
    }, toAbsolute(i3, t, e) {
      if (pe2(i3), this.isDataUrl(i3) || this.isBlobUrl(i3)) return i3;
      let r = Zi(this.toPosix(t ?? N.get().getBaseUrl())), s = Zi(this.toPosix(e ?? this.rootname(r)));
      return i3 = this.toPosix(i3), i3.startsWith("/") ? wt2.join(s, i3.slice(1)) : this.isAbsolute(i3) ? i3 : this.join(r, i3);
    }, normalize(i3) {
      if (pe2(i3), i3.length === 0) return ".";
      if (this.isDataUrl(i3) || this.isBlobUrl(i3)) return i3;
      i3 = this.toPosix(i3);
      let t = "", e = i3.startsWith("/");
      this.hasProtocol(i3) && (t = this.rootname(i3), i3 = i3.slice(t.length));
      let r = i3.endsWith("/");
      return i3 = aT(i3, false), i3.length > 0 && r && (i3 += "/"), e ? `/${i3}` : t + i3;
    }, isAbsolute(i3) {
      return pe2(i3), i3 = this.toPosix(i3), this.hasProtocol(i3) ? true : i3.startsWith("/");
    }, join(...i3) {
      if (i3.length === 0) return ".";
      let t;
      for (let e = 0; e < i3.length; ++e) {
        let r = i3[e];
        if (pe2(r), r.length > 0) if (t === void 0) t = r;
        else {
          let s = i3[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(s).toLowerCase()) ? t += `/../${r}` : t += `/${r}`;
        }
      }
      return t === void 0 ? "." : this.normalize(t);
    }, dirname(i3) {
      if (pe2(i3), i3.length === 0) return ".";
      i3 = this.toPosix(i3);
      let t = i3.charCodeAt(0), e = t === 47, r = -1, s = true, o = this.getProtocol(i3), n = i3;
      i3 = i3.slice(o.length);
      for (let a = i3.length - 1; a >= 1; --a) if (t = i3.charCodeAt(a), t === 47) {
        if (!s) {
          r = a;
          break;
        }
      } else s = false;
      return r === -1 ? e ? "/" : this.isUrl(n) ? o + i3 : o : e && r === 1 ? "//" : o + i3.slice(0, r);
    }, rootname(i3) {
      pe2(i3), i3 = this.toPosix(i3);
      let t = "";
      if (i3.startsWith("/") ? t = "/" : t = this.getProtocol(i3), this.isUrl(i3)) {
        let e = i3.indexOf("/", t.length);
        e !== -1 ? t = i3.slice(0, e) : t = i3, t.endsWith("/") || (t += "/");
      }
      return t;
    }, basename(i3, t) {
      pe2(i3), t && pe2(t), i3 = Zi(this.toPosix(i3));
      let e = 0, r = -1, s = true, o;
      if (t !== void 0 && t.length > 0 && t.length <= i3.length) {
        if (t.length === i3.length && t === i3) return "";
        let n = t.length - 1, a = -1;
        for (o = i3.length - 1; o >= 0; --o) {
          let c = i3.charCodeAt(o);
          if (c === 47) {
            if (!s) {
              e = o + 1;
              break;
            }
          } else a === -1 && (s = false, a = o + 1), n >= 0 && (c === t.charCodeAt(n) ? --n === -1 && (r = o) : (n = -1, r = a));
        }
        return e === r ? r = a : r === -1 && (r = i3.length), i3.slice(e, r);
      }
      for (o = i3.length - 1; o >= 0; --o) if (i3.charCodeAt(o) === 47) {
        if (!s) {
          e = o + 1;
          break;
        }
      } else r === -1 && (s = false, r = o + 1);
      return r === -1 ? "" : i3.slice(e, r);
    }, extname(i3) {
      pe2(i3), i3 = Zi(this.toPosix(i3));
      let t = -1, e = 0, r = -1, s = true, o = 0;
      for (let n = i3.length - 1; n >= 0; --n) {
        let a = i3.charCodeAt(n);
        if (a === 47) {
          if (!s) {
            e = n + 1;
            break;
          }
          continue;
        }
        r === -1 && (s = false, r = n + 1), a === 46 ? t === -1 ? t = n : o !== 1 && (o = 1) : t !== -1 && (o = -1);
      }
      return t === -1 || r === -1 || o === 0 || o === 1 && t === r - 1 && t === e + 1 ? "" : i3.slice(t, r);
    }, parse(i3) {
      pe2(i3);
      let t = { root: "", dir: "", base: "", ext: "", name: "" };
      if (i3.length === 0) return t;
      i3 = Zi(this.toPosix(i3));
      let e = i3.charCodeAt(0), r = this.isAbsolute(i3), s, o = "";
      t.root = this.rootname(i3), r || this.hasProtocol(i3) ? s = 1 : s = 0;
      let n = -1, a = 0, c = -1, l = true, h = i3.length - 1, u = 0;
      for (; h >= s; --h) {
        if (e = i3.charCodeAt(h), e === 47) {
          if (!l) {
            a = h + 1;
            break;
          }
          continue;
        }
        c === -1 && (l = false, c = h + 1), e === 46 ? n === -1 ? n = h : u !== 1 && (u = 1) : n !== -1 && (u = -1);
      }
      return n === -1 || c === -1 || u === 0 || u === 1 && n === c - 1 && n === a + 1 ? c !== -1 && (a === 0 && r ? t.base = t.name = i3.slice(1, c) : t.base = t.name = i3.slice(a, c)) : (a === 0 && r ? (t.name = i3.slice(1, n), t.base = i3.slice(1, c)) : (t.name = i3.slice(a, n), t.base = i3.slice(a, c)), t.ext = i3.slice(n, c)), t.dir = this.dirname(i3), o && (t.dir = o + t.dir), t;
    }, sep: "/", delimiter: ":", joinExtensions: [".html"] };
  });
  var Wt2;
  var Qi = p(() => {
    "use strict";
    Wt2 = (i3, t, e = false) => (Array.isArray(i3) || (i3 = [i3]), t ? i3.map((r) => typeof r == "string" || e ? t(r) : r) : i3);
  });
  function Nf(i3, t, e, r, s) {
    let o = t[e];
    for (let n = 0; n < o.length; n++) {
      let a = o[n];
      e < t.length - 1 ? Nf(i3.replace(r[e], a), t, e + 1, r, s) : s.push(i3.replace(r[e], a));
    }
  }
  function Hf(i3) {
    let t = /\{(.*?)\}/g, e = i3.match(t), r = [];
    if (e) {
      let s = [];
      e.forEach((o) => {
        let n = o.substring(1, o.length - 1).split(",");
        s.push(n);
      }), Nf(i3, s, 0, e, r);
    } else r.push(i3);
    return r;
  }
  var Wf = p(() => {
    "use strict";
  });
  var vr2;
  var sn2 = p(() => {
    "use strict";
    vr2 = (i3) => !Array.isArray(i3);
  });
  function cT(i3) {
    return i3.split(".").pop().split("?").shift().split("#").shift();
  }
  var ie2;
  var zr2 = p(() => {
    ot2();
    br2();
    Qi();
    Wf();
    sn2();
    ie2 = class {
      constructor() {
        this._defaultBundleIdentifierOptions = { connector: "-", createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`, extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "") }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
      }
      setBundleIdentifier(t) {
        if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
      }
      prefer(...t) {
        t.forEach((e) => {
          this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
        }), this._resolverHash = {};
      }
      set basePath(t) {
        this._basePath = t;
      }
      get basePath() {
        return this._basePath;
      }
      set rootPath(t) {
        this._rootPath = t;
      }
      get rootPath() {
        return this._rootPath;
      }
      get parsers() {
        return this._parsers;
      }
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
      }
      setDefaultSearchParams(t) {
        if (typeof t == "string") this._defaultSearchParams = t;
        else {
          let e = t;
          this._defaultSearchParams = Object.keys(e).map((r) => `${encodeURIComponent(r)}=${encodeURIComponent(e[r])}`).join("&");
        }
      }
      getAlias(t) {
        let { alias: e, src: r } = t;
        return Wt2(e || r, (o) => typeof o == "string" ? o : Array.isArray(o) ? o.map((n) => n?.src ?? n) : o?.src ? o.src : o, true);
      }
      addManifest(t) {
        this._manifest && O2("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
          this.addBundle(e.name, e.assets);
        });
      }
      addBundle(t, e) {
        let r = [], s = e;
        Array.isArray(e) || (s = Object.entries(e).map(([o, n]) => typeof n == "string" || Array.isArray(n) ? { alias: o, src: n } : { alias: o, ...n })), s.forEach((o) => {
          let n = o.src, a = o.alias, c;
          if (typeof a == "string") {
            let l = this._createBundleAssetId(t, a);
            r.push(l), c = [a, l];
          } else {
            let l = a.map((h) => this._createBundleAssetId(t, h));
            r.push(...l), c = [...a, ...l];
          }
          this.add({ ...o, alias: c, src: n });
        }), this._bundles[t] = r;
      }
      add(t) {
        let e = [];
        Array.isArray(t) ? e.push(...t) : e.push(t);
        let r;
        r = (o) => {
          this.hasKey(o) && O2(`[Resolver] already has key: ${o} overwriting`);
        }, Wt2(e).forEach((o) => {
          let { src: n } = o, { data: a, format: c, loadParser: l } = o, h = Wt2(n).map((d2) => typeof d2 == "string" ? Hf(d2) : Array.isArray(d2) ? d2 : [d2]), u = this.getAlias(o);
          Array.isArray(u) ? u.forEach(r) : r(u);
          let f = [];
          h.forEach((d2) => {
            d2.forEach((m) => {
              let g = {};
              if (typeof m != "object") {
                g.src = m;
                for (let x2 = 0; x2 < this._parsers.length; x2++) {
                  let b = this._parsers[x2];
                  if (b.test(m)) {
                    g = b.parse(m);
                    break;
                  }
                }
              } else a = m.data ?? a, c = m.format ?? c, l = m.loadParser ?? l, g = { ...g, ...m };
              if (!u) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`);
              g = this._buildResolvedAsset(g, { aliases: u, data: a, format: c, loadParser: l }), f.push(g);
            });
          }), u.forEach((d2) => {
            this._assetMap[d2] = f;
          });
        });
      }
      resolveBundle(t) {
        let e = vr2(t);
        t = Wt2(t);
        let r = {};
        return t.forEach((s) => {
          let o = this._bundles[s];
          if (o) {
            let n = this.resolve(o), a = {};
            for (let c in n) {
              let l = n[c];
              a[this._extractAssetIdFromBundle(s, c)] = l;
            }
            r[s] = a;
          }
        }), e ? r[t[0]] : r;
      }
      resolveUrl(t) {
        let e = this.resolve(t);
        if (typeof t != "string") {
          let r = {};
          for (let s in e) r[s] = e[s].src;
          return r;
        }
        return e.src;
      }
      resolve(t) {
        let e = vr2(t);
        t = Wt2(t);
        let r = {};
        return t.forEach((s) => {
          if (!this._resolverHash[s]) if (this._assetMap[s]) {
            let o = this._assetMap[s], n = this._getPreferredOrder(o);
            n?.priority.forEach((a) => {
              n.params[a].forEach((c) => {
                let l = o.filter((h) => h[a] ? h[a] === c : false);
                l.length && (o = l);
              });
            }), this._resolverHash[s] = o[0];
          } else this._resolverHash[s] = this._buildResolvedAsset({ alias: [s], src: s }, {});
          r[s] = this._resolverHash[s];
        }), e ? r[t[0]] : r;
      }
      hasKey(t) {
        return !!this._assetMap[t];
      }
      hasBundle(t) {
        return !!this._bundles[t];
      }
      _getPreferredOrder(t) {
        for (let e = 0; e < t.length; e++) {
          let r = t[e], s = this._preferredOrder.find((o) => o.params.format.includes(r.format));
          if (s) return s;
        }
        return this._preferredOrder[0];
      }
      _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams) return t;
        let e = /\?/.test(t) ? "&" : "?";
        return `${t}${e}${this._defaultSearchParams}`;
      }
      _buildResolvedAsset(t, e) {
        let { aliases: r, data: s, loadParser: o, format: n } = e;
        return (this._basePath || this._rootPath) && (t.src = wt2.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = r ?? t.alias ?? [t.src], t.src = this._appendDefaultSearchParams(t.src), t.data = { ...s || {}, ...t.data }, t.loadParser = o ?? t.loadParser, t.format = n ?? t.format ?? cT(t.src), t;
      }
    };
    ie2.RETINA_PREFIX = /@([0-9\.]+)x/;
  });
  var Ji;
  var Uc = p(() => {
    "use strict";
    Ji = (i3, t) => {
      let e = t.split("?")[1];
      return e && (i3 += `?${e}`), i3;
    };
  });
  var zf;
  var Dc;
  var Vf = p(() => {
    St2();
    rt2();
    zf = class ts {
      constructor(t, e) {
        this.linkedSheets = [], this._texture = t instanceof B ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
        let r = parseFloat(e.meta.scale);
        r ? (this.resolution = r, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
      }
      parse() {
        return new Promise((t) => {
          this._callback = t, this._batchIndex = 0, this._frameKeys.length <= ts.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
        });
      }
      _processFrames(t) {
        let e = t, r = ts.BATCH_SIZE;
        for (; e - t < r && e < this._frameKeys.length; ) {
          let s = this._frameKeys[e], o = this._frames[s], n = o.frame;
          if (n) {
            let a = null, c = null, l = o.trimmed !== false && o.sourceSize ? o.sourceSize : o.frame, h = new Y2(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
            o.rotated ? a = new Y2(Math.floor(n.x) / this.resolution, Math.floor(n.y) / this.resolution, Math.floor(n.h) / this.resolution, Math.floor(n.w) / this.resolution) : a = new Y2(Math.floor(n.x) / this.resolution, Math.floor(n.y) / this.resolution, Math.floor(n.w) / this.resolution, Math.floor(n.h) / this.resolution), o.trimmed !== false && o.spriteSourceSize && (c = new Y2(Math.floor(o.spriteSourceSize.x) / this.resolution, Math.floor(o.spriteSourceSize.y) / this.resolution, Math.floor(n.w) / this.resolution, Math.floor(n.h) / this.resolution)), this.textures[s] = new B({ source: this.textureSource, frame: a, orig: h, trim: c, rotate: o.rotated ? 2 : 0, defaultAnchor: o.anchor, defaultBorders: o.borders, label: s.toString() });
          }
          e++;
        }
      }
      _processAnimations() {
        let t = this.data.animations || {};
        for (let e in t) {
          this.animations[e] = [];
          for (let r = 0; r < t[e].length; r++) {
            let s = t[e][r];
            this.animations[e].push(this.textures[s]);
          }
        }
      }
      _parseComplete() {
        let t = this._callback;
        this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
      }
      _nextBatch() {
        this._processFrames(this._batchIndex * ts.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
          this._batchIndex * ts.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
        }, 0);
      }
      destroy(t = false) {
        for (let e in this.textures) this.textures[e].destroy();
        this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (this._texture?.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
      }
    };
    zf.BATCH_SIZE = 1e3;
    Dc = zf;
  });
  function Xf(i3, t, e) {
    let r = {};
    if (i3.forEach((s) => {
      r[s] = t;
    }), Object.keys(t.textures).forEach((s) => {
      r[s] = t.textures[s];
    }), !e) {
      let s = wt2.dirname(i3[0]);
      t.linkedSheets.forEach((o, n) => {
        let a = Xf([`${s}/${t.data.meta.related_multi_packs[n]}`], o, true);
        Object.assign(r, a);
      });
    }
    return r;
  }
  var lT;
  var Yf;
  var $f = p(() => {
    Ue2();
    zr2();
    Uc();
    E();
    rt2();
    br2();
    Vf();
    lT = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"];
    Yf = { extension: _2.Asset, cache: { test: (i3) => i3 instanceof Dc, getCacheableAssets: (i3, t) => Xf(i3, t, false) }, resolver: { extension: { type: _2.ResolveParser, name: "resolveSpritesheet" }, test: (i3) => {
      let e = i3.split("?")[0].split("."), r = e.pop(), s = e.pop();
      return r === "json" && lT.includes(s);
    }, parse: (i3) => {
      let t = i3.split(".");
      return { resolution: parseFloat(ie2.RETINA_PREFIX.exec(i3)?.[1] ?? "1"), format: t[t.length - 2], src: i3 };
    } }, loader: { name: "spritesheetLoader", extension: { type: _2.LoadParser, priority: Et2.Normal, name: "spritesheetLoader" }, async testParse(i3, t) {
      return wt2.extname(t.src).toLowerCase() === ".json" && !!i3.frames;
    }, async parse(i3, t, e) {
      let { texture: r, imageFilename: s, textureOptions: o } = t?.data ?? {}, n = wt2.dirname(t.src);
      n && n.lastIndexOf("/") !== n.length - 1 && (n += "/");
      let a;
      if (r instanceof B) a = r;
      else {
        let h = Ji(n + (s ?? i3.meta.image), t.src);
        a = (await e.load([{ src: h, data: o }]))[h];
      }
      let c = new Dc(a.source, i3);
      await c.parse();
      let l = i3?.meta?.related_multi_packs;
      if (Array.isArray(l)) {
        let h = [];
        for (let f of l) {
          if (typeof f != "string") continue;
          let d2 = n + f;
          t.data?.ignoreMultiPack || (d2 = Ji(d2, t.src), h.push(e.load({ src: d2, data: { textureOptions: o, ignoreMultiPack: true } })));
        }
        let u = await Promise.all(h);
        c.linkedSheets = u, u.forEach((f) => {
          f.linkedSheets = [c].concat(c.linkedSheets.filter((d2) => d2 !== f));
        });
      }
      return c;
    }, async unload(i3, t, e) {
      await e.unload(i3.textureSource._sourceOrigin), i3.destroy(false);
    } } };
  });
  var on2 = p(() => {
    E();
    $f();
    U2.add(Yf);
  });
  function nn2(i3, t, e) {
    let { width: r, height: s } = e.orig, o = e.trim;
    if (o) {
      let n = o.width, a = o.height;
      i3.minX = o.x - t._x * r, i3.maxX = i3.minX + n, i3.minY = o.y - t._y * s, i3.maxY = i3.minY + a;
    } else i3.minX = -t._x * r, i3.maxX = i3.minX + r, i3.minY = -t._y * s, i3.maxY = i3.minY + s;
  }
  var Oc = p(() => {
    "use strict";
  });
  var Ft2;
  var an2 = p(() => {
    Do();
    rt2();
    Oc();
    ft2();
    rn2();
    Ft2 = class i3 extends $e2 {
      constructor(t = B.EMPTY) {
        t instanceof B && (t = { texture: t });
        let { texture: e = B.EMPTY, anchor: r, roundPixels: s, width: o, height: n, ...a } = t;
        super({ label: "Sprite", ...a }), this.renderPipeId = "sprite", this.batched = true, this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._anchor = new kt2({ _onUpdate: () => {
          this.onViewUpdate();
        } }), r ? this.anchor = r : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = false, this.roundPixels = s ?? false, o !== void 0 && (this.width = o), n !== void 0 && (this.height = n);
      }
      static from(t, e = false) {
        return t instanceof B ? new i3(t) : new i3(B.from(t, e));
      }
      set texture(t) {
        t || (t = B.EMPTY);
        let e = this._texture;
        e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
      }
      get texture() {
        return this._texture;
      }
      get visualBounds() {
        return nn2(this._visualBounds, this._anchor, this._texture), this._visualBounds;
      }
      get sourceBounds() {
        return L2("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
      }
      updateBounds() {
        let t = this._anchor, e = this._texture, r = this._bounds, { width: s, height: o } = e.orig;
        r.minX = -t._x * s, r.maxX = r.minX + s, r.minY = -t._y * o, r.maxY = r.minY + o;
      }
      destroy(t = false) {
        if (super.destroy(t), typeof t == "boolean" ? t : t?.texture) {
          let r = typeof t == "boolean" ? t : t?.textureSource;
          this._texture.destroy(r);
        }
        this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(t) {
        typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
      }
      get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(t) {
        this._setWidth(t, this._texture.orig.width), this._width = t;
      }
      get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(t) {
        this._setHeight(t, this._texture.orig.height), this._height = t;
      }
      getSize(t) {
        return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
      }
      setSize(t, e) {
        typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this._texture.orig.width), e !== void 0 && this._setHeight(e, this._texture.orig.height);
      }
    };
  });
  function cn2(i3, t, e) {
    let r = hT;
    i3.measurable = true, Fr2(i3, e, r), t.addBoundsMask(r), i3.measurable = false;
  }
  var hT;
  var Lc = p(() => {
    $t2();
    Hi();
    hT = new st2();
  });
  function ln2(i3, t, e) {
    let r = ee2.get();
    i3.measurable = true;
    let s = vt2.get().identity(), o = jf(i3, e, s);
    Dr2(i3, r, o), i3.measurable = false, t.addBoundsMask(r), vt2.return(s), ee2.return(r);
  }
  function jf(i3, t, e) {
    return i3 ? (i3 !== t && (jf(i3.parent, t, e), i3.updateLocalTransform(), e.append(i3.localTransform)), e) : (O2("Mask bounds, renderable is not inside the root container"), e);
  }
  var Nc = p(() => {
    Vo();
    fr2();
    ot2();
  });
  var es;
  var Kf = p(() => {
    E();
    an2();
    Lc();
    Nc();
    es = class {
      constructor(t) {
        this.priority = 0, this.inverse = false, this.pipe = "alphaMask", t?.mask && this.init(t.mask);
      }
      init(t) {
        this.mask = t, this.renderMaskToTexture = !(t instanceof Ft2), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true, this.mask = null;
      }
      addBounds(t, e) {
        this.inverse || cn2(this.mask, t, e);
      }
      addLocalBounds(t, e) {
        ln2(this.mask, t, e);
      }
      containsPoint(t, e) {
        let r = this.mask;
        return e(r, t);
      }
      destroy() {
        this.reset();
      }
      static test(t) {
        return t instanceof Ft2;
      }
    };
    es.extension = _2.MaskEffect;
  });
  var rs;
  var qf = p(() => {
    E();
    rs = class {
      constructor(t) {
        this.priority = 0, this.pipe = "colorMask", t?.mask && this.init(t.mask);
      }
      init(t) {
        this.mask = t;
      }
      destroy() {
      }
      static test(t) {
        return typeof t == "number";
      }
    };
    rs.extension = _2.MaskEffect;
  });
  var is;
  var Zf = p(() => {
    E();
    fe2();
    Lc();
    Nc();
    is = class {
      constructor(t) {
        this.priority = 0, this.pipe = "stencilMask", t?.mask && this.init(t.mask);
      }
      init(t) {
        this.mask = t, this.mask.includeInBuild = false, this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true, this.mask.includeInBuild = true, this.mask = null;
      }
      addBounds(t, e) {
        cn2(this.mask, t, e);
      }
      addLocalBounds(t, e) {
        ln2(this.mask, t, e);
      }
      containsPoint(t, e) {
        let r = this.mask;
        return e(r, t);
      }
      destroy() {
        this.reset();
      }
      static test(t) {
        return t instanceof ct2;
      }
    };
    is.extension = _2.MaskEffect;
  });
  var Ot2;
  var Vr2 = p(() => {
    lt2();
    E();
    jt2();
    Ot2 = class extends et3 {
      constructor(t) {
        t.resource || (t.resource = N.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity, this.resizeCanvas(), this.transparent = !!t.transparent;
      }
      resizeCanvas() {
        this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
      }
      resize(t = this.width, e = this.height, r = this._resolution) {
        let s = super.resize(t, e, r);
        return s && this.resizeCanvas(), s;
      }
      static test(t) {
        return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
      }
      get context2D() {
        return this._context2D || (this._context2D = this.resource.getContext("2d"));
      }
    };
    Ot2.extension = _2.TextureSource;
  });
  var qt2;
  var Xr2 = p(() => {
    lt2();
    E();
    ot2();
    jt2();
    qt2 = class extends et3 {
      constructor(t) {
        if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
          let e = N.get().createCanvas(t.resource.width, t.resource.height);
          e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, O2("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
        }
        super(t), this.uploadMethodId = "image", this.autoGarbageCollect = true;
      }
      static test(t) {
        return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame;
      }
    };
    qt2.extension = _2.TextureSource;
  });
  async function hn2() {
    return Hc ?? (Hc = (async () => {
      let t = document.createElement("canvas").getContext("webgl");
      if (!t) return "premultiply-alpha-on-upload";
      let e = await new Promise((n) => {
        let a = document.createElement("video");
        a.onloadeddata = () => n(a), a.onerror = () => n(null), a.autoplay = false, a.crossOrigin = "anonymous", a.preload = "auto", a.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", a.load();
      });
      if (!e) return "premultiply-alpha-on-upload";
      let r = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, r);
      let s = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, s), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
      let o = new Uint8Array(4);
      return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, o), t.deleteFramebuffer(s), t.deleteTexture(r), t.getExtension("WEBGL_lose_context")?.loseContext(), o[0] <= o[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })()), Hc;
  }
  var Hc;
  var Wc = p(() => {
    "use strict";
  });
  var un2;
  var Yr2;
  var zc = p(() => {
    E();
    $i();
    Wc();
    jt2();
    un2 = class Qf extends et3 {
      constructor(t) {
        super(t), this.isReady = false, this.uploadMethodId = "video", t = { ...Qf.defaultOptions, ...t }, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== false, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== false && this.load();
      }
      updateFrame() {
        if (!this.destroyed) {
          if (this._updateFPS) {
            let t = Kt2.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
          }
          (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
        }
      }
      _videoFrameRequestCallback() {
        this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
      }
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      async load() {
        if (this._load) return this._load;
        let t = this.resource, e = this.options;
        return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = true), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, true)), this.alphaMode = await hn2(), this._load = new Promise((r, s) => {
          this.isValid ? r(this) : (this._resolve = r, this._reject = s, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
            this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
          })), t.load());
        }), this._load;
      }
      _onError(t) {
        this.resource.removeEventListener("error", this._onError, true), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
      }
      _isSourcePlaying() {
        let t = this.resource;
        return !t.paused && !t.ended;
      }
      _isSourceReady() {
        return this.resource.readyState > 2;
      }
      _onPlayStart() {
        this.isValid || this._mediaReady(), this._configureAutoUpdate();
      }
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      _onSeeked() {
        this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
      }
      _onCanPlay() {
        this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
      }
      _onCanPlayThrough() {
        this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
      }
      _mediaReady() {
        let t = this.resource;
        this.isValid && (this.isReady = true, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
      }
      destroy() {
        this._configureAutoUpdate();
        let t = this.resource;
        t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, true), t.pause(), t.src = "", t.load()), super.destroy();
      }
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
      }
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(t) {
        t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
      }
      _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Kt2.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Kt2.shared.add(this.updateFrame, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Kt2.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
      }
      static test(t) {
        return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement;
      }
    };
    un2.extension = _2.TextureSource;
    un2.defaultOptions = { ...et3.defaultOptions, autoLoad: true, autoPlay: true, updateFPS: 0, crossorigin: true, loop: false, muted: true, playsinline: true, preload: false };
    un2.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" };
    Yr2 = un2;
  });
  var Vc;
  var tt2;
  var je2 = p(() => {
    ot2();
    Qi();
    Vc = class {
      constructor() {
        this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
      }
      reset() {
        this._cacheMap.clear(), this._cache.clear();
      }
      has(t) {
        return this._cache.has(t);
      }
      get(t) {
        let e = this._cache.get(t);
        return e || O2(`[Assets] Asset id ${t} was not found in the Cache`), e;
      }
      set(t, e) {
        let r = Wt2(t), s;
        for (let c = 0; c < this.parsers.length; c++) {
          let l = this.parsers[c];
          if (l.test(e)) {
            s = l.getCacheableAssets(r, e);
            break;
          }
        }
        let o = new Map(Object.entries(s || {}));
        s || r.forEach((c) => {
          o.set(c, e);
        });
        let n = [...o.keys()], a = { cacheKeys: n, keys: r };
        r.forEach((c) => {
          this._cacheMap.set(c, a);
        }), n.forEach((c) => {
          let l = s ? s[c] : e;
          this._cache.has(c) && this._cache.get(c) !== l && O2("[Cache] already has key:", c), this._cache.set(c, o.get(c));
        });
      }
      remove(t) {
        if (!this._cacheMap.has(t)) {
          O2(`[Assets] Asset id ${t} was not found in the Cache`);
          return;
        }
        let e = this._cacheMap.get(t);
        e.cacheKeys.forEach((s) => {
          this._cache.delete(s);
        }), e.keys.forEach((s) => {
          this._cacheMap.delete(s);
        });
      }
      get parsers() {
        return this._parsers;
      }
    }, tt2 = new Vc();
  });
  function Jf(i3 = {}) {
    let t = i3 && i3.resource, e = t ? i3.resource : i3, r = t ? i3 : { resource: i3 };
    for (let s = 0; s < Xc.length; s++) {
      let o = Xc[s];
      if (o.test(e)) return new o(r);
    }
    throw new Error(`Could not find a source type for resource: ${r.resource}`);
  }
  function tp(i3 = {}, t = false) {
    let e = i3 && i3.resource, r = e ? i3.resource : i3, s = e ? i3 : { resource: i3 };
    if (!t && tt2.has(r)) return tt2.get(r);
    let o = new B({ source: Jf(s) });
    return o.on("destroy", () => {
      tt2.has(r) && tt2.remove(r);
    }), t || tt2.set(r, o), o;
  }
  function ep(i3, t = false) {
    return typeof i3 == "string" ? tt2.get(i3) : i3 instanceof et3 ? new B({ source: i3 }) : tp(i3, t);
  }
  var Xc;
  var Yc = p(() => {
    je2();
    E();
    jt2();
    rt2();
    Xc = [];
    U2.handleByList(_2.TextureSource, Xc);
    B.from = ep;
    et3.from = Jf;
  });
  var dn2 = p(() => {
    E();
    Kf();
    qf();
    Zf();
    _c();
    Vr2();
    Xr2();
    zc();
    Yc();
    U2.add(es, rs, is, Yr2, qt2, Ot2, _r2);
  });
  var Mt2;
  var Ke2 = p(() => {
    "use strict";
    Mt2 = class {
      constructor(t) {
        this.resources = /* @__PURE__ */ Object.create(null), this._dirty = true;
        let e = 0;
        for (let r in t) {
          let s = t[r];
          this.setResource(s, e++);
        }
        this._updateKey();
      }
      _updateKey() {
        if (!this._dirty) return;
        this._dirty = false;
        let t = [], e = 0;
        for (let r in this.resources) t[e++] = this.resources[r]._resourceId;
        this._key = t.join("|");
      }
      setResource(t, e) {
        let r = this.resources[e];
        t !== r && (r && t.off?.("change", this.onResourceChange, this), t.on?.("change", this.onResourceChange, this), this.resources[e] = t, this._dirty = true);
      }
      getResource(t) {
        return this.resources[t];
      }
      _touch(t) {
        let e = this.resources;
        for (let r in e) e[r]._touched = t;
      }
      destroy() {
        let t = this.resources;
        for (let e in t) t[e].off?.("change", this.onResourceChange, this);
        this.resources = null;
      }
      onResourceChange(t) {
        if (this._dirty = true, t.destroyed) {
          let e = this.resources;
          for (let r in e) e[r] === t && (e[r] = null);
        } else this._updateKey();
      }
    };
  });
  function pn2() {
    return (!fn2 || fn2?.isContextLost()) && (fn2 = N.get().createCanvas().getContext("webgl", {})), fn2;
  }
  var fn2;
  var $c = p(() => {
    lt2();
  });
  function dT(i3) {
    let t = "";
    for (let e = 0; e < i3; ++e) e > 0 && (t += `
else `), e < i3 - 1 && (t += `if(test == ${e}.0){}`);
    return t;
  }
  function rp(i3, t) {
    if (i3 === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    let e = t.createShader(t.FRAGMENT_SHADER);
    try {
      for (; ; ) {
        let r = uT.replace(/%forloop%/gi, dT(i3));
        if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS)) i3 = i3 / 2 | 0;
        else break;
      }
    } finally {
      t.deleteShader(e);
    }
    return i3;
  }
  var uT;
  var ip = p(() => {
    "use strict";
    uT = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
  });
  function ne2() {
    if ($r2) return $r2;
    let i3 = pn2();
    return $r2 = i3.getParameter(i3.MAX_TEXTURE_IMAGE_UNITS), $r2 = rp($r2, i3), i3.getExtension("WEBGL_lose_context")?.loseContext(), $r2;
  }
  var $r2;
  var Tr2 = p(() => {
    $c();
    ip();
    $r2 = null;
  });
  function jr2(i3, t) {
    let e = 2166136261;
    for (let r = 0; r < t; r++) e ^= i3[r].uid, e = Math.imul(e, 16777619), e >>>= 0;
    return sp[e] || fT(i3, t, e);
  }
  function fT(i3, t, e) {
    let r = {}, s = 0;
    jc || (jc = ne2());
    for (let n = 0; n < jc; n++) {
      let a = n < t ? i3[n] : B.EMPTY.source;
      r[s++] = a.source, r[s++] = a.style;
    }
    let o = new Mt2(r);
    return sp[e] = o, o;
  }
  var sp;
  var jc;
  var mn2 = p(() => {
    Ke2();
    rt2();
    Tr2();
    sp = {};
    jc = 0;
  });
  var ve2;
  var Kc = p(() => {
    "use strict";
    ve2 = class {
      constructor(t) {
        typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
      }
      get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      }
      get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      }
      get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      }
      get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      }
      get float64View() {
        return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
      }
      get bigUint64View() {
        return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
      }
      view(t) {
        return this[`${t}View`];
      }
      destroy() {
        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
      }
      static sizeOf(t) {
        switch (t) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(`${t} isn't a valid view type`);
        }
      }
    };
  });
  function ss(i3, t) {
    let e = i3.byteLength / 8 | 0, r = new Float64Array(i3, 0, e);
    new Float64Array(t, 0, e).set(r);
    let o = i3.byteLength - e * 8;
    if (o > 0) {
      let n = new Uint8Array(i3, e * 8, o);
      new Uint8Array(t, e * 8, o).set(n);
    }
  }
  var qc = p(() => {
    "use strict";
  });
  var op;
  var ht2;
  var Sr2 = p(() => {
    "use strict";
    op = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" }, ht2 = ((i3) => (i3[i3.DISABLED = 0] = "DISABLED", i3[i3.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i3[i3.MASK_ACTIVE = 2] = "MASK_ACTIVE", i3[i3.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", i3[i3.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", i3[i3.NONE = 5] = "NONE", i3))(ht2 || {});
  });
  function De2(i3, t) {
    return t.alphaMode === "no-premultiply-alpha" && op[i3] || i3;
  }
  var os = p(() => {
    Sr2();
  });
  var gn2;
  var np = p(() => {
    "use strict";
    gn2 = class {
      constructor() {
        this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
      }
      clear() {
        for (let t = 0; t < this.count; t++) {
          let e = this.textures[t];
          this.textures[t] = null, this.ids[e.uid] = null;
        }
        this.count = 0;
      }
    };
  });
  function ap() {
    return Qc > 0 ? lp[--Qc] : new Zc();
  }
  function cp(i3) {
    lp[Qc++] = i3;
  }
  var Zc;
  var lp;
  var Qc;
  var ns;
  var hp;
  var up;
  var dp = p(() => {
    It2();
    Kc();
    qc();
    os();
    Tr2();
    np();
    Zc = class {
      constructor() {
        this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new gn2(), this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = true;
      }
      destroy() {
        this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
      }
    }, lp = [], Qc = 0;
    ns = 0, hp = class xn2 {
      constructor(t = {}) {
        this.uid = q2("batcher"), this.dirty = true, this.batchIndex = 0, this.batches = [], this._elements = [], xn2.defaultOptions.maxTextures = xn2.defaultOptions.maxTextures ?? ne2(), t = { ...xn2.defaultOptions, ...t };
        let { maxTextures: e, attributesInitialSize: r, indicesInitialSize: s } = t;
        this.attributeBuffer = new ve2(r * 4), this.indexBuffer = new Uint16Array(s), this.maxTextures = e;
      }
      begin() {
        this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
        for (let t = 0; t < this.batchIndex; t++) cp(this.batches[t]);
        this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = true;
      }
      add(t) {
        this._elements[this.elementSize++] = t, t._indexStart = this.indexSize, t._attributeStart = this.attributeSize, t._batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize;
      }
      checkAndUpdateTexture(t, e) {
        let r = t._batch.textures.ids[e._source.uid];
        return !r && r !== 0 ? false : (t._textureId = r, t.texture = e, true);
      }
      updateElement(t) {
        this.dirty = true;
        let e = this.attributeBuffer;
        t.packAsQuad ? this.packQuadAttributes(t, e.float32View, e.uint32View, t._attributeStart, t._textureId) : this.packAttributes(t, e.float32View, e.uint32View, t._attributeStart, t._textureId);
      }
      break(t) {
        let e = this._elements;
        if (!e[this.elementStart]) return;
        let r = ap(), s = r.textures;
        s.clear();
        let o = e[this.elementStart], n = De2(o.blendMode, o.texture._source), a = o.topology;
        this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
        let c = this.attributeBuffer.float32View, l = this.attributeBuffer.uint32View, h = this.indexBuffer, u = this._batchIndexSize, f = this._batchIndexStart, d2 = "startBatch", m = this.maxTextures;
        for (let g = this.elementStart; g < this.elementSize; ++g) {
          let x2 = e[g];
          e[g] = null;
          let y = x2.texture._source, v = De2(x2.blendMode, y), T2 = n !== v || a !== x2.topology;
          if (y._batchTick === ns && !T2) {
            x2._textureId = y._textureBindLocation, u += x2.indexSize, x2.packAsQuad ? (this.packQuadAttributes(x2, c, l, x2._attributeStart, x2._textureId), this.packQuadIndex(h, x2._indexStart, x2._attributeStart / this.vertexSize)) : (this.packAttributes(x2, c, l, x2._attributeStart, x2._textureId), this.packIndex(x2, h, x2._indexStart, x2._attributeStart / this.vertexSize)), x2._batch = r;
            continue;
          }
          y._batchTick = ns, (s.count >= m || T2) && (this._finishBatch(r, f, u - f, s, n, a, t, d2), d2 = "renderBatch", f = u, n = v, a = x2.topology, r = ap(), s = r.textures, s.clear(), ++ns), x2._textureId = y._textureBindLocation = s.count, s.ids[y.uid] = s.count, s.textures[s.count++] = y, x2._batch = r, u += x2.indexSize, x2.packAsQuad ? (this.packQuadAttributes(x2, c, l, x2._attributeStart, x2._textureId), this.packQuadIndex(h, x2._indexStart, x2._attributeStart / this.vertexSize)) : (this.packAttributes(x2, c, l, x2._attributeStart, x2._textureId), this.packIndex(x2, h, x2._indexStart, x2._attributeStart / this.vertexSize));
        }
        s.count > 0 && (this._finishBatch(r, f, u - f, s, n, a, t, d2), f = u, ++ns), this.elementStart = this.elementSize, this._batchIndexStart = f, this._batchIndexSize = u;
      }
      _finishBatch(t, e, r, s, o, n, a, c) {
        t.gpuBindGroup = null, t.bindGroup = null, t.action = c, t.batcher = this, t.textures = s, t.blendMode = o, t.topology = n, t.start = e, t.size = r, ++ns, this.batches[this.batchIndex++] = t, a.add(t);
      }
      finish(t) {
        this.break(t);
      }
      ensureAttributeBuffer(t) {
        t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
      }
      ensureIndexBuffer(t) {
        t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
      }
      _resizeAttributeBuffer(t) {
        let e = Math.max(t, this.attributeBuffer.size * 2), r = new ve2(e);
        ss(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r;
      }
      _resizeIndexBuffer(t) {
        let e = this.indexBuffer, r = Math.max(t, e.length * 1.5);
        r += r % 2;
        let s = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        if (s.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT) for (let o = 0; o < e.length; o++) s[o] = e[o];
        else ss(e.buffer, s.buffer);
        this.indexBuffer = s;
      }
      packQuadIndex(t, e, r) {
        t[e] = r + 0, t[e + 1] = r + 1, t[e + 2] = r + 2, t[e + 3] = r + 0, t[e + 4] = r + 2, t[e + 5] = r + 3;
      }
      packIndex(t, e, r, s) {
        let o = t.indices, n = t.indexSize, a = t.indexOffset, c = t.attributeOffset;
        for (let l = 0; l < n; l++) e[r++] = s + o[l + a] - c;
      }
      destroy() {
        for (let t = 0; t < this.batches.length; t++) cp(this.batches[t]);
        this.batches = null;
        for (let t = 0; t < this._elements.length; t++) this._elements[t]._batch = null;
        this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
      }
    };
    hp.defaultOptions = { maxTextures: null, attributesInitialSize: 4, indicesInitialSize: 6 };
    up = hp;
  });
  var K2;
  var Oe2 = p(() => {
    "use strict";
    K2 = ((i3) => (i3[i3.MAP_READ = 1] = "MAP_READ", i3[i3.MAP_WRITE = 2] = "MAP_WRITE", i3[i3.COPY_SRC = 4] = "COPY_SRC", i3[i3.COPY_DST = 8] = "COPY_DST", i3[i3.INDEX = 16] = "INDEX", i3[i3.VERTEX = 32] = "VERTEX", i3[i3.UNIFORM = 64] = "UNIFORM", i3[i3.STORAGE = 128] = "STORAGE", i3[i3.INDIRECT = 256] = "INDIRECT", i3[i3.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i3[i3.STATIC = 1024] = "STATIC", i3))(K2 || {});
  });
  var _t2;
  var qe2 = p(() => {
    Dt2();
    It2();
    Oe2();
    _t2 = class extends at2 {
      constructor(t) {
        let { data: e, size: r } = t, { usage: s, label: o, shrinkToFit: n } = t;
        super(), this.uid = q2("buffer"), this._resourceType = "buffer", this._resourceId = q2("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = true, this.destroyed = false, e instanceof Array && (e = new Float32Array(e)), this._data = e, r ?? (r = e?.byteLength);
        let a = !!e;
        this.descriptor = { size: r, usage: s, mappedAtCreation: a, label: o }, this.shrinkToFit = n ?? true;
      }
      get data() {
        return this._data;
      }
      set data(t) {
        this.setDataWithSize(t, t.length, true);
      }
      get dataInt32() {
        return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
      }
      get static() {
        return !!(this.descriptor.usage & K2.STATIC);
      }
      set static(t) {
        t ? this.descriptor.usage |= K2.STATIC : this.descriptor.usage &= ~K2.STATIC;
      }
      setDataWithSize(t, e, r) {
        if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
          r && this.emit("update", this);
          return;
        }
        let s = this._data;
        if (this._data = t, this._dataInt32 = null, !s || s.length !== t.length) {
          !this.shrinkToFit && s && t.byteLength < s.byteLength ? r && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = q2("resource"), this.emit("change", this));
          return;
        }
        r && this.emit("update", this);
      }
      update(t) {
        this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
      }
      destroy() {
        this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
      }
    };
  });
  function Jc(i3, t) {
    if (!(i3 instanceof _t2)) {
      let e = t ? K2.INDEX : K2.VERTEX;
      i3 instanceof Array && (t ? (i3 = new Uint32Array(i3), e = K2.INDEX | K2.COPY_DST) : (i3 = new Float32Array(i3), e = K2.VERTEX | K2.COPY_DST)), i3 = new _t2({ data: i3, label: t ? "index-mesh-buffer" : "vertex-mesh-buffer", usage: e });
    }
    return i3;
  }
  var fp = p(() => {
    qe2();
    Oe2();
  });
  function pp(i3, t, e) {
    let r = i3.getAttribute(t);
    if (!r) return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
    let s = r.buffer.data, o = 1 / 0, n = 1 / 0, a = -1 / 0, c = -1 / 0, l = s.BYTES_PER_ELEMENT, h = (r.offset || 0) / l, u = (r.stride || 2 * 4) / l;
    for (let f = h; f < s.length; f += u) {
      let d2 = s[f], m = s[f + 1];
      d2 > a && (a = d2), m > c && (c = m), d2 < o && (o = d2), m < n && (n = m);
    }
    return e.minX = o, e.minY = n, e.maxX = a, e.maxY = c, e;
  }
  var mp = p(() => {
    "use strict";
  });
  function pT(i3) {
    return (i3 instanceof _t2 || Array.isArray(i3) || i3.BYTES_PER_ELEMENT) && (i3 = { buffer: i3 }), i3.buffer = Jc(i3.buffer, false), i3;
  }
  var ae2;
  var Kr2 = p(() => {
    Dt2();
    $t2();
    It2();
    qe2();
    fp();
    mp();
    ae2 = class extends at2 {
      constructor(t = {}) {
        super(), this.uid = q2("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new st2(), this._boundsDirty = true;
        let { attributes: e, indexBuffer: r, topology: s } = t;
        if (this.buffers = [], this.attributes = {}, e) for (let o in e) this.addAttribute(o, e[o]);
        this.instanceCount = t.instanceCount ?? 1, r && this.addIndex(r), this.topology = s || "triangle-list";
      }
      onBufferUpdate() {
        this._boundsDirty = true, this.emit("update", this);
      }
      getAttribute(t) {
        return this.attributes[t];
      }
      getIndex() {
        return this.indexBuffer;
      }
      getBuffer(t) {
        return this.getAttribute(t).buffer;
      }
      getSize() {
        for (let t in this.attributes) {
          let e = this.attributes[t];
          return e.buffer.data.length / (e.stride / 4 || e.size);
        }
        return 0;
      }
      addAttribute(t, e) {
        let r = pT(e);
        this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer), r.buffer.on("update", this.onBufferUpdate, this), r.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = r;
      }
      addIndex(t) {
        this.indexBuffer = Jc(t, true), this.buffers.push(this.indexBuffer);
      }
      get bounds() {
        return this._boundsDirty ? (this._boundsDirty = false, pp(this, "aPosition", this._bounds)) : this._bounds;
      }
      destroy(t = false) {
        this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
      }
    };
  });
  var mT;
  var gT;
  var _n2;
  var gp = p(() => {
    qe2();
    Oe2();
    Kr2();
    mT = new Float32Array(1), gT = new Uint32Array(1), _n2 = class extends ae2 {
      constructor() {
        let e = new _t2({ data: mT, label: "attribute-batch-buffer", usage: K2.VERTEX | K2.COPY_DST, shrinkToFit: false }), r = new _t2({ data: gT, label: "index-batch-buffer", usage: K2.INDEX | K2.COPY_DST, shrinkToFit: false }), s = 6 * 4;
        super({ attributes: { aPosition: { buffer: e, format: "float32x2", stride: s, offset: 0 }, aUV: { buffer: e, format: "float32x2", stride: s, offset: 2 * 4 }, aColor: { buffer: e, format: "unorm8x4", stride: s, offset: 4 * 4 }, aTextureIdAndRound: { buffer: e, format: "uint16x2", stride: s, offset: 5 * 4 } }, indexBuffer: r });
      }
    };
  });
  function Le2(i3, t) {
    let e = xp[i3];
    return e === void 0 && (tl[t] === void 0 && (tl[t] = 1), xp[i3] = e = tl[t]++), e;
  }
  var tl;
  var xp;
  var as = p(() => {
    "use strict";
    tl = /* @__PURE__ */ Object.create(null), xp = /* @__PURE__ */ Object.create(null);
  });
  function _p() {
    if (!yn2) {
      yn2 = "mediump";
      let i3 = pn2();
      i3 && i3.getShaderPrecisionFormat && (yn2 = i3.getShaderPrecisionFormat(i3.FRAGMENT_SHADER, i3.HIGH_FLOAT).precision ? "highp" : "mediump");
    }
    return yn2;
  }
  var yn2;
  var yp = p(() => {
    $c();
  });
  function bp(i3, t, e) {
    return t ? i3 : e ? (i3 = i3.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i3}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i3}
        `;
  }
  var vp = p(() => {
    "use strict";
  });
  function Tp(i3, t, e) {
    let r = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
    if (i3.substring(0, 9) !== "precision") {
      let s = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
      return s === "highp" && r !== "highp" && (s = "mediump"), `precision ${s} float;
${i3}`;
    } else if (r !== "highp" && i3.substring(0, 15) === "precision highp") return i3.replace("precision highp", "precision mediump");
    return i3;
  }
  var Sp = p(() => {
    "use strict";
  });
  function wp(i3, t) {
    return t ? `#version 300 es
${i3}` : i3;
  }
  var Pp = p(() => {
    "use strict";
  });
  function Ap(i3, { name: t = "pixi-program" }, e = true) {
    t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
    let r = e ? xT : _T;
    return r[t] ? (r[t]++, t += `-${r[t]}`) : r[t] = 1, i3.indexOf("#define SHADER_NAME") !== -1 ? i3 : `${`#define SHADER_NAME ${t}`}
${i3}`;
  }
  var xT;
  var _T;
  var Cp = p(() => {
    "use strict";
    xT = {}, _T = {};
  });
  function Ep(i3, t) {
    return t ? i3.replace("#version 300 es", "") : i3;
  }
  var Mp = p(() => {
    "use strict";
  });
  var el;
  var rl;
  var Bp;
  var ce2;
  var wr2 = p(() => {
    as();
    yp();
    vp();
    Sp();
    Pp();
    Cp();
    Mp();
    el = { stripVersion: Ep, ensurePrecision: Tp, addProgramDefines: bp, setProgramName: Ap, insertVersion: wp }, rl = /* @__PURE__ */ Object.create(null), Bp = class il {
      constructor(t) {
        t = { ...il.defaultOptions, ...t };
        let e = t.fragment.indexOf("#version 300 es") !== -1, r = { stripVersion: e, ensurePrecision: { requestedFragmentPrecision: t.preferredFragmentPrecision, requestedVertexPrecision: t.preferredVertexPrecision, maxSupportedVertexPrecision: "highp", maxSupportedFragmentPrecision: _p() }, setProgramName: { name: t.name }, addProgramDefines: e, insertVersion: e }, s = t.fragment, o = t.vertex;
        Object.keys(el).forEach((n) => {
          let a = r[n];
          s = el[n](s, a, true), o = el[n](o, a, false);
        }), this.fragment = s, this.vertex = o, this.transformFeedbackVaryings = t.transformFeedbackVaryings, this._key = Le2(`${this.vertex}:${this.fragment}`, "gl-program");
      }
      destroy() {
        this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
      }
      static from(t) {
        let e = `${t.vertex}:${t.fragment}`;
        return rl[e] || (rl[e] = new il(t)), rl[e];
      }
    };
    Bp.defaultOptions = { preferredVertexPrecision: "highp", preferredFragmentPrecision: "mediump" };
    ce2 = Bp;
  });
  function Zt2(i3) {
    return Rp[i3] ?? Rp.float32;
  }
  var Rp;
  var Pr2 = p(() => {
    "use strict";
    Rp = { uint8x2: { size: 2, stride: 2, normalised: false }, uint8x4: { size: 4, stride: 4, normalised: false }, sint8x2: { size: 2, stride: 2, normalised: false }, sint8x4: { size: 4, stride: 4, normalised: false }, unorm8x2: { size: 2, stride: 2, normalised: true }, unorm8x4: { size: 4, stride: 4, normalised: true }, snorm8x2: { size: 2, stride: 2, normalised: true }, snorm8x4: { size: 4, stride: 4, normalised: true }, uint16x2: { size: 2, stride: 4, normalised: false }, uint16x4: { size: 4, stride: 8, normalised: false }, sint16x2: { size: 2, stride: 4, normalised: false }, sint16x4: { size: 4, stride: 8, normalised: false }, unorm16x2: { size: 2, stride: 4, normalised: true }, unorm16x4: { size: 4, stride: 8, normalised: true }, snorm16x2: { size: 2, stride: 4, normalised: true }, snorm16x4: { size: 4, stride: 8, normalised: true }, float16x2: { size: 2, stride: 4, normalised: false }, float16x4: { size: 4, stride: 8, normalised: false }, float32: { size: 1, stride: 4, normalised: false }, float32x2: { size: 2, stride: 8, normalised: false }, float32x3: { size: 3, stride: 12, normalised: false }, float32x4: { size: 4, stride: 16, normalised: false }, uint32: { size: 1, stride: 4, normalised: false }, uint32x2: { size: 2, stride: 8, normalised: false }, uint32x3: { size: 3, stride: 12, normalised: false }, uint32x4: { size: 4, stride: 16, normalised: false }, sint32: { size: 1, stride: 4, normalised: false }, sint32x2: { size: 2, stride: 8, normalised: false }, sint32x3: { size: 3, stride: 12, normalised: false }, sint32x4: { size: 4, stride: 16, normalised: false } };
  });
  function Gp({ source: i3, entryPoint: t }) {
    let e = {}, r = i3.indexOf(`fn ${t}`);
    if (r !== -1) {
      let s = i3.indexOf("->", r);
      if (s !== -1) {
        let o = i3.substring(r, s), n = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g, a;
        for (; (a = n.exec(o)) !== null; ) {
          let c = yT[a[3]] ?? "float32";
          e[a[2]] = { location: parseInt(a[1], 10), format: c, stride: Zt2(c).stride, offset: 0, instance: false, start: 0 };
        }
      }
    }
    return e;
  }
  var yT;
  var kp = p(() => {
    Pr2();
    yT = { f32: "float32", "vec2<f32>": "float32x2", "vec3<f32>": "float32x3", "vec4<f32>": "float32x4", vec2f: "float32x2", vec3f: "float32x3", vec4f: "float32x4", i32: "sint32", "vec2<i32>": "sint32x2", "vec3<i32>": "sint32x3", "vec4<i32>": "sint32x4", u32: "uint32", "vec2<u32>": "uint32x2", "vec3<u32>": "uint32x3", "vec4<u32>": "uint32x4", bool: "uint32", "vec2<bool>": "uint32x2", "vec3<bool>": "uint32x3", "vec4<bool>": "uint32x4" };
  });
  function bn2(i3) {
    let t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, r = /@binding\((\d+)\)/, s = /var(<[^>]+>)? (\w+)/, o = /:\s*(\w+)/, n = /struct\s+(\w+)\s*{([^}]+)}/g, a = /(\w+)\s*:\s*([\w\<\>]+)/g, c = /struct\s+(\w+)/, l = i3.match(t)?.map((u) => ({ group: parseInt(u.match(e)[1], 10), binding: parseInt(u.match(r)[1], 10), name: u.match(s)[2], isUniform: u.match(s)[1] === "<uniform>", type: u.match(o)[1] }));
    if (!l) return { groups: [], structs: [] };
    let h = i3.match(n)?.map((u) => {
      let f = u.match(c)[1], d2 = u.match(a).reduce((m, g) => {
        let [x2, b] = g.split(":");
        return m[x2.trim()] = b.trim(), m;
      }, {});
      return d2 ? { name: f, members: d2 } : null;
    }).filter(({ name: u }) => l.some((f) => f.type === u)) ?? [];
    return { groups: l, structs: h };
  }
  var Ip = p(() => {
    "use strict";
  });
  var qr2;
  var Fp = p(() => {
    "use strict";
    qr2 = ((i3) => (i3[i3.VERTEX = 1] = "VERTEX", i3[i3.FRAGMENT = 2] = "FRAGMENT", i3[i3.COMPUTE = 4] = "COMPUTE", i3))(qr2 || {});
  });
  function Up({ groups: i3 }) {
    let t = [];
    for (let e = 0; e < i3.length; e++) {
      let r = i3[e];
      t[r.group] || (t[r.group] = []), r.isUniform ? t[r.group].push({ binding: r.binding, visibility: qr2.VERTEX | qr2.FRAGMENT, buffer: { type: "uniform" } }) : r.type === "sampler" ? t[r.group].push({ binding: r.binding, visibility: qr2.FRAGMENT, sampler: { type: "filtering" } }) : r.type === "texture_2d" && t[r.group].push({ binding: r.binding, visibility: qr2.FRAGMENT, texture: { sampleType: "float", viewDimension: "2d", multisampled: false } });
    }
    return t;
  }
  var Dp = p(() => {
    Fp();
  });
  function Op({ groups: i3 }) {
    let t = [];
    for (let e = 0; e < i3.length; e++) {
      let r = i3[e];
      t[r.group] || (t[r.group] = {}), t[r.group][r.name] = r.binding;
    }
    return t;
  }
  var Lp = p(() => {
    "use strict";
  });
  function Np(i3, t) {
    let e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), s = [...i3.structs, ...t.structs].filter((n) => e.has(n.name) ? false : (e.add(n.name), true)), o = [...i3.groups, ...t.groups].filter((n) => {
      let a = `${n.name}-${n.binding}`;
      return r.has(a) ? false : (r.add(a), true);
    });
    return { structs: s, groups: o };
  }
  var Hp = p(() => {
    "use strict";
  });
  var sl;
  var le2;
  var Zr2 = p(() => {
    as();
    kp();
    Ip();
    Dp();
    Lp();
    Hp();
    sl = /* @__PURE__ */ Object.create(null), le2 = class i3 {
      constructor(t) {
        this._layoutKey = 0, this._attributeLocationsKey = 0;
        let { fragment: e, vertex: r, layout: s, gpuLayout: o, name: n } = t;
        if (this.name = n, this.fragment = e, this.vertex = r, e.source === r.source) {
          let a = bn2(e.source);
          this.structsAndGroups = a;
        } else {
          let a = bn2(r.source), c = bn2(e.source);
          this.structsAndGroups = Np(a, c);
        }
        this.layout = s ?? Op(this.structsAndGroups), this.gpuLayout = o ?? Up(this.structsAndGroups), this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0, this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0, this._generateProgramKey();
      }
      _generateProgramKey() {
        let { vertex: t, fragment: e } = this, r = t.source + e.source + t.entryPoint + e.entryPoint;
        this._layoutKey = Le2(r, "program");
      }
      get attributeData() {
        return this._attributeData ?? (this._attributeData = Gp(this.vertex)), this._attributeData;
      }
      destroy() {
        this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
      }
      static from(t) {
        let e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
        return sl[e] || (sl[e] = new i3(t)), sl[e];
      }
    };
  });
  function ol(i3, t, e) {
    if (i3) for (let r in i3) {
      let s = r.toLocaleLowerCase(), o = t[s];
      if (o) {
        let n = i3[r];
        r === "header" && (n = n.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && o.push(`//----${e}----//`), o.push(n);
      } else O2(`${r} placement hook does not exist in shader`);
    }
  }
  var Wp = p(() => {
    ot2();
  });
  function nl(i3) {
    let t = {};
    return (i3.match(bT)?.map((r) => r.replace(/[{()}]/g, "")) ?? []).forEach((r) => {
      t[r] = [];
    }), t;
  }
  var bT;
  var zp = p(() => {
    "use strict";
    bT = /\{\{(.*?)\}\}/g;
  });
  function Vp(i3, t) {
    let e, r = /@in\s+([^;]+);/g;
    for (; (e = r.exec(i3)) !== null; ) t.push(e[1]);
  }
  function al(i3, t, e = false) {
    let r = [];
    Vp(t, r), i3.forEach((a) => {
      a.header && Vp(a.header, r);
    });
    let s = r;
    e && s.sort();
    let o = s.map((a, c) => `       @location(${c}) ${a},`).join(`
`), n = t.replace(/@in\s+[^;]+;\s*/g, "");
    return n = n.replace("{{in}}", `
${o}
`), n;
  }
  var Xp = p(() => {
    "use strict";
  });
  function Yp(i3, t) {
    let e, r = /@out\s+([^;]+);/g;
    for (; (e = r.exec(i3)) !== null; ) t.push(e[1]);
  }
  function vT(i3) {
    let e = /\b(\w+)\s*:/g.exec(i3);
    return e ? e[1] : "";
  }
  function TT(i3) {
    let t = /@.*?\s+/g;
    return i3.replace(t, "");
  }
  function $p(i3, t) {
    let e = [];
    Yp(t, e), i3.forEach((c) => {
      c.header && Yp(c.header, e);
    });
    let r = 0, s = e.sort().map((c) => c.indexOf("builtin") > -1 ? c : `@location(${r++}) ${c}`).join(`,
`), o = e.sort().map((c) => `       var ${TT(c)};`).join(`
`), n = `return VSOutput(
            ${e.sort().map((c) => ` ${vT(c)}`).join(`,
`)});`, a = t.replace(/@out\s+[^;]+;\s*/g, "");
    return a = a.replace("{{struct}}", `
${s}
`), a = a.replace("{{start}}", `
${o}
`), a = a.replace("{{return}}", `
${n}
`), a;
  }
  var jp = p(() => {
    "use strict";
  });
  function cl(i3, t) {
    let e = i3;
    for (let r in t) {
      let s = t[r];
      s.join(`
`).length ? e = e.replace(`{{${r}}}`, `//-----${r} START-----//
${s.join(`
`)}
//----${r} FINISH----//`) : e = e.replace(`{{${r}}}`, "");
    }
    return e;
  }
  var Kp = p(() => {
    "use strict";
  });
  function qp({ template: i3, bits: t }) {
    let e = Qp(i3, t);
    if (Ze2[e]) return Ze2[e];
    let { vertex: r, fragment: s } = wT(i3, t);
    return Ze2[e] = Jp(r, s, t), Ze2[e];
  }
  function Zp({ template: i3, bits: t }) {
    let e = Qp(i3, t);
    return Ze2[e] || (Ze2[e] = Jp(i3.vertex, i3.fragment, t)), Ze2[e];
  }
  function wT(i3, t) {
    let e = t.map((n) => n.vertex).filter((n) => !!n), r = t.map((n) => n.fragment).filter((n) => !!n), s = al(e, i3.vertex, true);
    s = $p(e, s);
    let o = al(r, i3.fragment, true);
    return { vertex: s, fragment: o };
  }
  function Qp(i3, t) {
    return t.map((e) => (ll.has(e) || ll.set(e, ST++), ll.get(e))).sort((e, r) => e - r).join("-") + i3.vertex + i3.fragment;
  }
  function Jp(i3, t, e) {
    let r = nl(i3), s = nl(t);
    return e.forEach((o) => {
      ol(o.vertex, r, o.name), ol(o.fragment, s, o.name);
    }), { vertex: cl(i3, r), fragment: cl(t, s) };
  }
  var Ze2;
  var ll;
  var ST;
  var tm = p(() => {
    Wp();
    zp();
    Xp();
    jp();
    Kp();
    Ze2 = /* @__PURE__ */ Object.create(null), ll = /* @__PURE__ */ new Map(), ST = 0;
  });
  var em;
  var rm;
  var im;
  var sm;
  var om = p(() => {
    "use strict";
    em = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, rm = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, im = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, sm = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`;
  });
  var nm;
  var am;
  var cm = p(() => {
    "use strict";
    nm = { name: "global-uniforms-bit", vertex: { header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        ` } }, am = { name: "global-uniforms-bit", vertex: { header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        ` } };
  });
  function Te2({ bits: i3, name: t }) {
    let e = qp({ template: { fragment: rm, vertex: em }, bits: [nm, ...i3] });
    return le2.from({ name: t, vertex: { source: e.vertex, entryPoint: "main" }, fragment: { source: e.fragment, entryPoint: "main" } });
  }
  function Se2({ bits: i3, name: t }) {
    return new ce2({ name: t, ...Zp({ template: { vertex: im, fragment: sm }, bits: [am, ...i3] }) });
  }
  var Qe2 = p(() => {
    wr2();
    Zr2();
    tm();
    om();
    cm();
  });
  var Qr2;
  var Jr2;
  var cs = p(() => {
    "use strict";
    Qr2 = { name: "color-bit", vertex: { header: `
            @in aColor: vec4<f32>;
        `, main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        ` } }, Jr2 = { name: "color-bit", vertex: { header: `
            in vec4 aColor;
        `, main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        ` } };
  });
  function PT(i3) {
    let t = [];
    if (i3 === 1) t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let e = 0;
      for (let r = 0; r < i3; r++) t.push(`@group(1) @binding(${e++}) var textureSource${r + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${r + 1}: sampler;`);
    }
    return t.join(`
`);
  }
  function AT(i3) {
    let t = [];
    if (i3 === 1) t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
      t.push("switch vTextureId {");
      for (let e = 0; e < i3; e++) e === i3 - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
      t.push("}");
    }
    return t.join(`
`);
  }
  function ti2(i3) {
    return hl[i3] || (hl[i3] = { name: "texture-batch-bit", vertex: { header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `, main: `
                vTextureId = aTextureIdAndRound.y;
            `, end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            ` }, fragment: { header: `
                @in @interpolate(flat) vTextureId: u32;

                ${PT(i3)}
            `, main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${AT(i3)}
            ` } }), hl[i3];
  }
  function CT(i3) {
    let t = [];
    for (let e = 0; e < i3; e++) e > 0 && t.push("else"), e < i3 - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
    return t.join(`
`);
  }
  function ei2(i3) {
    return ul[i3] || (ul[i3] = { name: "texture-batch-bit", vertex: { header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `, main: `
                vTextureId = aTextureIdAndRound.y;
            `, end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            ` }, fragment: { header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i3}];

            `, main: `

                ${CT(i3)}
            ` } }), ul[i3];
  }
  var hl;
  var ul;
  var ls = p(() => {
    "use strict";
    hl = {};
    ul = {};
  });
  var we2;
  var Pe2;
  var Je2 = p(() => {
    "use strict";
    we2 = { name: "round-pixels-bit", vertex: { header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        ` } }, Pe2 = { name: "round-pixels-bit", vertex: { header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        ` } };
  });
  var dl;
  var lm;
  var hm = p(() => {
    "use strict";
    dl = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"], lm = dl.reduce((i3, t) => (i3[t] = true, i3), {});
  });
  function um(i3, t) {
    switch (i3) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * t);
      case "vec3<f32>":
        return new Float32Array(3 * t);
      case "vec4<f32>":
        return new Float32Array(4 * t);
      case "mat2x2<f32>":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3x3<f32>":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4x4<f32>":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    return null;
  }
  var dm = p(() => {
    "use strict";
  });
  var fm;
  var nt2;
  var zt2 = p(() => {
    It2();
    as();
    hm();
    dm();
    fm = class pm {
      constructor(t, e) {
        this._touched = 0, this.uid = q2("uniform"), this._resourceType = "uniformGroup", this._resourceId = q2("resource"), this.isUniformGroup = true, this._dirtyId = 0, this.destroyed = false, e = { ...pm.defaultOptions, ...e }, this.uniformStructures = t;
        let r = {};
        for (let s in t) {
          let o = t[s];
          if (o.name = s, o.size = o.size ?? 1, !lm[o.type]) throw new Error(`Uniform type ${o.type} is not supported. Supported uniform types are: ${dl.join(", ")}`);
          o.value ?? (o.value = um(o.type, o.size)), r[s] = o.value;
        }
        this.uniforms = r, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = Le2(Object.keys(r).map((s) => `${s}-${t[s].type}`).join("-"), "uniform-group");
      }
      update() {
        this._dirtyId++;
      }
    };
    fm.defaultOptions = { ubo: false, isStatic: false };
    nt2 = fm;
  });
  function ri(i3) {
    let t = mm[i3];
    if (t) return t;
    let e = new Int32Array(i3);
    for (let r = 0; r < i3; r++) e[r] = r;
    return t = mm[i3] = new nt2({ uTextures: { value: e, type: "i32", size: i3 } }, { isStatic: true }), t;
  }
  var mm;
  var vn2 = p(() => {
    zt2();
    mm = {};
  });
  var Tt2;
  var Ae2 = p(() => {
    "use strict";
    Tt2 = ((i3) => (i3[i3.WEBGL = 1] = "WEBGL", i3[i3.WEBGPU = 2] = "WEBGPU", i3[i3.BOTH = 3] = "BOTH", i3))(Tt2 || {});
  });
  var yt2;
  var me2 = p(() => {
    Dt2();
    It2();
    wr2();
    Ke2();
    Zr2();
    Ae2();
    zt2();
    yt2 = class i3 extends at2 {
      constructor(t) {
        super(), this.uid = q2("shader"), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
        let { gpuProgram: e, glProgram: r, groups: s, resources: o, compatibleRenderers: n, groupMap: a } = t;
        this.gpuProgram = e, this.glProgram = r, n === void 0 && (n = 0, e && (n |= Tt2.WEBGPU), r && (n |= Tt2.WEBGL)), this.compatibleRenderers = n;
        let c = {};
        if (!o && !s && (o = {}), o && s) throw new Error("[Shader] Cannot have both resources and groups");
        if (!e && s && !a) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        if (!e && s && a) for (let l in a) for (let h in a[l]) {
          let u = a[l][h];
          c[u] = { group: l, binding: h, name: u };
        }
        else if (e && s && !a) {
          let l = e.structsAndGroups.groups;
          a = {}, l.forEach((h) => {
            a[h.group] = a[h.group] || {}, a[h.group][h.binding] = h.name, c[h.name] = h;
          });
        } else if (o) {
          s = {}, a = {}, e && e.structsAndGroups.groups.forEach((u) => {
            a[u.group] = a[u.group] || {}, a[u.group][u.binding] = u.name, c[u.name] = u;
          });
          let l = 0;
          for (let h in o) c[h] || (s[99] || (s[99] = new Mt2(), this._ownedBindGroups.push(s[99])), c[h] = { group: 99, binding: l, name: h }, a[99] = a[99] || {}, a[99][l] = h, l++);
          for (let h in o) {
            let u = h, f = o[h];
            !f.source && !f._resourceType && (f = new nt2(f));
            let d2 = c[u];
            d2 && (s[d2.group] || (s[d2.group] = new Mt2(), this._ownedBindGroups.push(s[d2.group])), s[d2.group].setResource(f, d2.binding));
          }
        }
        this.groups = s, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(s, c);
      }
      addResource(t, e, r) {
        var s, o;
        (s = this._uniformBindMap)[e] || (s[e] = {}), (o = this._uniformBindMap[e])[r] || (o[r] = t), this.groups[e] || (this.groups[e] = new Mt2(), this._ownedBindGroups.push(this.groups[e]));
      }
      _buildResourceAccessor(t, e) {
        let r = {};
        for (let s in e) {
          let o = e[s];
          Object.defineProperty(r, o.name, { get() {
            return t[o.group].getResource(o.binding);
          }, set(n) {
            t[o.group].setResource(n, o.binding);
          } });
        }
        return r;
      }
      destroy(t = false) {
        this.emit("destroy", this), t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((e) => {
          e.destroy();
        }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
      }
      static from(t) {
        let { gpu: e, gl: r, ...s } = t, o, n;
        return e && (o = le2.from(e)), r && (n = ce2.from(r)), new i3({ gpuProgram: o, glProgram: n, ...s });
      }
    };
  });
  var Tn2;
  var gm = p(() => {
    Qe2();
    cs();
    ls();
    Je2();
    vn2();
    me2();
    Tn2 = class extends yt2 {
      constructor(t) {
        let e = Se2({ name: "batch", bits: [Jr2, ei2(t), Pe2] }), r = Te2({ name: "batch", bits: [Qr2, ti2(t), we2] });
        super({ glProgram: e, gpuProgram: r, resources: { batchSamplers: ri(t) } });
      }
    };
  });
  var xm;
  var _m;
  var hs;
  var fl2 = p(() => {
    E();
    dp();
    gp();
    gm();
    xm = null, _m = class ym extends up {
      constructor() {
        super(...arguments), this.geometry = new _n2(), this.shader = xm || (xm = new Tn2(this.maxTextures)), this.name = ym.extension.name, this.vertexSize = 6;
      }
      packAttributes(t, e, r, s, o) {
        let n = o << 16 | t.roundPixels & 65535, a = t.transform, c = a.a, l = a.b, h = a.c, u = a.d, f = a.tx, d2 = a.ty, { positions: m, uvs: g } = t, x2 = t.color, b = t.attributeOffset, y = b + t.attributeSize;
        for (let v = b; v < y; v++) {
          let T2 = v * 2, P = m[T2], w = m[T2 + 1];
          e[s++] = c * P + h * w + f, e[s++] = u * w + l * P + d2, e[s++] = g[T2], e[s++] = g[T2 + 1], r[s++] = x2, r[s++] = n;
        }
      }
      packQuadAttributes(t, e, r, s, o) {
        let n = t.texture, a = t.transform, c = a.a, l = a.b, h = a.c, u = a.d, f = a.tx, d2 = a.ty, m = t.bounds, g = m.maxX, x2 = m.minX, b = m.maxY, y = m.minY, v = n.uvs, T2 = t.color, P = o << 16 | t.roundPixels & 65535;
        e[s + 0] = c * x2 + h * y + f, e[s + 1] = u * y + l * x2 + d2, e[s + 2] = v.x0, e[s + 3] = v.y0, r[s + 4] = T2, r[s + 5] = P, e[s + 6] = c * g + h * y + f, e[s + 7] = u * y + l * g + d2, e[s + 8] = v.x1, e[s + 9] = v.y1, r[s + 10] = T2, r[s + 11] = P, e[s + 12] = c * g + h * b + f, e[s + 13] = u * b + l * g + d2, e[s + 14] = v.x2, e[s + 15] = v.y2, r[s + 16] = T2, r[s + 17] = P, e[s + 18] = c * x2 + h * b + f, e[s + 19] = u * b + l * x2 + d2, e[s + 20] = v.x3, e[s + 21] = v.y3, r[s + 22] = T2, r[s + 23] = P;
      }
    };
    _m.extension = { type: [_2.Batcher], name: "default" };
    hs = _m;
  });
  function bm(i3, t, e, r, s, o, n, a = null) {
    let c = 0;
    e *= t, s *= o;
    let l = a.a, h = a.b, u = a.c, f = a.d, d2 = a.tx, m = a.ty;
    for (; c < n; ) {
      let g = i3[e], x2 = i3[e + 1];
      r[s] = l * g + u * x2 + d2, r[s + 1] = h * g + f * x2 + m, s += o, e += t, c++;
    }
  }
  function vm(i3, t, e, r) {
    let s = 0;
    for (t *= e; s < r; ) i3[t] = 0, i3[t + 1] = 0, t += e, s++;
  }
  var Tm = p(() => {
    "use strict";
  });
  function pl(i3, t, e, r, s) {
    let o = t.a, n = t.b, a = t.c, c = t.d, l = t.tx, h = t.ty;
    e || (e = 0), r || (r = 2), s || (s = i3.length / r - e);
    let u = e * r;
    for (let f = 0; f < s; f++) {
      let d2 = i3[u], m = i3[u + 1];
      i3[u] = o * d2 + a * m + l, i3[u + 1] = n * d2 + c * m + h, u += r;
    }
  }
  var Sm = p(() => {
    "use strict";
  });
  var ET;
  var Ar2;
  var ml = p(() => {
    Q2();
    cc();
    ET = new I(), Ar2 = class {
      constructor() {
        this.packAsQuad = false, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = true, this.roundPixels = 0, this._batcher = null, this._batch = null;
      }
      get uvs() {
        return this.geometryData.uvs;
      }
      get positions() {
        return this.geometryData.vertices;
      }
      get indices() {
        return this.geometryData.indices;
      }
      get blendMode() {
        return this.applyTransform ? this.renderable.groupBlendMode : "normal";
      }
      get color() {
        let t = this.baseColor, e = t >> 16 | t & 65280 | (t & 255) << 16, r = this.renderable;
        return r ? zo(e, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : e + (this.alpha * 255 << 24);
      }
      get transform() {
        return this.renderable?.groupTransform || ET;
      }
      copyTo(t) {
        t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData, t.topology = this.topology;
      }
      reset() {
        this.applyTransform = true, this.renderable = null, this.topology = "triangle-list";
      }
    };
  });
  var ii;
  var wm;
  var Pm;
  var Am = p(() => {
    E();
    ii = { extension: { type: _2.ShapeBuilder, name: "circle" }, build(i3, t) {
      let e, r, s, o, n, a;
      if (i3.type === "circle") {
        let T2 = i3;
        e = T2.x, r = T2.y, n = a = T2.radius, s = o = 0;
      } else if (i3.type === "ellipse") {
        let T2 = i3;
        e = T2.x, r = T2.y, n = T2.halfWidth, a = T2.halfHeight, s = o = 0;
      } else {
        let T2 = i3, P = T2.width / 2, w = T2.height / 2;
        e = T2.x + P, r = T2.y + w, n = a = Math.max(0, Math.min(T2.radius, Math.min(P, w))), s = P - n, o = w - a;
      }
      if (!(n >= 0 && a >= 0 && s >= 0 && o >= 0)) return t;
      let c = Math.ceil(2.3 * Math.sqrt(n + a)), l = c * 8 + (s ? 4 : 0) + (o ? 4 : 0);
      if (l === 0) return t;
      if (c === 0) return t[0] = t[6] = e + s, t[1] = t[3] = r + o, t[2] = t[4] = e - s, t[5] = t[7] = r - o, t;
      let h = 0, u = c * 4 + (s ? 2 : 0) + 2, f = u, d2 = l, m = s + n, g = o, x2 = e + m, b = e - m, y = r + g;
      if (t[h++] = x2, t[h++] = y, t[--u] = y, t[--u] = b, o) {
        let T2 = r - g;
        t[f++] = b, t[f++] = T2, t[--d2] = T2, t[--d2] = x2;
      }
      for (let T2 = 1; T2 < c; T2++) {
        let P = Math.PI / 2 * (T2 / c), w = s + Math.cos(P) * n, C = o + Math.sin(P) * a, G2 = e + w, M2 = e - w, S2 = r + C, A2 = r - C;
        t[h++] = G2, t[h++] = S2, t[--u] = S2, t[--u] = M2, t[f++] = M2, t[f++] = A2, t[--d2] = A2, t[--d2] = G2;
      }
      m = s, g = o + a, x2 = e + m, b = e - m, y = r + g;
      let v = r - g;
      return t[h++] = x2, t[h++] = y, t[--d2] = v, t[--d2] = x2, s && (t[h++] = b, t[h++] = y, t[--d2] = v, t[--d2] = b), t;
    }, triangulate(i3, t, e, r, s, o) {
      if (i3.length === 0) return;
      let n = 0, a = 0;
      for (let h = 0; h < i3.length; h += 2) n += i3[h], a += i3[h + 1];
      n /= i3.length / 2, a /= i3.length / 2;
      let c = r;
      t[c * e] = n, t[c * e + 1] = a;
      let l = c++;
      for (let h = 0; h < i3.length; h += 2) t[c * e] = i3[h], t[c * e + 1] = i3[h + 1], h > 0 && (s[o++] = c, s[o++] = l, s[o++] = c - 1), c++;
      s[o++] = l + 1, s[o++] = l, s[o++] = c - 1;
    } }, wm = { ...ii, extension: { ...ii.extension, name: "ellipse" } }, Pm = { ...ii, extension: { ...ii.extension, name: "roundedRectangle" } };
  });
  function Cm(i3) {
    let t = i3.length;
    if (t < 6) return 1;
    let e = 0;
    for (let r = 0, s = i3[t - 2], o = i3[t - 1]; r < t; r += 2) {
      let n = i3[r], a = i3[r + 1];
      e += (n - s) * (a + o), s = n, o = a;
    }
    return e < 0 ? -1 : 1;
  }
  var Em = p(() => {
    "use strict";
  });
  function Mm(i3, t, e, r, s, o, n, a) {
    let c = i3 - e * s, l = t - r * s, h = i3 + e * o, u = t + r * o, f, d2;
    n ? (f = r, d2 = -e) : (f = -r, d2 = e);
    let m = c + f, g = l + d2, x2 = h + f, b = u + d2;
    return a.push(m, g), a.push(x2, b), 2;
  }
  function Cr2(i3, t, e, r, s, o, n, a) {
    let c = e - i3, l = r - t, h = Math.atan2(c, l), u = Math.atan2(s - i3, o - t);
    a && h < u ? h += Math.PI * 2 : !a && h > u && (u += Math.PI * 2);
    let f = h, d2 = u - h, m = Math.abs(d2), g = Math.sqrt(c * c + l * l), x2 = (15 * m * Math.sqrt(g) / Math.PI >> 0) + 1, b = d2 / x2;
    if (f += b, a) {
      n.push(i3, t), n.push(e, r);
      for (let y = 1, v = f; y < x2; y++, v += b) n.push(i3, t), n.push(i3 + Math.sin(v) * g, t + Math.cos(v) * g);
      n.push(i3, t), n.push(s, o);
    } else {
      n.push(e, r), n.push(i3, t);
      for (let y = 1, v = f; y < x2; y++, v += b) n.push(i3 + Math.sin(v) * g, t + Math.cos(v) * g), n.push(i3, t);
      n.push(s, o), n.push(i3, t);
    }
    return x2 * 2;
  }
  function Bm(i3, t, e, r, s, o) {
    let n = 1e-4;
    if (i3.length === 0) return;
    let a = t, c = a.alignment;
    if (t.alignment !== 0.5) {
      let j2 = Cm(i3);
      e && (j2 *= -1), c = (c - 0.5) * j2 + 0.5;
    }
    let l = new Z2(i3[0], i3[1]), h = new Z2(i3[i3.length - 2], i3[i3.length - 1]), u = r, f = Math.abs(l.x - h.x) < n && Math.abs(l.y - h.y) < n;
    if (u) {
      i3 = i3.slice(), f && (i3.pop(), i3.pop(), h.set(i3[i3.length - 2], i3[i3.length - 1]));
      let j2 = (l.x + h.x) * 0.5, xt2 = (h.y + l.y) * 0.5;
      i3.unshift(j2, xt2), i3.push(j2, xt2);
    }
    let d2 = s, m = i3.length / 2, g = i3.length, x2 = d2.length / 2, b = a.width / 2, y = b * b, v = a.miterLimit * a.miterLimit, T2 = i3[0], P = i3[1], w = i3[2], C = i3[3], G2 = 0, M2 = 0, S2 = -(P - C), A2 = T2 - w, R2 = 0, F2 = 0, W2 = Math.sqrt(S2 * S2 + A2 * A2);
    S2 /= W2, A2 /= W2, S2 *= b, A2 *= b;
    let X = c, D = (1 - X) * 2, k2 = X * 2;
    u || (a.cap === "round" ? g += Cr2(T2 - S2 * (D - k2) * 0.5, P - A2 * (D - k2) * 0.5, T2 - S2 * D, P - A2 * D, T2 + S2 * k2, P + A2 * k2, d2, true) + 2 : a.cap === "square" && (g += Mm(T2, P, S2, A2, D, k2, true, d2))), d2.push(T2 - S2 * D, P - A2 * D), d2.push(T2 + S2 * k2, P + A2 * k2);
    for (let j2 = 1; j2 < m - 1; ++j2) {
      T2 = i3[(j2 - 1) * 2], P = i3[(j2 - 1) * 2 + 1], w = i3[j2 * 2], C = i3[j2 * 2 + 1], G2 = i3[(j2 + 1) * 2], M2 = i3[(j2 + 1) * 2 + 1], S2 = -(P - C), A2 = T2 - w, W2 = Math.sqrt(S2 * S2 + A2 * A2), S2 /= W2, A2 /= W2, S2 *= b, A2 *= b, R2 = -(C - M2), F2 = w - G2, W2 = Math.sqrt(R2 * R2 + F2 * F2), R2 /= W2, F2 /= W2, R2 *= b, F2 *= b;
      let xt2 = w - T2, te2 = P - C, nr2 = w - G2, ar2 = M2 - C, Wu = xt2 * nr2 + te2 * ar2, Ro = te2 * nr2 - ar2 * xt2, Ui = Ro < 0;
      if (Math.abs(Ro) < 1e-3 * Math.abs(Wu)) {
        d2.push(w - S2 * D, C - A2 * D), d2.push(w + S2 * k2, C + A2 * k2), Wu >= 0 && (a.join === "round" ? g += Cr2(w, C, w - S2 * D, C - A2 * D, w - R2 * D, C - F2 * D, d2, false) + 4 : g += 2, d2.push(w - R2 * k2, C - F2 * k2), d2.push(w + R2 * D, C + F2 * D));
        continue;
      }
      let zu = (-S2 + T2) * (-A2 + C) - (-S2 + w) * (-A2 + P), Vu = (-R2 + G2) * (-F2 + C) - (-R2 + w) * (-F2 + M2), Go = (xt2 * Vu - nr2 * zu) / Ro, ko = (ar2 * zu - te2 * Vu) / Ro, Xa = (Go - w) * (Go - w) + (ko - C) * (ko - C), cr2 = w + (Go - w) * D, lr2 = C + (ko - C) * D, hr2 = w - (Go - w) * k2, ur2 = C - (ko - C) * k2, T0 = Math.min(xt2 * xt2 + te2 * te2, nr2 * nr2 + ar2 * ar2), Xu = Ui ? D : k2, S0 = T0 + Xu * Xu * y;
      Xa <= S0 ? a.join === "bevel" || Xa / y > v ? (Ui ? (d2.push(cr2, lr2), d2.push(w + S2 * k2, C + A2 * k2), d2.push(cr2, lr2), d2.push(w + R2 * k2, C + F2 * k2)) : (d2.push(w - S2 * D, C - A2 * D), d2.push(hr2, ur2), d2.push(w - R2 * D, C - F2 * D), d2.push(hr2, ur2)), g += 2) : a.join === "round" ? Ui ? (d2.push(cr2, lr2), d2.push(w + S2 * k2, C + A2 * k2), g += Cr2(w, C, w + S2 * k2, C + A2 * k2, w + R2 * k2, C + F2 * k2, d2, true) + 4, d2.push(cr2, lr2), d2.push(w + R2 * k2, C + F2 * k2)) : (d2.push(w - S2 * D, C - A2 * D), d2.push(hr2, ur2), g += Cr2(w, C, w - S2 * D, C - A2 * D, w - R2 * D, C - F2 * D, d2, false) + 4, d2.push(w - R2 * D, C - F2 * D), d2.push(hr2, ur2)) : (d2.push(cr2, lr2), d2.push(hr2, ur2)) : (d2.push(w - S2 * D, C - A2 * D), d2.push(w + S2 * k2, C + A2 * k2), a.join === "round" ? Ui ? g += Cr2(w, C, w + S2 * k2, C + A2 * k2, w + R2 * k2, C + F2 * k2, d2, true) + 2 : g += Cr2(w, C, w - S2 * D, C - A2 * D, w - R2 * D, C - F2 * D, d2, false) + 2 : a.join === "miter" && Xa / y <= v && (Ui ? (d2.push(hr2, ur2), d2.push(hr2, ur2)) : (d2.push(cr2, lr2), d2.push(cr2, lr2)), g += 2), d2.push(w - R2 * D, C - F2 * D), d2.push(w + R2 * k2, C + F2 * k2), g += 2);
    }
    T2 = i3[(m - 2) * 2], P = i3[(m - 2) * 2 + 1], w = i3[(m - 1) * 2], C = i3[(m - 1) * 2 + 1], S2 = -(P - C), A2 = T2 - w, W2 = Math.sqrt(S2 * S2 + A2 * A2), S2 /= W2, A2 /= W2, S2 *= b, A2 *= b, d2.push(w - S2 * D, C - A2 * D), d2.push(w + S2 * k2, C + A2 * k2), u || (a.cap === "round" ? g += Cr2(w - S2 * (D - k2) * 0.5, C - A2 * (D - k2) * 0.5, w - S2 * D, C - A2 * D, w + S2 * k2, C + A2 * k2, d2, false) + 2 : a.cap === "square" && (g += Mm(w, C, S2, A2, D, k2, false, d2)));
    let gt2 = 1e-4 * 1e-4;
    for (let j2 = x2; j2 < g + x2 - 2; ++j2) T2 = d2[j2 * 2], P = d2[j2 * 2 + 1], w = d2[(j2 + 1) * 2], C = d2[(j2 + 1) * 2 + 1], G2 = d2[(j2 + 2) * 2], M2 = d2[(j2 + 2) * 2 + 1], !(Math.abs(T2 * (C - M2) + w * (M2 - P) + G2 * (P - C)) < gt2) && o.push(j2, j2 + 1, j2 + 2);
  }
  var Rm = p(() => {
    oe2();
    Em();
  });
  function Gm(i3, t, e, r) {
    let s = 1e-4;
    if (i3.length === 0) return;
    let o = i3[0], n = i3[1], a = i3[i3.length - 2], c = i3[i3.length - 1], l = t || Math.abs(o - a) < s && Math.abs(n - c) < s, h = e, u = i3.length / 2, f = h.length / 2;
    for (let d2 = 0; d2 < u; d2++) h.push(i3[d2 * 2]), h.push(i3[d2 * 2 + 1]);
    for (let d2 = 0; d2 < u - 1; d2++) r.push(f + d2, f + d2 + 1);
    l && r.push(f + u - 1, f);
  }
  var km = p(() => {
  });
  var bl = $a((n2, yl) => {
    "use strict";
    yl.exports = Pn2;
    yl.exports.default = Pn2;
    function Pn2(i3, t, e) {
      e = e || 2;
      var r = t && t.length, s = r ? t[0] * e : i3.length, o = Fm(i3, 0, s, e, true), n = [];
      if (!o || o.next === o.prev) return n;
      var a, c, l, h, u, f, d2;
      if (r && (o = FT(i3, t, o, e)), i3.length > 80 * e) {
        a = l = i3[0], c = h = i3[1];
        for (var m = e; m < s; m += e) u = i3[m], f = i3[m + 1], u < a && (a = u), f < c && (c = f), u > l && (l = u), f > h && (h = f);
        d2 = Math.max(l - a, h - c), d2 = d2 !== 0 ? 32767 / d2 : 0;
      }
      return us(o, n, e, a, c, d2, 0), n;
    }
    function Fm(i3, t, e, r, s) {
      var o, n;
      if (s === _l(i3, t, e, r) > 0) for (o = t; o < e; o += r) n = Im(o, i3[o], i3[o + 1], n);
      else for (o = e - r; o >= t; o -= r) n = Im(o, i3[o], i3[o + 1], n);
      return n && An2(n, n.next) && (fs(n), n = n.next), n;
    }
    function Er2(i3, t) {
      if (!i3) return i3;
      t || (t = i3);
      var e = i3, r;
      do
        if (r = false, !e.steiner && (An2(e, e.next) || mt2(e.prev, e, e.next) === 0)) {
          if (fs(e), e = t = e.prev, e === e.next) break;
          r = true;
        } else e = e.next;
      while (r || e !== t);
      return t;
    }
    function us(i3, t, e, r, s, o, n) {
      if (i3) {
        !n && o && NT(i3, r, s, o);
        for (var a = i3, c, l; i3.prev !== i3.next; ) {
          if (c = i3.prev, l = i3.next, o ? GT(i3, r, s, o) : RT(i3)) {
            t.push(c.i / e | 0), t.push(i3.i / e | 0), t.push(l.i / e | 0), fs(i3), i3 = l.next, a = l.next;
            continue;
          }
          if (i3 = l, i3 === a) {
            n ? n === 1 ? (i3 = kT(Er2(i3), t, e), us(i3, t, e, r, s, o, 2)) : n === 2 && IT(i3, t, e, r, s, o) : us(Er2(i3), t, e, r, s, o, 1);
            break;
          }
        }
      }
    }
    function RT(i3) {
      var t = i3.prev, e = i3, r = i3.next;
      if (mt2(t, e, r) >= 0) return false;
      for (var s = t.x, o = e.x, n = r.x, a = t.y, c = e.y, l = r.y, h = s < o ? s < n ? s : n : o < n ? o : n, u = a < c ? a < l ? a : l : c < l ? c : l, f = s > o ? s > n ? s : n : o > n ? o : n, d2 = a > c ? a > l ? a : l : c > l ? c : l, m = r.next; m !== t; ) {
        if (m.x >= h && m.x <= f && m.y >= u && m.y <= d2 && si(s, a, o, c, n, l, m.x, m.y) && mt2(m.prev, m, m.next) >= 0) return false;
        m = m.next;
      }
      return true;
    }
    function GT(i3, t, e, r) {
      var s = i3.prev, o = i3, n = i3.next;
      if (mt2(s, o, n) >= 0) return false;
      for (var a = s.x, c = o.x, l = n.x, h = s.y, u = o.y, f = n.y, d2 = a < c ? a < l ? a : l : c < l ? c : l, m = h < u ? h < f ? h : f : u < f ? u : f, g = a > c ? a > l ? a : l : c > l ? c : l, x2 = h > u ? h > f ? h : f : u > f ? u : f, b = gl(d2, m, t, e, r), y = gl(g, x2, t, e, r), v = i3.prevZ, T2 = i3.nextZ; v && v.z >= b && T2 && T2.z <= y; ) {
        if (v.x >= d2 && v.x <= g && v.y >= m && v.y <= x2 && v !== s && v !== n && si(a, h, c, u, l, f, v.x, v.y) && mt2(v.prev, v, v.next) >= 0 || (v = v.prevZ, T2.x >= d2 && T2.x <= g && T2.y >= m && T2.y <= x2 && T2 !== s && T2 !== n && si(a, h, c, u, l, f, T2.x, T2.y) && mt2(T2.prev, T2, T2.next) >= 0)) return false;
        T2 = T2.nextZ;
      }
      for (; v && v.z >= b; ) {
        if (v.x >= d2 && v.x <= g && v.y >= m && v.y <= x2 && v !== s && v !== n && si(a, h, c, u, l, f, v.x, v.y) && mt2(v.prev, v, v.next) >= 0) return false;
        v = v.prevZ;
      }
      for (; T2 && T2.z <= y; ) {
        if (T2.x >= d2 && T2.x <= g && T2.y >= m && T2.y <= x2 && T2 !== s && T2 !== n && si(a, h, c, u, l, f, T2.x, T2.y) && mt2(T2.prev, T2, T2.next) >= 0) return false;
        T2 = T2.nextZ;
      }
      return true;
    }
    function kT(i3, t, e) {
      var r = i3;
      do {
        var s = r.prev, o = r.next.next;
        !An2(s, o) && Um(s, r, r.next, o) && ds(s, o) && ds(o, s) && (t.push(s.i / e | 0), t.push(r.i / e | 0), t.push(o.i / e | 0), fs(r), fs(r.next), r = i3 = o), r = r.next;
      } while (r !== i3);
      return Er2(r);
    }
    function IT(i3, t, e, r, s, o) {
      var n = i3;
      do {
        for (var a = n.next.next; a !== n.prev; ) {
          if (n.i !== a.i && zT(n, a)) {
            var c = Dm(n, a);
            n = Er2(n, n.next), c = Er2(c, c.next), us(n, t, e, r, s, o, 0), us(c, t, e, r, s, o, 0);
            return;
          }
          a = a.next;
        }
        n = n.next;
      } while (n !== i3);
    }
    function FT(i3, t, e, r) {
      var s = [], o, n, a, c, l;
      for (o = 0, n = t.length; o < n; o++) a = t[o] * r, c = o < n - 1 ? t[o + 1] * r : i3.length, l = Fm(i3, a, c, r, false), l === l.next && (l.steiner = true), s.push(WT(l));
      for (s.sort(UT), o = 0; o < s.length; o++) e = DT(s[o], e);
      return e;
    }
    function UT(i3, t) {
      return i3.x - t.x;
    }
    function DT(i3, t) {
      var e = OT(i3, t);
      if (!e) return t;
      var r = Dm(e, i3);
      return Er2(r, r.next), Er2(e, e.next);
    }
    function OT(i3, t) {
      var e = t, r = i3.x, s = i3.y, o = -1 / 0, n;
      do {
        if (s <= e.y && s >= e.next.y && e.next.y !== e.y) {
          var a = e.x + (s - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
          if (a <= r && a > o && (o = a, n = e.x < e.next.x ? e : e.next, a === r)) return n;
        }
        e = e.next;
      } while (e !== t);
      if (!n) return null;
      var c = n, l = n.x, h = n.y, u = 1 / 0, f;
      e = n;
      do
        r >= e.x && e.x >= l && r !== e.x && si(s < h ? r : o, s, l, h, s < h ? o : r, s, e.x, e.y) && (f = Math.abs(s - e.y) / (r - e.x), ds(e, i3) && (f < u || f === u && (e.x > n.x || e.x === n.x && LT(n, e))) && (n = e, u = f)), e = e.next;
      while (e !== c);
      return n;
    }
    function LT(i3, t) {
      return mt2(i3.prev, i3, t.prev) < 0 && mt2(t.next, i3, i3.next) < 0;
    }
    function NT(i3, t, e, r) {
      var s = i3;
      do
        s.z === 0 && (s.z = gl(s.x, s.y, t, e, r)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
      while (s !== i3);
      s.prevZ.nextZ = null, s.prevZ = null, HT(s);
    }
    function HT(i3) {
      var t, e, r, s, o, n, a, c, l = 1;
      do {
        for (e = i3, i3 = null, o = null, n = 0; e; ) {
          for (n++, r = e, a = 0, t = 0; t < l && (a++, r = r.nextZ, !!r); t++) ;
          for (c = l; a > 0 || c > 0 && r; ) a !== 0 && (c === 0 || !r || e.z <= r.z) ? (s = e, e = e.nextZ, a--) : (s = r, r = r.nextZ, c--), o ? o.nextZ = s : i3 = s, s.prevZ = o, o = s;
          e = r;
        }
        o.nextZ = null, l *= 2;
      } while (n > 1);
      return i3;
    }
    function gl(i3, t, e, r, s) {
      return i3 = (i3 - e) * s | 0, t = (t - r) * s | 0, i3 = (i3 | i3 << 8) & 16711935, i3 = (i3 | i3 << 4) & 252645135, i3 = (i3 | i3 << 2) & 858993459, i3 = (i3 | i3 << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i3 | t << 1;
    }
    function WT(i3) {
      var t = i3, e = i3;
      do
        (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
      while (t !== i3);
      return e;
    }
    function si(i3, t, e, r, s, o, n, a) {
      return (s - n) * (t - a) >= (i3 - n) * (o - a) && (i3 - n) * (r - a) >= (e - n) * (t - a) && (e - n) * (o - a) >= (s - n) * (r - a);
    }
    function zT(i3, t) {
      return i3.next.i !== t.i && i3.prev.i !== t.i && !VT(i3, t) && (ds(i3, t) && ds(t, i3) && XT(i3, t) && (mt2(i3.prev, i3, t.prev) || mt2(i3, t.prev, t)) || An2(i3, t) && mt2(i3.prev, i3, i3.next) > 0 && mt2(t.prev, t, t.next) > 0);
    }
    function mt2(i3, t, e) {
      return (t.y - i3.y) * (e.x - t.x) - (t.x - i3.x) * (e.y - t.y);
    }
    function An2(i3, t) {
      return i3.x === t.x && i3.y === t.y;
    }
    function Um(i3, t, e, r) {
      var s = wn2(mt2(i3, t, e)), o = wn2(mt2(i3, t, r)), n = wn2(mt2(e, r, i3)), a = wn2(mt2(e, r, t));
      return !!(s !== o && n !== a || s === 0 && Sn2(i3, e, t) || o === 0 && Sn2(i3, r, t) || n === 0 && Sn2(e, i3, r) || a === 0 && Sn2(e, t, r));
    }
    function Sn2(i3, t, e) {
      return t.x <= Math.max(i3.x, e.x) && t.x >= Math.min(i3.x, e.x) && t.y <= Math.max(i3.y, e.y) && t.y >= Math.min(i3.y, e.y);
    }
    function wn2(i3) {
      return i3 > 0 ? 1 : i3 < 0 ? -1 : 0;
    }
    function VT(i3, t) {
      var e = i3;
      do {
        if (e.i !== i3.i && e.next.i !== i3.i && e.i !== t.i && e.next.i !== t.i && Um(e, e.next, i3, t)) return true;
        e = e.next;
      } while (e !== i3);
      return false;
    }
    function ds(i3, t) {
      return mt2(i3.prev, i3, i3.next) < 0 ? mt2(i3, t, i3.next) >= 0 && mt2(i3, i3.prev, t) >= 0 : mt2(i3, t, i3.prev) < 0 || mt2(i3, i3.next, t) < 0;
    }
    function XT(i3, t) {
      var e = i3, r = false, s = (i3.x + t.x) / 2, o = (i3.y + t.y) / 2;
      do
        e.y > o != e.next.y > o && e.next.y !== e.y && s < (e.next.x - e.x) * (o - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;
      while (e !== i3);
      return r;
    }
    function Dm(i3, t) {
      var e = new xl(i3.i, i3.x, i3.y), r = new xl(t.i, t.x, t.y), s = i3.next, o = t.prev;
      return i3.next = t, t.prev = i3, e.next = s, s.prev = e, r.next = e, e.prev = r, o.next = r, r.prev = o, r;
    }
    function Im(i3, t, e, r) {
      var s = new xl(i3, t, e);
      return r ? (s.next = r.next, s.prev = r, r.next.prev = s, r.next = s) : (s.prev = s, s.next = s), s;
    }
    function fs(i3) {
      i3.next.prev = i3.prev, i3.prev.next = i3.next, i3.prevZ && (i3.prevZ.nextZ = i3.nextZ), i3.nextZ && (i3.nextZ.prevZ = i3.prevZ);
    }
    function xl(i3, t, e) {
      this.i = i3, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    Pn2.deviation = function(i3, t, e, r) {
      var s = t && t.length, o = s ? t[0] * e : i3.length, n = Math.abs(_l(i3, 0, o, e));
      if (s) for (var a = 0, c = t.length; a < c; a++) {
        var l = t[a] * e, h = a < c - 1 ? t[a + 1] * e : i3.length;
        n -= Math.abs(_l(i3, l, h, e));
      }
      var u = 0;
      for (a = 0; a < r.length; a += 3) {
        var f = r[a] * e, d2 = r[a + 1] * e, m = r[a + 2] * e;
        u += Math.abs((i3[f] - i3[m]) * (i3[d2 + 1] - i3[f + 1]) - (i3[f] - i3[d2]) * (i3[m + 1] - i3[f + 1]));
      }
      return n === 0 && u === 0 ? 0 : Math.abs((u - n) / n);
    };
    function _l(i3, t, e, r) {
      for (var s = 0, o = t, n = e - r; o < e; o += r) s += (i3[n] - i3[o]) * (i3[o + 1] + i3[n + 1]), n = o;
      return s;
    }
    Pn2.flatten = function(i3) {
      for (var t = i3[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, s = 0; s < i3.length; s++) {
        for (var o = 0; o < i3[s].length; o++) for (var n = 0; n < t; n++) e.vertices.push(i3[s][o][n]);
        s > 0 && (r += i3[s - 1].length, e.holes.push(r));
      }
      return e;
    };
  });
  function Cn2(i3, t, e, r, s, o, n) {
    let a = (0, Om.default)(i3, t, 2);
    if (!a) return;
    for (let l = 0; l < a.length; l += 3) o[n++] = a[l] + s, o[n++] = a[l + 1] + s, o[n++] = a[l + 2] + s;
    let c = s * r;
    for (let l = 0; l < i3.length; l += 2) e[c] = i3[l], e[c + 1] = i3[l + 1], c += r;
  }
  var Om;
  var vl = p(() => {
    Om = Io(bl(), 1);
  });
  var YT;
  var Lm;
  var Nm = p(() => {
    E();
    vl();
    YT = [], Lm = { extension: { type: _2.ShapeBuilder, name: "polygon" }, build(i3, t) {
      for (let e = 0; e < i3.points.length; e++) t[e] = i3.points[e];
      return t;
    }, triangulate(i3, t, e, r, s, o) {
      Cn2(i3, YT, t, e, r, s, o);
    } };
  });
  var Hm;
  var Wm = p(() => {
    E();
    Hm = { extension: { type: _2.ShapeBuilder, name: "rectangle" }, build(i3, t) {
      let e = i3, r = e.x, s = e.y, o = e.width, n = e.height;
      return o >= 0 && n >= 0 && (t[0] = r, t[1] = s, t[2] = r + o, t[3] = s, t[4] = r + o, t[5] = s + n, t[6] = r, t[7] = s + n), t;
    }, triangulate(i3, t, e, r, s, o) {
      let n = 0;
      r *= e, t[r + n] = i3[0], t[r + n + 1] = i3[1], n += e, t[r + n] = i3[2], t[r + n + 1] = i3[3], n += e, t[r + n] = i3[6], t[r + n + 1] = i3[7], n += e, t[r + n] = i3[4], t[r + n + 1] = i3[5], n += e;
      let a = r / e;
      s[o++] = a, s[o++] = a + 1, s[o++] = a + 2, s[o++] = a + 1, s[o++] = a + 3, s[o++] = a + 2;
    } };
  });
  var zm;
  var Vm = p(() => {
    E();
    zm = { extension: { type: _2.ShapeBuilder, name: "triangle" }, build(i3, t) {
      return t[0] = i3.x, t[1] = i3.y, t[2] = i3.x2, t[3] = i3.y2, t[4] = i3.x3, t[5] = i3.y3, t;
    }, triangulate(i3, t, e, r, s, o) {
      let n = 0;
      r *= e, t[r + n] = i3[0], t[r + n + 1] = i3[1], n += e, t[r + n] = i3[2], t[r + n + 1] = i3[3], n += e, t[r + n] = i3[4], t[r + n + 1] = i3[5];
      let a = r / e;
      s[o++] = a, s[o++] = a + 1, s[o++] = a + 2;
    } };
  });
  function Ym(i3, t) {
    for (let e = 0; e < t.length; e++) {
      let r = t[e];
      i3.addColorStop(r.offset, r.color);
    }
  }
  function $m(i3, t) {
    let e = N.get().createCanvas(i3, t), r = e.getContext("2d");
    return { canvas: e, context: r };
  }
  function $T(i3) {
    let t = i3[0] ?? {};
    return (typeof t == "number" || i3[1]) && (L2("8.5.2", "use options object instead"), t = { type: "linear", start: { x: i3[0], y: i3[1] }, end: { x: i3[2], y: i3[3] }, textureSpace: i3[4], textureSize: i3[5] ?? Qt2.defaultLinearOptions.textureSize }), t;
  }
  var Xm;
  var Sl;
  var Qt2;
  var oi = p(() => {
    Gt2();
    lt2();
    Q2();
    Xr2();
    rt2();
    It2();
    ft2();
    pc();
    Xm = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }], Sl = class Tl {
      constructor(...t) {
        this.uid = q2("fillGradient"), this.type = "linear", this.colorStops = [];
        let e = $T(t);
        e = { ...e.type === "radial" ? Tl.defaultRadialOptions : Tl.defaultLinearOptions, ...Xo(e) }, this._textureSize = e.textureSize, this._wrapMode = e.wrapMode, e.type === "radial" ? (this.center = e.center, this.outerCenter = e.outerCenter ?? this.center, this.innerRadius = e.innerRadius, this.outerRadius = e.outerRadius, this.scale = e.scale, this.rotation = e.rotation) : (this.start = e.start, this.end = e.end), this.textureSpace = e.textureSpace, this.type = e.type, e.colorStops.forEach((s) => {
          this.addColorStop(s.offset, s.color);
        });
      }
      addColorStop(t, e) {
        return this.colorStops.push({ offset: t, color: $.shared.setValue(e).toHexa() }), this;
      }
      buildLinearGradient() {
        if (this.texture) return;
        let { x: t, y: e } = this.start, { x: r, y: s } = this.end, o = r - t, n = s - e, a = o < 0 || n < 0;
        if (this._wrapMode === "clamp-to-edge") {
          if (o < 0) {
            let x2 = t;
            t = r, r = x2, o *= -1;
          }
          if (n < 0) {
            let x2 = e;
            e = s, s = x2, n *= -1;
          }
        }
        let c = this.colorStops.length ? this.colorStops : Xm, l = this._textureSize, { canvas: h, context: u } = $m(l, 1), f = a ? u.createLinearGradient(this._textureSize, 0, 0, 0) : u.createLinearGradient(0, 0, this._textureSize, 0);
        Ym(f, c), u.fillStyle = f, u.fillRect(0, 0, l, 1), this.texture = new B({ source: new qt2({ resource: h, addressMode: this._wrapMode }) });
        let d2 = Math.sqrt(o * o + n * n), m = Math.atan2(n, o), g = new I();
        g.scale(d2 / l, 1), g.rotate(m), g.translate(t, e), this.textureSpace === "local" && g.scale(l, l), this.transform = g;
      }
      buildGradient() {
        this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
      }
      buildRadialGradient() {
        if (this.texture) return;
        let t = this.colorStops.length ? this.colorStops : Xm, e = this._textureSize, { canvas: r, context: s } = $m(e, e), { x: o, y: n } = this.center, { x: a, y: c } = this.outerCenter, l = this.innerRadius, h = this.outerRadius, u = a - h, f = c - h, d2 = e / (h * 2), m = (o - u) * d2, g = (n - f) * d2, x2 = s.createRadialGradient(m, g, l * d2, (a - u) * d2, (c - f) * d2, h * d2);
        Ym(x2, t), s.fillStyle = t[t.length - 1].color, s.fillRect(0, 0, e, e), s.fillStyle = x2, s.translate(m, g), s.rotate(this.rotation), s.scale(1, this.scale), s.translate(-m, -g), s.fillRect(0, 0, e, e), this.texture = new B({ source: new qt2({ resource: r, addressMode: this._wrapMode }) });
        let b = new I();
        b.scale(1 / d2, 1 / d2), b.translate(u, f), this.textureSpace === "local" && b.scale(e, e), this.transform = b;
      }
      get styleKey() {
        return this.uid;
      }
      destroy() {
        this.texture?.destroy(true), this.texture = null;
      }
    };
    Sl.defaultLinearOptions = { start: { x: 0, y: 0 }, end: { x: 0, y: 1 }, colorStops: [], textureSpace: "local", type: "linear", textureSize: 256, wrapMode: "clamp-to-edge" };
    Sl.defaultRadialOptions = { center: { x: 0.5, y: 0.5 }, innerRadius: 0, outerRadius: 0.5, colorStops: [], scale: 1, textureSpace: "local", type: "radial", textureSize: 256, wrapMode: "clamp-to-edge" };
    Qt2 = Sl;
  });
  function jm(i3, t, e, r) {
    let s = t.matrix ? i3.copyFrom(t.matrix).invert() : i3.identity();
    if (t.textureSpace === "local") {
      let n = e.getBounds(KT);
      t.width && n.pad(t.width);
      let { x: a, y: c } = n, l = 1 / n.width, h = 1 / n.height, u = -a * l, f = -c * h, d2 = s.a, m = s.b, g = s.c, x2 = s.d;
      s.a *= l, s.b *= l, s.c *= h, s.d *= h, s.tx = u * d2 + f * g + s.tx, s.ty = u * m + f * x2 + s.ty;
    } else s.translate(t.texture.frame.x, t.texture.frame.y), s.scale(1 / t.texture.source.width, 1 / t.texture.source.height);
    let o = t.texture.source.style;
    return !(t.fill instanceof Qt2) && o.addressMode === "clamp-to-edge" && (o.addressMode = "repeat", o.update()), r && s.append(jT.copyFrom(r).invert()), s;
  }
  var jT;
  var KT;
  var Km = p(() => {
    Q2();
    St2();
    oi();
    jT = new I(), KT = new Y2();
  });
  function Zm(i3, t) {
    let { geometryData: e, batches: r } = t;
    r.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
    for (let s = 0; s < i3.instructions.length; s++) {
      let o = i3.instructions[s];
      if (o.action === "texture") QT(o.data, r, e);
      else if (o.action === "fill" || o.action === "stroke") {
        let n = o.action === "stroke", a = o.data.path.shapePath, c = o.data.style, l = o.data.hole;
        n && l && qm(l.shapePath, c, true, r, e), l && (a.shapePrimitives[a.shapePrimitives.length - 1].holes = l.shapePath.shapePrimitives), qm(a, c, n, r, e);
      }
    }
  }
  function QT(i3, t, e) {
    let { vertices: r, uvs: s, indices: o } = e, n = o.length, a = r.length / 2, c = [], l = En2.rectangle, h = qT, u = i3.image;
    h.x = i3.dx, h.y = i3.dy, h.width = i3.dw, h.height = i3.dh;
    let f = i3.transform;
    l.build(h, c), f && pl(c, f), l.triangulate(c, r, 2, a, o, n);
    let d2 = u.uvs;
    s.push(d2.x0, d2.y0, d2.x1, d2.y1, d2.x3, d2.y3, d2.x2, d2.y2);
    let m = V2.get(Ar2);
    m.indexOffset = n, m.indexSize = o.length - n, m.attributeOffset = a, m.attributeSize = r.length / 2 - a, m.baseColor = i3.style, m.alpha = i3.alpha, m.texture = u, m.geometryData = e, t.push(m);
  }
  function qm(i3, t, e, r, s) {
    let { vertices: o, uvs: n, indices: a } = s;
    i3.shapePrimitives.forEach(({ shape: c, transform: l, holes: h }) => {
      let u = a.length, f = o.length / 2, d2 = [], m = En2[c.type], g = "triangle-list";
      if (m.build(c, d2), l && pl(d2, l), e) {
        let v = c.closePath ?? true, T2 = t;
        T2.pixelLine ? (Gm(d2, v, o, a), g = "line-list") : Bm(d2, T2, false, v, o, a);
      } else if (h) {
        let v = [], T2 = d2.slice();
        JT(h).forEach((w) => {
          v.push(T2.length / 2), T2.push(...w);
        }), Cn2(T2, v, o, 2, f, a, u);
      } else m.triangulate(d2, o, 2, f, a, u);
      let x2 = n.length / 2, b = t.texture;
      if (b !== B.WHITE) {
        let v = jm(ZT, t, c, l);
        bm(o, 2, f, n, x2, 2, o.length / 2 - f, v);
      } else vm(n, x2, 2, o.length / 2 - f);
      let y = V2.get(Ar2);
      y.indexOffset = u, y.indexSize = a.length - u, y.attributeOffset = f, y.attributeSize = o.length / 2 - f, y.baseColor = t.color, y.alpha = t.alpha, y.texture = b, y.geometryData = s, y.topology = g, r.push(y);
    });
  }
  function JT(i3) {
    let t = [];
    for (let e = 0; e < i3.length; e++) {
      let r = i3[e].shape, s = [];
      En2[r.type].build(r, s), t.push(s);
    }
    return t;
  }
  var En2;
  var qT;
  var ZT;
  var Qm = p(() => {
    E();
    Q2();
    St2();
    Tm();
    Sm();
    rt2();
    Nt2();
    ml();
    Am();
    Rm();
    km();
    Nm();
    Wm();
    Vm();
    Km();
    vl();
    En2 = {};
    U2.handleByMap(_2.ShapeBuilder, En2);
    U2.add(Hm, Lm, zm, ii, wm, Pm);
    qT = new Y2(), ZT = new I();
  });
  var wl;
  var Pl;
  var Cl;
  var ni;
  var Mn2 = p(() => {
    E();
    mn2();
    fl2();
    dc();
    ft2();
    Nt2();
    Qm();
    wl = class {
      constructor() {
        this.batches = [], this.geometryData = { vertices: [], uvs: [], indices: [] };
      }
    }, Pl = class {
      constructor() {
        this.batcher = new hs(), this.instructions = new Or2();
      }
      init() {
        this.instructions.reset();
      }
      get geometry() {
        return L2(gd, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
      }
    }, Cl = class Al {
      constructor(t) {
        this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
      }
      init(t) {
        Al.defaultOptions.bezierSmoothness = t?.bezierSmoothness ?? Al.defaultOptions.bezierSmoothness;
      }
      getContextRenderData(t) {
        return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
      }
      updateGpuContext(t) {
        let e = this._gpuContextHash[t.uid] || this._initContext(t);
        if (t.dirty) {
          e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), Zm(t, e);
          let r = t.batchMode;
          t.customShader || r === "no-batch" ? e.isBatchable = false : r === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = false;
        }
        return e;
      }
      getGpuContext(t) {
        return this._gpuContextHash[t.uid] || this._initContext(t);
      }
      _initContextRenderData(t) {
        let e = V2.get(Pl), { batches: r, geometryData: s } = this._gpuContextHash[t.uid], o = s.vertices.length, n = s.indices.length;
        for (let h = 0; h < r.length; h++) r[h].applyTransform = false;
        let a = e.batcher;
        a.ensureAttributeBuffer(o), a.ensureIndexBuffer(n), a.begin();
        for (let h = 0; h < r.length; h++) {
          let u = r[h];
          a.add(u);
        }
        a.finish(e.instructions);
        let c = a.geometry;
        c.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, true), c.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, true);
        let l = a.batches;
        for (let h = 0; h < l.length; h++) {
          let u = l[h];
          u.bindGroup = jr2(u.textures.textures, u.textures.count);
        }
        return this._graphicsDataContextHash[t.uid] = e, e;
      }
      _initContext(t) {
        let e = new wl();
        return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
      }
      onGraphicsContextDestroy(t) {
        this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
      }
      _cleanGraphicsContextData(t) {
        let e = this._gpuContextHash[t.uid];
        e.isBatchable || this._graphicsDataContextHash[t.uid] && (V2.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((r) => {
          V2.return(r);
        });
      }
      destroy() {
        for (let t in this._gpuContextHash) this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
      }
    };
    Cl.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "graphicsContext" };
    Cl.defaultOptions = { bezierSmoothness: 0.5 };
    ni = Cl;
  });
  var tS;
  var El;
  var Ml;
  var Bl;
  var Rl;
  var Gl;
  var kl;
  var Il;
  var bt2;
  var ge2 = p(() => {
    "use strict";
    tS = { normal: 0, add: 1, multiply: 2, screen: 3, overlay: 4, erase: 5, "normal-npm": 6, "add-npm": 7, "screen-npm": 8, min: 9, max: 10 }, El = 0, Ml = 1, Bl = 2, Rl = 3, Gl = 4, kl = 5, Il = class Jm {
      constructor() {
        this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = true, this.depthMask = true;
      }
      get blend() {
        return !!(this.data & 1 << El);
      }
      set blend(t) {
        !!(this.data & 1 << El) !== t && (this.data ^= 1 << El);
      }
      get offsets() {
        return !!(this.data & 1 << Ml);
      }
      set offsets(t) {
        !!(this.data & 1 << Ml) !== t && (this.data ^= 1 << Ml);
      }
      set cullMode(t) {
        if (t === "none") {
          this.culling = false;
          return;
        }
        this.culling = true, this.clockwiseFrontFace = t === "front";
      }
      get cullMode() {
        return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
      }
      get culling() {
        return !!(this.data & 1 << Bl);
      }
      set culling(t) {
        !!(this.data & 1 << Bl) !== t && (this.data ^= 1 << Bl);
      }
      get depthTest() {
        return !!(this.data & 1 << Rl);
      }
      set depthTest(t) {
        !!(this.data & 1 << Rl) !== t && (this.data ^= 1 << Rl);
      }
      get depthMask() {
        return !!(this.data & 1 << kl);
      }
      set depthMask(t) {
        !!(this.data & 1 << kl) !== t && (this.data ^= 1 << kl);
      }
      get clockwiseFrontFace() {
        return !!(this.data & 1 << Gl);
      }
      set clockwiseFrontFace(t) {
        !!(this.data & 1 << Gl) !== t && (this.data ^= 1 << Gl);
      }
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(t) {
        this.blend = t !== "none", this._blendMode = t, this._blendModeId = tS[t] || 0;
      }
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(t) {
        this.offsets = !!t, this._polygonOffset = t;
      }
      toString() {
        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      static for2d() {
        let t = new Jm();
        return t.depthTest = false, t.blend = true, t;
      }
    };
    Il.default2d = Il.for2d();
    bt2 = Il;
  });
  function Ce2(i3, t, e) {
    let r = (i3 >> 24 & 255) / 255;
    t[e++] = (i3 & 255) / 255 * r, t[e++] = (i3 >> 8 & 255) / 255 * r, t[e++] = (i3 >> 16 & 255) / 255 * r, t[e++] = r;
  }
  var ai = p(() => {
    "use strict";
  });
  var ps;
  var tg = p(() => {
    E();
    ge2();
    Nt2();
    ai();
    ml();
    ps = class {
      constructor(t, e) {
        this.state = bt2.for2d(), this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.renderer = t, this._adaptor = e, this._adaptor.init(), this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash");
      }
      validateRenderable(t) {
        let e = t.context, r = !!this._graphicsBatchesHash[t.uid], s = this.renderer.graphicsContext.updateGpuContext(e);
        return !!(s.isBatchable || r !== s.isBatchable);
      }
      addRenderable(t, e) {
        let r = this.renderer.graphicsContext.updateGpuContext(t.context);
        t.didViewUpdate && this._rebuild(t), r.isBatchable ? this._addToBatcher(t, e) : (this.renderer.renderPipes.batch.break(e), e.add(t));
      }
      updateRenderable(t) {
        let e = this._graphicsBatchesHash[t.uid];
        if (e) for (let r = 0; r < e.length; r++) {
          let s = e[r];
          s._batcher.updateElement(s);
        }
      }
      destroyRenderable(t) {
        this._graphicsBatchesHash[t.uid] && this._removeBatchForRenderable(t.uid), t.off("destroyed", this._destroyRenderableBound);
      }
      execute(t) {
        if (!t.isRenderable) return;
        let e = this.renderer, r = t.context;
        if (!e.graphicsContext.getGpuContext(r).batches.length) return;
        let o = r.customShader || this._adaptor.shader;
        this.state.blendMode = t.groupBlendMode;
        let n = o.resources.localUniforms.uniforms;
        n.uTransformMatrix = t.groupTransform, n.uRound = e._roundPixels | t._roundPixels, Ce2(t.groupColorAlpha, n.uColor, 0), this._adaptor.execute(this, t);
      }
      _rebuild(t) {
        let e = !!this._graphicsBatchesHash[t.uid], r = this.renderer.graphicsContext.updateGpuContext(t.context);
        e && this._removeBatchForRenderable(t.uid), r.isBatchable && this._initBatchesForRenderable(t), t.batched = r.isBatchable;
      }
      _addToBatcher(t, e) {
        let r = this.renderer.renderPipes.batch, s = this._getBatchesForRenderable(t);
        for (let o = 0; o < s.length; o++) {
          let n = s[o];
          r.addToBatch(n, e);
        }
      }
      _getBatchesForRenderable(t) {
        return this._graphicsBatchesHash[t.uid] || this._initBatchesForRenderable(t);
      }
      _initBatchesForRenderable(t) {
        let e = t.context, r = this.renderer.graphicsContext.getGpuContext(e), s = this.renderer._roundPixels | t._roundPixels, o = r.batches.map((n) => {
          let a = V2.get(Ar2);
          return n.copyTo(a), a.renderable = t, a.roundPixels = s, a;
        });
        return this._graphicsBatchesHash[t.uid] === void 0 && t.on("destroyed", this._destroyRenderableBound), this._graphicsBatchesHash[t.uid] = o, o;
      }
      _removeBatchForRenderable(t) {
        this._graphicsBatchesHash[t].forEach((e) => {
          V2.return(e);
        }), this._graphicsBatchesHash[t] = null;
      }
      destroy() {
        this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null;
        for (let t in this._graphicsBatchesHash) this._removeBatchForRenderable(t);
        this._graphicsBatchesHash = null;
      }
    };
    ps.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "graphics" };
  });
  var Fl = p(() => {
    E();
    Mn2();
    tg();
    U2.add(ps);
    U2.add(ni);
  });
  var tr2;
  var Bn2 = p(() => {
    "use strict";
    tr2 = class {
      constructor() {
        this.batcherName = "default", this.packAsQuad = false, this.indexOffset = 0, this.attributeOffset = 0, this.roundPixels = 0, this._batcher = null, this._batch = null, this._textureMatrixUpdateId = -1, this._uvUpdateId = -1;
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get topology() {
        return this._topology || this.geometry.topology;
      }
      set topology(t) {
        this._topology = t;
      }
      reset() {
        this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.geometry = null, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1;
      }
      setTexture(t) {
        this.texture !== t && (this.texture = t, this._textureMatrixUpdateId = -1);
      }
      get uvs() {
        let e = this.geometry.getBuffer("aUV"), r = e.data, s = r, o = this.texture.textureMatrix;
        return o.isSimple || (s = this._transformedUvs, (this._textureMatrixUpdateId !== o._updateID || this._uvUpdateId !== e._updateID) && ((!s || s.length < r.length) && (s = this._transformedUvs = new Float32Array(r.length)), this._textureMatrixUpdateId = o._updateID, this._uvUpdateId = e._updateID, o.multiplyUvs(r, s))), s;
      }
      get positions() {
        return this.geometry.positions;
      }
      get indices() {
        return this.geometry.indices;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      get groupTransform() {
        return this.renderable.groupTransform;
      }
      get attributeSize() {
        return this.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.geometry.indices.length;
      }
    };
  });
  var ms;
  var eg = p(() => {
    E();
    Q2();
    Ke2();
    zt2();
    os();
    Nt2();
    ai();
    Bn2();
    ms = class {
      constructor(t, e) {
        this.localUniforms = new nt2({ uTransformMatrix: { value: new I(), type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), this.localUniformsBindGroup = new Mt2({ 0: this.localUniforms }), this._meshDataHash = /* @__PURE__ */ Object.create(null), this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.renderer = t, this._adaptor = e, this._adaptor.init(), t.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash"), t.renderableGC.addManagedHash(this, "_meshDataHash");
      }
      validateRenderable(t) {
        let e = this._getMeshData(t), r = e.batched, s = t.batched;
        if (e.batched = s, r !== s) return true;
        if (s) {
          let o = t._geometry;
          if (o.indices.length !== e.indexSize || o.positions.length !== e.vertexSize) return e.indexSize = o.indices.length, e.vertexSize = o.positions.length, true;
          let n = this._getBatchableMesh(t);
          return n.texture.uid !== t._texture.uid && (n._textureMatrixUpdateId = -1), !n._batcher.checkAndUpdateTexture(n, t._texture);
        }
        return false;
      }
      addRenderable(t, e) {
        let r = this.renderer.renderPipes.batch, { batched: s } = this._getMeshData(t);
        if (s) {
          let o = this._getBatchableMesh(t);
          o.setTexture(t._texture), o.geometry = t._geometry, r.addToBatch(o, e);
        } else r.break(e), e.add(t);
      }
      updateRenderable(t) {
        if (t.batched) {
          let e = this._gpuBatchableMeshHash[t.uid];
          e.setTexture(t._texture), e.geometry = t._geometry, e._batcher.updateElement(e);
        }
      }
      destroyRenderable(t) {
        this._meshDataHash[t.uid] = null;
        let e = this._gpuBatchableMeshHash[t.uid];
        e && (V2.return(e), this._gpuBatchableMeshHash[t.uid] = null), t.off("destroyed", this._destroyRenderableBound);
      }
      execute(t) {
        if (!t.isRenderable) return;
        t.state.blendMode = De2(t.groupBlendMode, t.texture._source);
        let e = this.localUniforms;
        e.uniforms.uTransformMatrix = t.groupTransform, e.uniforms.uRound = this.renderer._roundPixels | t._roundPixels, e.update(), Ce2(t.groupColorAlpha, e.uniforms.uColor, 0), this._adaptor.execute(this, t);
      }
      _getMeshData(t) {
        return this._meshDataHash[t.uid] || this._initMeshData(t);
      }
      _initMeshData(t) {
        return this._meshDataHash[t.uid] = { batched: t.batched, indexSize: t._geometry.indices?.length, vertexSize: t._geometry.positions?.length }, t.on("destroyed", this._destroyRenderableBound), this._meshDataHash[t.uid];
      }
      _getBatchableMesh(t) {
        return this._gpuBatchableMeshHash[t.uid] || this._initBatchableMesh(t);
      }
      _initBatchableMesh(t) {
        let e = V2.get(tr2);
        return e.renderable = t, e.setTexture(t._texture), e.transform = t.groupTransform, e.roundPixels = this.renderer._roundPixels | t._roundPixels, this._gpuBatchableMeshHash[t.uid] = e, e;
      }
      destroy() {
        for (let t in this._gpuBatchableMeshHash) this._gpuBatchableMeshHash[t] && V2.return(this._gpuBatchableMeshHash[t]);
        this._gpuBatchableMeshHash = null, this._meshDataHash = null, this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null;
      }
    };
    ms.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "mesh" };
  });
  var Ul = p(() => {
    E();
    eg();
    U2.add(ms);
  });
  var Rn2;
  var rg = p(() => {
    "use strict";
    Rn2 = class {
      execute(t, e) {
        let r = t.state, s = t.renderer, o = e.shader || t.defaultShader;
        o.resources.uTexture = e.texture._source, o.resources.uniforms = t.localUniforms;
        let n = s.gl, a = t.getBuffers(e);
        s.shader.bind(o), s.state.set(r), s.geometry.bind(a.geometry, o.glProgram);
        let l = a.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
        n.drawElements(n.TRIANGLES, e.particleChildren.length * 6, l, 0);
      }
    };
  });
  function Dl(i3, t = null) {
    let e = i3 * 6;
    if (e > 65535 ? t || (t = new Uint32Array(e)) : t || (t = new Uint16Array(e)), t.length !== e) throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${e}`);
    for (let r = 0, s = 0; r < e; r += 6, s += 4) t[r + 0] = s + 0, t[r + 1] = s + 1, t[r + 2] = s + 2, t[r + 3] = s + 0, t[r + 4] = s + 2, t[r + 5] = s + 3;
    return t;
  }
  var ig = p(() => {
    "use strict";
  });
  function og(i3) {
    return { dynamicUpdate: sg(i3, true), staticUpdate: sg(i3, false) };
  }
  function sg(i3, t) {
    let e = [];
    e.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let r = 0;
    for (let o in i3) {
      let n = i3[o];
      if (t !== n.dynamic) continue;
      e.push(`offset = index + ${r}`), e.push(n.code);
      let a = Zt2(n.format);
      r += a.stride / 4;
    }
    e.push(`
            index += stride * 4;
        }
    `), e.unshift(`
        var stride = ${r};
    `);
    let s = e.join(`
`);
    return new Function("ps", "f32v", "u32v", s);
  }
  var ng = p(() => {
    Pr2();
  });
  function eS(i3) {
    let t = [];
    for (let e in i3) {
      let r = i3[e];
      t.push(e, r.code, r.dynamic ? "d" : "s");
    }
    return t.join("_");
  }
  var Gn2;
  var ag = p(() => {
    qe2();
    Oe2();
    Kr2();
    Pr2();
    Kc();
    ig();
    ng();
    Gn2 = class {
      constructor(t) {
        this._size = 0, this._generateParticleUpdateCache = {};
        let e = this._size = t.size ?? 1e3, r = t.properties, s = 0, o = 0;
        for (let h in r) {
          let u = r[h], f = Zt2(u.format);
          u.dynamic ? o += f.stride : s += f.stride;
        }
        this._dynamicStride = o / 4, this._staticStride = s / 4, this.staticAttributeBuffer = new ve2(e * 4 * s), this.dynamicAttributeBuffer = new ve2(e * 4 * o), this.indexBuffer = Dl(e);
        let n = new ae2(), a = 0, c = 0;
        this._staticBuffer = new _t2({ data: new Float32Array(1), label: "static-particle-buffer", shrinkToFit: false, usage: K2.VERTEX | K2.COPY_DST }), this._dynamicBuffer = new _t2({ data: new Float32Array(1), label: "dynamic-particle-buffer", shrinkToFit: false, usage: K2.VERTEX | K2.COPY_DST });
        for (let h in r) {
          let u = r[h], f = Zt2(u.format);
          u.dynamic ? (n.addAttribute(u.attributeName, { buffer: this._dynamicBuffer, stride: this._dynamicStride * 4, offset: a * 4, format: u.format }), a += f.size) : (n.addAttribute(u.attributeName, { buffer: this._staticBuffer, stride: this._staticStride * 4, offset: c * 4, format: u.format }), c += f.size);
        }
        n.addIndex(this.indexBuffer);
        let l = this.getParticleUpdate(r);
        this._dynamicUpload = l.dynamicUpdate, this._staticUpload = l.staticUpdate, this.geometry = n;
      }
      getParticleUpdate(t) {
        let e = eS(t);
        return this._generateParticleUpdateCache[e] ? this._generateParticleUpdateCache[e] : (this._generateParticleUpdateCache[e] = this.generateParticleUpdate(t), this._generateParticleUpdateCache[e]);
      }
      generateParticleUpdate(t) {
        return og(t);
      }
      update(t, e) {
        t.length > this._size && (e = true, this._size = Math.max(t.length, this._size * 1.5 | 0), this.staticAttributeBuffer = new ve2(this._size * this._staticStride * 4 * 4), this.dynamicAttributeBuffer = new ve2(this._size * this._dynamicStride * 4 * 4), this.indexBuffer = Dl(this._size), this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, true));
        let r = this.dynamicAttributeBuffer;
        if (this._dynamicUpload(t, r.float32View, r.uint32View), this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, t.length * this._dynamicStride * 4, true), e) {
          let s = this.staticAttributeBuffer;
          this._staticUpload(t, s.float32View, s.uint32View), this._staticBuffer.setDataWithSize(s.float32View, t.length * this._staticStride * 4, true);
        }
      }
      destroy() {
        this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy();
      }
    };
  });
  var cg;
  var lg = p(() => {
    cg = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`;
  });
  var hg;
  var ug = p(() => {
    hg = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`;
  });
  var Ol;
  var dg = p(() => {
    Ol = `
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;
  });
  var kn2;
  var fg = p(() => {
    Gt2();
    Q2();
    wr2();
    Zr2();
    me2();
    rt2();
    mc();
    lg();
    ug();
    dg();
    kn2 = class extends yt2 {
      constructor() {
        let t = ce2.from({ vertex: hg, fragment: cg }), e = le2.from({ fragment: { source: Ol, entryPoint: "mainFragment" }, vertex: { source: Ol, entryPoint: "mainVertex" } });
        super({ glProgram: t, gpuProgram: e, resources: { uTexture: B.WHITE.source, uSampler: new Yo({}), uniforms: { uTranslationMatrix: { value: new I(), type: "mat3x3<f32>" }, uColor: { value: new $(16777215), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } } } });
      }
    };
  });
  var ci;
  var Ll = p(() => {
    Q2();
    zt2();
    os();
    ge2();
    ai();
    ag();
    fg();
    ci = class {
      constructor(t, e) {
        this.state = bt2.for2d(), this._gpuBufferHash = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.localUniforms = new nt2({ uTranslationMatrix: { value: new I(), type: "mat3x3<f32>" }, uColor: { value: new Float32Array(4), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }), this.renderer = t, this.adaptor = e, this.defaultShader = new kn2(), this.state = bt2.for2d();
      }
      validateRenderable(t) {
        return false;
      }
      addRenderable(t, e) {
        this.renderer.renderPipes.batch.break(e), e.add(t);
      }
      getBuffers(t) {
        return this._gpuBufferHash[t.uid] || this._initBuffer(t);
      }
      _initBuffer(t) {
        return this._gpuBufferHash[t.uid] = new Gn2({ size: t.particleChildren.length, properties: t._properties }), t.on("destroyed", this._destroyRenderableBound), this._gpuBufferHash[t.uid];
      }
      updateRenderable(t) {
      }
      destroyRenderable(t) {
        this._gpuBufferHash[t.uid].destroy(), this._gpuBufferHash[t.uid] = null, t.off("destroyed", this._destroyRenderableBound);
      }
      execute(t) {
        let e = t.particleChildren;
        if (e.length === 0) return;
        let r = this.renderer, s = this.getBuffers(t);
        t.texture || (t.texture = e[0].texture);
        let o = this.state;
        s.update(e, t._childrenDirty), t._childrenDirty = false, o.blendMode = De2(t.blendMode, t.texture._source);
        let n = this.localUniforms.uniforms, a = n.uTranslationMatrix;
        t.worldTransform.copyTo(a), a.prepend(r.globalUniforms.globalUniformData.projectionMatrix), n.uResolution = r.globalUniforms.globalUniformData.resolution, n.uRound = r._roundPixels | t._roundPixels, Ce2(t.groupColorAlpha, n.uColor, 0), this.adaptor.execute(this, t);
      }
      destroy() {
        this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null);
      }
    };
  });
  var gs;
  var pg = p(() => {
    E();
    rg();
    Ll();
    gs = class extends ci {
      constructor(t) {
        super(t, new Rn2());
      }
    };
    gs.extension = { type: [_2.WebGLPipes], name: "particle" };
  });
  var In2;
  var mg = p(() => {
    "use strict";
    In2 = class {
      execute(t, e) {
        let r = t.renderer, s = e.shader || t.defaultShader;
        s.groups[0] = r.renderPipes.uniformBatch.getUniformBindGroup(t.localUniforms, true), s.groups[1] = r.texture.getTextureBindGroup(e.texture);
        let o = t.state, n = t.getBuffers(e);
        r.encoder.draw({ geometry: n.geometry, shader: e.shader || t.defaultShader, state: o, size: e.particleChildren.length * 6 });
      }
    };
  });
  var xs;
  var gg = p(() => {
    E();
    mg();
    Ll();
    xs = class extends ci {
      constructor(t) {
        super(t, new In2());
      }
    };
    xs.extension = { type: [_2.WebGPUPipes], name: "particle" };
  });
  var Nl = p(() => {
    E();
    pg();
    gg();
    U2.add(gs);
    U2.add(xs);
  });
  var Ee2;
  var _s = p(() => {
    "use strict";
    Ee2 = class {
      constructor() {
        this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = true, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null;
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      reset() {
        this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null;
      }
    };
  });
  function ys(i3, t) {
    let { texture: e, bounds: r } = i3;
    nn2(r, t._anchor, e);
    let s = t._style.padding;
    r.minX -= s, r.minY -= s, r.maxX -= s, r.maxY -= s;
  }
  var Hl = p(() => {
    Oc();
  });
  var bs;
  var xg = p(() => {
    E();
    Nt2();
    _s();
    Hl();
    bs = class {
      constructor(t) {
        this._gpuText = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.runners.resolutionChange.add(this), this._renderer.renderableGC.addManagedHash(this, "_gpuText");
      }
      resolutionChange() {
        for (let t in this._gpuText) {
          let e = this._gpuText[t];
          if (!e) continue;
          let r = e.batchableSprite.renderable;
          r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate());
        }
      }
      validateRenderable(t) {
        let e = this._getGpuText(t), r = t._getKey();
        return e.currentKey !== r;
      }
      addRenderable(t, e) {
        let s = this._getGpuText(t).batchableSprite;
        t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(s, e);
      }
      updateRenderable(t) {
        let r = this._getGpuText(t).batchableSprite;
        t._didTextUpdate && this._updateText(t), r._batcher.updateElement(r);
      }
      destroyRenderable(t) {
        t.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(t.uid);
      }
      _destroyRenderableById(t) {
        let e = this._gpuText[t];
        this._renderer.canvasText.decreaseReferenceCount(e.currentKey), V2.return(e.batchableSprite), this._gpuText[t] = null;
      }
      _updateText(t) {
        let e = t._getKey(), r = this._getGpuText(t), s = r.batchableSprite;
        r.currentKey !== e && this._updateGpuText(t), t._didTextUpdate = false, ys(s, t);
      }
      _updateGpuText(t) {
        let e = this._getGpuText(t), r = e.batchableSprite;
        e.texture && this._renderer.canvasText.decreaseReferenceCount(e.currentKey), e.texture = r.texture = this._renderer.canvasText.getManagedTexture(t), e.currentKey = t._getKey(), r.texture = e.texture;
      }
      _getGpuText(t) {
        return this._gpuText[t.uid] || this.initGpuText(t);
      }
      initGpuText(t) {
        let e = { texture: null, currentKey: "--", batchableSprite: V2.get(Ee2) };
        return e.batchableSprite.renderable = t, e.batchableSprite.transform = t.groupTransform, e.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, e.batchableSprite.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuText[t.uid] = e, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, this._updateText(t), t.on("destroyed", this._destroyRenderableBound), e;
      }
      destroy() {
        for (let t in this._gpuText) this._destroyRenderableById(t);
        this._gpuText = null, this._renderer = null;
      }
    };
    bs.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "text" };
  });
  var Wl;
  var Jt2;
  var li = p(() => {
    lt2();
    zi();
    Wl = class {
      constructor(t) {
        this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = false;
      }
      _createCanvasAndContext(t, e) {
        let r = N.get().createCanvas();
        r.width = t, r.height = e;
        let s = r.getContext("2d");
        return { canvas: r, context: s };
      }
      getOptimalCanvasAndContext(t, e, r = 1) {
        t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), t = ke2(t), e = ke2(e);
        let s = (t << 17) + (e << 1);
        this._canvasPool[s] || (this._canvasPool[s] = []);
        let o = this._canvasPool[s].pop();
        return o || (o = this._createCanvasAndContext(t, e)), o;
      }
      returnCanvasAndContext(t) {
        let e = t.canvas, { width: r, height: s } = e, o = (r << 17) + (s << 1);
        t.context.clearRect(0, 0, r, s), this._canvasPool[o].push(t);
      }
      clear() {
        this._canvasPool = {};
      }
    }, Jt2 = new Wl();
  });
  function _g(i3, t, e) {
    for (let r = 0, s = 4 * e * t; r < t; ++r, s += 4) if (i3[s + 3] !== 0) return false;
    return true;
  }
  function yg(i3, t, e, r, s) {
    let o = 4 * t;
    for (let n = r, a = r * o + 4 * e; n <= s; ++n, a += o) if (i3[a + 3] !== 0) return false;
    return true;
  }
  function bg(i3, t = 1) {
    let { width: e, height: r } = i3, s = i3.getContext("2d", { willReadFrequently: true });
    if (s === null) throw new TypeError("Failed to get canvas 2D context");
    let n = s.getImageData(0, 0, e, r).data, a = 0, c = 0, l = e - 1, h = r - 1;
    for (; c < r && _g(n, e, c); ) ++c;
    if (c === r) return Y2.EMPTY;
    for (; _g(n, e, h); ) --h;
    for (; yg(n, e, a, c, h); ) ++a;
    for (; yg(n, e, l, c, h); ) --l;
    return ++l, ++h, new Y2(a / t, c / t, (l - a) / t, (h - c) / t);
  }
  var vg = p(() => {
    St2();
  });
  var Tg;
  var Ne2;
  var Fn2 = p(() => {
    Q2();
    It2();
    Tg = { repeat: { addressModeU: "repeat", addressModeV: "repeat" }, "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" }, "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" }, "no-repeat": { addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" } }, Ne2 = class {
      constructor(t, e) {
        this.uid = q2("fillPattern"), this.transform = new I(), this._styleKey = null, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), e && (t.source.style.addressModeU = Tg[e].addressModeU, t.source.style.addressModeV = Tg[e].addressModeV);
      }
      setTransform(t) {
        let e = this.texture;
        this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / e.frame.width, 1 / e.frame.height), this._styleKey = null;
      }
      get styleKey() {
        return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
      }
    };
  });
  var wg = $a((Bk, Sg) => {
    Sg.exports = iS;
    var zl = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, rS = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function iS(i3) {
      var t = [];
      return i3.replace(rS, function(e, r, s) {
        var o = r.toLowerCase();
        for (s = oS(s), o == "m" && s.length > 2 && (t.push([r].concat(s.splice(0, 2))), o = "l", r = r == "m" ? "l" : "L"); ; ) {
          if (s.length == zl[o]) return s.unshift(r), t.push(s);
          if (s.length < zl[o]) throw new Error("malformed path data");
          t.push([r].concat(s.splice(0, zl[o])));
        }
      }), t;
    }
    var sS = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function oS(i3) {
      var t = i3.match(sS);
      return t ? t.map(Number) : [];
    }
  });
  function Ag(i3, t) {
    let e = (0, Pg.default)(i3), r = [], s = null, o = 0, n = 0;
    for (let a = 0; a < e.length; a++) {
      let c = e[a], l = c[0], h = c;
      switch (l) {
        case "M":
          o = h[1], n = h[2], t.moveTo(o, n);
          break;
        case "m":
          o += h[1], n += h[2], t.moveTo(o, n);
          break;
        case "H":
          o = h[1], t.lineTo(o, n);
          break;
        case "h":
          o += h[1], t.lineTo(o, n);
          break;
        case "V":
          n = h[1], t.lineTo(o, n);
          break;
        case "v":
          n += h[1], t.lineTo(o, n);
          break;
        case "L":
          o = h[1], n = h[2], t.lineTo(o, n);
          break;
        case "l":
          o += h[1], n += h[2], t.lineTo(o, n);
          break;
        case "C":
          o = h[5], n = h[6], t.bezierCurveTo(h[1], h[2], h[3], h[4], o, n);
          break;
        case "c":
          t.bezierCurveTo(o + h[1], n + h[2], o + h[3], n + h[4], o + h[5], n + h[6]), o += h[5], n += h[6];
          break;
        case "S":
          o = h[3], n = h[4], t.bezierCurveToShort(h[1], h[2], o, n);
          break;
        case "s":
          t.bezierCurveToShort(o + h[1], n + h[2], o + h[3], n + h[4]), o += h[3], n += h[4];
          break;
        case "Q":
          o = h[3], n = h[4], t.quadraticCurveTo(h[1], h[2], o, n);
          break;
        case "q":
          t.quadraticCurveTo(o + h[1], n + h[2], o + h[3], n + h[4]), o += h[3], n += h[4];
          break;
        case "T":
          o = h[1], n = h[2], t.quadraticCurveToShort(o, n);
          break;
        case "t":
          o += h[1], n += h[2], t.quadraticCurveToShort(o, n);
          break;
        case "A":
          o = h[6], n = h[7], t.arcToSvg(h[1], h[2], h[3], h[4], h[5], o, n);
          break;
        case "a":
          o += h[6], n += h[7], t.arcToSvg(h[1], h[2], h[3], h[4], h[5], o, n);
          break;
        case "Z":
        case "z":
          t.closePath(), r.length > 0 && (s = r.pop(), s ? (o = s.startX, n = s.startY) : (o = 0, n = 0)), s = null;
          break;
        default:
          O2(`Unknown SVG path command: ${l}`);
      }
      l !== "Z" && l !== "z" && s === null && (s = { startX: o, startY: n }, r.push(s));
    }
    return t;
  }
  var Pg;
  var Cg = p(() => {
    Pg = Io(wg(), 1);
    ot2();
  });
  var Un2;
  var Eg = p(() => {
    St2();
    Un2 = class i3 {
      constructor(t = 0, e = 0, r = 0) {
        this.type = "circle", this.x = t, this.y = e, this.radius = r;
      }
      clone() {
        return new i3(this.x, this.y, this.radius);
      }
      contains(t, e) {
        if (this.radius <= 0) return false;
        let r = this.radius * this.radius, s = this.x - t, o = this.y - e;
        return s *= s, o *= o, s + o <= r;
      }
      strokeContains(t, e, r, s = 0.5) {
        if (this.radius === 0) return false;
        let o = this.x - t, n = this.y - e, a = this.radius, c = (1 - s) * r, l = Math.sqrt(o * o + n * n);
        return l <= a + c && l > a - (r - c);
      }
      getBounds(t) {
        return t || (t = new Y2()), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
      }
      copyFrom(t) {
        return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
      }
      copyTo(t) {
        return t.copyFrom(this), t;
      }
      toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  });
  var Dn2;
  var Mg = p(() => {
    St2();
    Dn2 = class i3 {
      constructor(t = 0, e = 0, r = 0, s = 0) {
        this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = r, this.halfHeight = s;
      }
      clone() {
        return new i3(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      contains(t, e) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;
        let r = (t - this.x) / this.halfWidth, s = (e - this.y) / this.halfHeight;
        return r *= r, s *= s, r + s <= 1;
      }
      strokeContains(t, e, r, s = 0.5) {
        let { halfWidth: o, halfHeight: n } = this;
        if (o <= 0 || n <= 0) return false;
        let a = r * (1 - s), c = r - a, l = o - c, h = n - c, u = o + a, f = n + a, d2 = t - this.x, m = e - this.y, g = d2 * d2 / (l * l) + m * m / (h * h), x2 = d2 * d2 / (u * u) + m * m / (f * f);
        return g > 1 && x2 <= 1;
      }
      getBounds(t) {
        return t || (t = new Y2()), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
      }
      copyFrom(t) {
        return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
      }
      copyTo(t) {
        return t.copyFrom(this), t;
      }
      toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  });
  function Bg(i3, t, e, r, s, o) {
    let n = i3 - e, a = t - r, c = s - e, l = o - r, h = n * c + a * l, u = c * c + l * l, f = -1;
    u !== 0 && (f = h / u);
    let d2, m;
    f < 0 ? (d2 = e, m = r) : f > 1 ? (d2 = s, m = o) : (d2 = e + f * c, m = r + f * l);
    let g = i3 - d2, x2 = t - m;
    return g * g + x2 * x2;
  }
  var Rg = p(() => {
    "use strict";
  });
  var nS;
  var aS;
  var hi;
  var Gg = p(() => {
    Rg();
    St2();
    hi = class i3 {
      constructor(...t) {
        this.type = "polygon";
        let e = Array.isArray(t[0]) ? t[0] : t;
        if (typeof e[0] != "number") {
          let r = [];
          for (let s = 0, o = e.length; s < o; s++) r.push(e[s].x, e[s].y);
          e = r;
        }
        this.points = e, this.closePath = true;
      }
      isClockwise() {
        let t = 0, e = this.points, r = e.length;
        for (let s = 0; s < r; s += 2) {
          let o = e[s], n = e[s + 1], a = e[(s + 2) % r], c = e[(s + 3) % r];
          t += (a - o) * (c + n);
        }
        return t < 0;
      }
      containsPolygon(t) {
        let e = this.getBounds(nS), r = t.getBounds(aS);
        if (!e.containsRect(r)) return false;
        let s = t.points;
        for (let o = 0; o < s.length; o += 2) {
          let n = s[o], a = s[o + 1];
          if (!this.contains(n, a)) return false;
        }
        return true;
      }
      clone() {
        let t = this.points.slice(), e = new i3(t);
        return e.closePath = this.closePath, e;
      }
      contains(t, e) {
        let r = false, s = this.points.length / 2;
        for (let o = 0, n = s - 1; o < s; n = o++) {
          let a = this.points[o * 2], c = this.points[o * 2 + 1], l = this.points[n * 2], h = this.points[n * 2 + 1];
          c > e != h > e && t < (l - a) * ((e - c) / (h - c)) + a && (r = !r);
        }
        return r;
      }
      strokeContains(t, e, r, s = 0.5) {
        let o = r * r, n = o * (1 - s), a = o - n, { points: c } = this, l = c.length - (this.closePath ? 0 : 2);
        for (let h = 0; h < l; h += 2) {
          let u = c[h], f = c[h + 1], d2 = c[(h + 2) % c.length], m = c[(h + 3) % c.length], g = Bg(t, e, u, f, d2, m), x2 = Math.sign((d2 - u) * (e - f) - (m - f) * (t - u));
          if (g <= (x2 < 0 ? a : n)) return true;
        }
        return false;
      }
      getBounds(t) {
        t || (t = new Y2());
        let e = this.points, r = 1 / 0, s = -1 / 0, o = 1 / 0, n = -1 / 0;
        for (let a = 0, c = e.length; a < c; a += 2) {
          let l = e[a], h = e[a + 1];
          r = l < r ? l : r, s = l > s ? l : s, o = h < o ? h : o, n = h > n ? h : n;
        }
        return t.x = r, t.width = s - r, t.y = o, t.height = n - o, t;
      }
      copyFrom(t) {
        return this.points = t.points.slice(), this.closePath = t.closePath, this;
      }
      copyTo(t) {
        return t.copyFrom(this), t;
      }
      toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
      }
      get lastX() {
        return this.points[this.points.length - 2];
      }
      get lastY() {
        return this.points[this.points.length - 1];
      }
      get x() {
        return this.points[this.points.length - 2];
      }
      get y() {
        return this.points[this.points.length - 1];
      }
    };
  });
  var On2;
  var Ln2;
  var kg = p(() => {
    St2();
    On2 = (i3, t, e, r, s, o, n) => {
      let a = i3 - e, c = t - r, l = Math.sqrt(a * a + c * c);
      return l >= s - o && l <= s + n;
    }, Ln2 = class i3 {
      constructor(t = 0, e = 0, r = 0, s = 0, o = 20) {
        this.type = "roundedRectangle", this.x = t, this.y = e, this.width = r, this.height = s, this.radius = o;
      }
      getBounds(t) {
        return t || (t = new Y2()), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
      }
      clone() {
        return new i3(this.x, this.y, this.width, this.height, this.radius);
      }
      copyFrom(t) {
        return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
      }
      copyTo(t) {
        return t.copyFrom(this), t;
      }
      contains(t, e) {
        if (this.width <= 0 || this.height <= 0) return false;
        if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
          let r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r) return true;
          let s = t - (this.x + r), o = e - (this.y + r), n = r * r;
          if (s * s + o * o <= n || (s = t - (this.x + this.width - r), s * s + o * o <= n) || (o = e - (this.y + this.height - r), s * s + o * o <= n) || (s = t - (this.x + r), s * s + o * o <= n)) return true;
        }
        return false;
      }
      strokeContains(t, e, r, s = 0.5) {
        let { x: o, y: n, width: a, height: c, radius: l } = this, h = r * (1 - s), u = r - h, f = o + l, d2 = n + l, m = a - l * 2, g = c - l * 2, x2 = o + a, b = n + c;
        return (t >= o - h && t <= o + u || t >= x2 - u && t <= x2 + h) && e >= d2 && e <= d2 + g || (e >= n - h && e <= n + u || e >= b - u && e <= b + h) && t >= f && t <= f + m ? true : t < f && e < d2 && On2(t, e, f, d2, l, u, h) || t > x2 - l && e < d2 && On2(t, e, x2 - l, d2, l, u, h) || t > x2 - l && e > b - l && On2(t, e, x2 - l, b - l, l, u, h) || t < f && e > b - l && On2(t, e, f, b - l, l, u, h);
      }
      toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  });
  function Hn(i3, t, e, r, s, o, n, a, c, l) {
    let u = Math.min(0.99, Math.max(0, l ?? ni.defaultOptions.bezierSmoothness)), f = (lS - u) / 1;
    return f *= f, hS(t, e, r, s, o, n, a, c, i3, f), i3;
  }
  function hS(i3, t, e, r, s, o, n, a, c, l) {
    Xl(i3, t, e, r, s, o, n, a, c, l, 0), c.push(n, a);
  }
  function Xl(i3, t, e, r, s, o, n, a, c, l, h) {
    if (h > cS) return;
    let u = Math.PI, f = (i3 + e) / 2, d2 = (t + r) / 2, m = (e + s) / 2, g = (r + o) / 2, x2 = (s + n) / 2, b = (o + a) / 2, y = (f + m) / 2, v = (d2 + g) / 2, T2 = (m + x2) / 2, P = (g + b) / 2, w = (y + T2) / 2, C = (v + P) / 2;
    if (h > 0) {
      let G2 = n - i3, M2 = a - t, S2 = Math.abs((e - n) * M2 - (r - a) * G2), A2 = Math.abs((s - n) * M2 - (o - a) * G2), R2, F2;
      if (S2 > Nn2 && A2 > Nn2) {
        if ((S2 + A2) * (S2 + A2) <= l * (G2 * G2 + M2 * M2)) {
          if (ui < Vl) {
            c.push(w, C);
            return;
          }
          let W2 = Math.atan2(o - r, s - e);
          if (R2 = Math.abs(W2 - Math.atan2(r - t, e - i3)), F2 = Math.abs(Math.atan2(a - o, n - s) - W2), R2 >= u && (R2 = 2 * u - R2), F2 >= u && (F2 = 2 * u - F2), R2 + F2 < ui) {
            c.push(w, C);
            return;
          }
          if (Mr2 !== 0) {
            if (R2 > Mr2) {
              c.push(e, r);
              return;
            }
            if (F2 > Mr2) {
              c.push(s, o);
              return;
            }
          }
        }
      } else if (S2 > Nn2) {
        if (S2 * S2 <= l * (G2 * G2 + M2 * M2)) {
          if (ui < Vl) {
            c.push(w, C);
            return;
          }
          if (R2 = Math.abs(Math.atan2(o - r, s - e) - Math.atan2(r - t, e - i3)), R2 >= u && (R2 = 2 * u - R2), R2 < ui) {
            c.push(e, r), c.push(s, o);
            return;
          }
          if (Mr2 !== 0 && R2 > Mr2) {
            c.push(e, r);
            return;
          }
        }
      } else if (A2 > Nn2) {
        if (A2 * A2 <= l * (G2 * G2 + M2 * M2)) {
          if (ui < Vl) {
            c.push(w, C);
            return;
          }
          if (R2 = Math.abs(Math.atan2(a - o, n - s) - Math.atan2(o - r, s - e)), R2 >= u && (R2 = 2 * u - R2), R2 < ui) {
            c.push(e, r), c.push(s, o);
            return;
          }
          if (Mr2 !== 0 && R2 > Mr2) {
            c.push(s, o);
            return;
          }
        }
      } else if (G2 = w - (i3 + n) / 2, M2 = C - (t + a) / 2, G2 * G2 + M2 * M2 <= l) {
        c.push(w, C);
        return;
      }
    }
    Xl(i3, t, f, d2, y, v, w, C, c, l, h + 1), Xl(w, C, T2, P, x2, b, n, a, c, l, h + 1);
  }
  var cS;
  var Nn2;
  var lS;
  var Vl;
  var ui;
  var Mr2;
  var Yl = p(() => {
    Mn2();
    cS = 8, Nn2 = 11920929e-14, lS = 1, Vl = 0.01, ui = 0, Mr2 = 0;
  });
  function Fg(i3, t, e, r, s, o, n, a) {
    let l = Math.min(0.99, Math.max(0, a ?? ni.defaultOptions.bezierSmoothness)), h = (fS - l) / 1;
    return h *= h, mS(t, e, r, s, o, n, i3, h), i3;
  }
  function mS(i3, t, e, r, s, o, n, a) {
    $l(n, i3, t, e, r, s, o, a, 0), n.push(s, o);
  }
  function $l(i3, t, e, r, s, o, n, a, c) {
    if (c > uS) return;
    let l = Math.PI, h = (t + r) / 2, u = (e + s) / 2, f = (r + o) / 2, d2 = (s + n) / 2, m = (h + f) / 2, g = (u + d2) / 2, x2 = o - t, b = n - e, y = Math.abs((r - o) * b - (s - n) * x2);
    if (y > dS) {
      if (y * y <= a * (x2 * x2 + b * b)) {
        if (Ig < pS) {
          i3.push(m, g);
          return;
        }
        let v = Math.abs(Math.atan2(n - s, o - r) - Math.atan2(s - e, r - t));
        if (v >= l && (v = 2 * l - v), v < Ig) {
          i3.push(m, g);
          return;
        }
      }
    } else if (x2 = m - (t + o) / 2, b = g - (e + n) / 2, x2 * x2 + b * b <= a) {
      i3.push(m, g);
      return;
    }
    $l(i3, t, e, h, u, m, g, a, c + 1), $l(i3, m, g, f, d2, o, n, a, c + 1);
  }
  var uS;
  var dS;
  var fS;
  var pS;
  var Ig;
  var Ug = p(() => {
    Mn2();
    uS = 8, dS = 11920929e-14, fS = 1, pS = 0.01, Ig = 0;
  });
  function Wn2(i3, t, e, r, s, o, n, a) {
    let c = Math.abs(s - o);
    (!n && s > o || n && o > s) && (c = 2 * Math.PI - c), a || (a = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (c / Math.PI)))), a = Math.max(a, 3);
    let l = c / a, h = s;
    l *= n ? -1 : 1;
    for (let u = 0; u < a + 1; u++) {
      let f = Math.cos(h), d2 = Math.sin(h), m = t + f * r, g = e + d2 * r;
      i3.push(m, g), h += l;
    }
  }
  var jl = p(() => {
    "use strict";
  });
  function Dg(i3, t, e, r, s, o) {
    let n = i3[i3.length - 2], c = i3[i3.length - 1] - e, l = n - t, h = s - e, u = r - t, f = Math.abs(c * u - l * h);
    if (f < 1e-8 || o === 0) {
      (i3[i3.length - 2] !== t || i3[i3.length - 1] !== e) && i3.push(t, e);
      return;
    }
    let d2 = c * c + l * l, m = h * h + u * u, g = c * h + l * u, x2 = o * Math.sqrt(d2) / f, b = o * Math.sqrt(m) / f, y = x2 * g / d2, v = b * g / m, T2 = x2 * u + b * l, P = x2 * h + b * c, w = l * (b + y), C = c * (b + y), G2 = u * (x2 + v), M2 = h * (x2 + v), S2 = Math.atan2(C - P, w - T2), A2 = Math.atan2(M2 - P, G2 - T2);
    Wn2(i3, T2 + t, P + e, o, S2, A2, l * h > u * c);
  }
  var Og = p(() => {
    jl();
  });
  function gS(i3, t) {
    let e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), r = t === 1.5707963267948966 ? 0.551915024494 : e, s = Math.cos(i3), o = Math.sin(i3), n = Math.cos(i3 + t), a = Math.sin(i3 + t);
    return [{ x: s - o * r, y: o + s * r }, { x: n + a * r, y: a - n * r }, { x: n, y: a }];
  }
  function Ng(i3, t, e, r, s, o, n, a = 0, c = 0, l = 0) {
    if (o === 0 || n === 0) return;
    let h = Math.sin(a * vs / 360), u = Math.cos(a * vs / 360), f = u * (t - r) / 2 + h * (e - s) / 2, d2 = -h * (t - r) / 2 + u * (e - s) / 2;
    if (f === 0 && d2 === 0) return;
    o = Math.abs(o), n = Math.abs(n);
    let m = Math.pow(f, 2) / Math.pow(o, 2) + Math.pow(d2, 2) / Math.pow(n, 2);
    m > 1 && (o *= Math.sqrt(m), n *= Math.sqrt(m)), xS(t, e, r, s, o, n, c, l, h, u, f, d2, Kl);
    let { ang1: g, ang2: x2 } = Kl, { centerX: b, centerY: y } = Kl, v = Math.abs(x2) / (vs / 4);
    Math.abs(1 - v) < 1e-7 && (v = 1);
    let T2 = Math.max(Math.ceil(v), 1);
    x2 /= T2;
    let P = i3[i3.length - 2], w = i3[i3.length - 1], C = { x: 0, y: 0 };
    for (let G2 = 0; G2 < T2; G2++) {
      let M2 = gS(g, x2), { x: S2, y: A2 } = ql(M2[0], o, n, u, h, b, y, C), { x: R2, y: F2 } = ql(M2[1], o, n, u, h, b, y, C), { x: W2, y: X } = ql(M2[2], o, n, u, h, b, y, C);
      Hn(i3, P, w, S2, A2, R2, F2, W2, X), P = W2, w = X, g += x2;
    }
  }
  var vs;
  var Kl;
  var ql;
  var Lg;
  var xS;
  var Hg = p(() => {
    Yl();
    vs = Math.PI * 2, Kl = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 }, ql = ({ x: i3, y: t }, e, r, s, o, n, a, c) => {
      i3 *= e, t *= r;
      let l = s * i3 - o * t, h = o * i3 + s * t;
      return c.x = l + n, c.y = h + a, c;
    };
    Lg = (i3, t, e, r) => {
      let s = i3 * r - t * e < 0 ? -1 : 1, o = i3 * e + t * r;
      return o > 1 && (o = 1), o < -1 && (o = -1), s * Math.acos(o);
    }, xS = (i3, t, e, r, s, o, n, a, c, l, h, u, f) => {
      let d2 = Math.pow(s, 2), m = Math.pow(o, 2), g = Math.pow(h, 2), x2 = Math.pow(u, 2), b = d2 * m - d2 * x2 - m * g;
      b < 0 && (b = 0), b /= d2 * x2 + m * g, b = Math.sqrt(b) * (n === a ? -1 : 1);
      let y = b * s / o * u, v = b * -o / s * h, T2 = l * y - c * v + (i3 + e) / 2, P = c * y + l * v + (t + r) / 2, w = (h - y) / s, C = (u - v) / o, G2 = (-h - y) / s, M2 = (-u - v) / o, S2 = Lg(1, 0, w, C), A2 = Lg(w, C, G2, M2);
      a === 0 && A2 > 0 && (A2 -= vs), a === 1 && A2 < 0 && (A2 += vs), f.centerX = T2, f.centerY = P, f.ang1 = S2, f.ang2 = A2;
    };
  });
  function Wg(i3, t, e) {
    let r = (n, a) => {
      let c = a.x - n.x, l = a.y - n.y, h = Math.sqrt(c * c + l * l), u = c / h, f = l / h;
      return { len: h, nx: u, ny: f };
    }, s = (n, a) => {
      n === 0 ? i3.moveTo(a.x, a.y) : i3.lineTo(a.x, a.y);
    }, o = t[t.length - 1];
    for (let n = 0; n < t.length; n++) {
      let a = t[n % t.length], c = a.radius ?? e;
      if (c <= 0) {
        s(n, a), o = a;
        continue;
      }
      let l = t[(n + 1) % t.length], h = r(a, o), u = r(a, l);
      if (h.len < 1e-4 || u.len < 1e-4) {
        s(n, a), o = a;
        continue;
      }
      let f = Math.asin(h.nx * u.ny - h.ny * u.nx), d2 = 1, m = false;
      h.nx * u.nx - h.ny * -u.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, d2 = -1, m = true) : f > 0 && (d2 = -1, m = true);
      let g = f / 2, x2, b = Math.abs(Math.cos(g) * c / Math.sin(g));
      b > Math.min(h.len / 2, u.len / 2) ? (b = Math.min(h.len / 2, u.len / 2), x2 = Math.abs(b * Math.sin(g) / Math.cos(g))) : x2 = c;
      let y = a.x + u.nx * b + -u.ny * x2 * d2, v = a.y + u.ny * b + u.nx * x2 * d2, T2 = Math.atan2(h.ny, h.nx) + Math.PI / 2 * d2, P = Math.atan2(u.ny, u.nx) - Math.PI / 2 * d2;
      n === 0 && i3.moveTo(y + Math.cos(T2) * x2, v + Math.sin(T2) * x2), i3.arc(y, v, x2, T2, P, m), o = a;
    }
  }
  function zg(i3, t, e, r) {
    let s = (a, c) => Math.sqrt((a.x - c.x) ** 2 + (a.y - c.y) ** 2), o = (a, c, l) => ({ x: a.x + (c.x - a.x) * l, y: a.y + (c.y - a.y) * l }), n = t.length;
    for (let a = 0; a < n; a++) {
      let c = t[(a + 1) % n], l = c.radius ?? e;
      if (l <= 0) {
        a === 0 ? i3.moveTo(c.x, c.y) : i3.lineTo(c.x, c.y);
        continue;
      }
      let h = t[a], u = t[(a + 2) % n], f = s(h, c), d2;
      if (f < 1e-4) d2 = c;
      else {
        let x2 = Math.min(f / 2, l);
        d2 = o(c, h, x2 / f);
      }
      let m = s(u, c), g;
      if (m < 1e-4) g = c;
      else {
        let x2 = Math.min(m / 2, l);
        g = o(c, u, x2 / m);
      }
      a === 0 ? i3.moveTo(d2.x, d2.y) : i3.lineTo(d2.x, d2.y), i3.quadraticCurveTo(c.x, c.y, g.x, g.y, r);
    }
  }
  var Vg = p(() => {
    "use strict";
  });
  var _S;
  var zn2;
  var Xg = p(() => {
    Eg();
    Mg();
    Gg();
    St2();
    kg();
    $t2();
    Yl();
    Ug();
    jl();
    Og();
    Hg();
    Vg();
    _S = new Y2(), zn2 = class {
      constructor(t) {
        this.shapePrimitives = [], this._currentPoly = null, this._bounds = new st2(), this._graphicsPath2D = t, this.signed = t.checkForHoles;
      }
      moveTo(t, e) {
        return this.startPoly(t, e), this;
      }
      lineTo(t, e) {
        this._ensurePoly();
        let r = this._currentPoly.points, s = r[r.length - 2], o = r[r.length - 1];
        return (s !== t || o !== e) && r.push(t, e), this;
      }
      arc(t, e, r, s, o, n) {
        this._ensurePoly(false);
        let a = this._currentPoly.points;
        return Wn2(a, t, e, r, s, o, n), this;
      }
      arcTo(t, e, r, s, o) {
        this._ensurePoly();
        let n = this._currentPoly.points;
        return Dg(n, t, e, r, s, o), this;
      }
      arcToSvg(t, e, r, s, o, n, a) {
        let c = this._currentPoly.points;
        return Ng(c, this._currentPoly.lastX, this._currentPoly.lastY, n, a, t, e, r, s, o), this;
      }
      bezierCurveTo(t, e, r, s, o, n, a) {
        this._ensurePoly();
        let c = this._currentPoly;
        return Hn(this._currentPoly.points, c.lastX, c.lastY, t, e, r, s, o, n, a), this;
      }
      quadraticCurveTo(t, e, r, s, o) {
        this._ensurePoly();
        let n = this._currentPoly;
        return Fg(this._currentPoly.points, n.lastX, n.lastY, t, e, r, s, o), this;
      }
      closePath() {
        return this.endPoly(true), this;
      }
      addPath(t, e) {
        this.endPoly(), e && !e.isIdentity() && (t = t.clone(true), t.transform(e));
        let r = this.shapePrimitives, s = r.length;
        for (let o = 0; o < t.instructions.length; o++) {
          let n = t.instructions[o];
          this[n.action](...n.data);
        }
        if (t.checkForHoles && r.length - s > 1) {
          let o = null;
          for (let n = s; n < r.length; n++) {
            let a = r[n];
            if (a.shape.type === "polygon") {
              let c = a.shape, l = o?.shape;
              l && l.containsPolygon(c) ? (o.holes || (o.holes = []), o.holes.push(a), r.copyWithin(n, n + 1), r.length--, n--) : o = a;
            }
          }
        }
        return this;
      }
      finish(t = false) {
        this.endPoly(t);
      }
      rect(t, e, r, s, o) {
        return this.drawShape(new Y2(t, e, r, s), o), this;
      }
      circle(t, e, r, s) {
        return this.drawShape(new Un2(t, e, r), s), this;
      }
      poly(t, e, r) {
        let s = new hi(t);
        return s.closePath = e, this.drawShape(s, r), this;
      }
      regularPoly(t, e, r, s, o = 0, n) {
        s = Math.max(s | 0, 3);
        let a = -1 * Math.PI / 2 + o, c = Math.PI * 2 / s, l = [];
        for (let h = 0; h < s; h++) {
          let u = a - h * c;
          l.push(t + r * Math.cos(u), e + r * Math.sin(u));
        }
        return this.poly(l, true, n), this;
      }
      roundPoly(t, e, r, s, o, n = 0, a) {
        if (s = Math.max(s | 0, 3), o <= 0) return this.regularPoly(t, e, r, s, n);
        let c = r * Math.sin(Math.PI / s) - 1e-3;
        o = Math.min(o, c);
        let l = -1 * Math.PI / 2 + n, h = Math.PI * 2 / s, u = (s - 2) * Math.PI / s / 2;
        for (let f = 0; f < s; f++) {
          let d2 = f * h + l, m = t + r * Math.cos(d2), g = e + r * Math.sin(d2), x2 = d2 + Math.PI + u, b = d2 - Math.PI - u, y = m + o * Math.cos(x2), v = g + o * Math.sin(x2), T2 = m + o * Math.cos(b), P = g + o * Math.sin(b);
          f === 0 ? this.moveTo(y, v) : this.lineTo(y, v), this.quadraticCurveTo(m, g, T2, P, a);
        }
        return this.closePath();
      }
      roundShape(t, e, r = false, s) {
        return t.length < 3 ? this : (r ? zg(this, t, e, s) : Wg(this, t, e), this.closePath());
      }
      filletRect(t, e, r, s, o) {
        if (o === 0) return this.rect(t, e, r, s);
        let n = Math.min(r, s) / 2, a = Math.min(n, Math.max(-n, o)), c = t + r, l = e + s, h = a < 0 ? -a : 0, u = Math.abs(a);
        return this.moveTo(t, e + u).arcTo(t + h, e + h, t + u, e, u).lineTo(c - u, e).arcTo(c - h, e + h, c, e + u, u).lineTo(c, l - u).arcTo(c - h, l - h, t + r - u, l, u).lineTo(t + u, l).arcTo(t + h, l - h, t, l - u, u).closePath();
      }
      chamferRect(t, e, r, s, o, n) {
        if (o <= 0) return this.rect(t, e, r, s);
        let a = Math.min(o, Math.min(r, s) / 2), c = t + r, l = e + s, h = [t + a, e, c - a, e, c, e + a, c, l - a, c - a, l, t + a, l, t, l - a, t, e + a];
        for (let u = h.length - 1; u >= 2; u -= 2) h[u] === h[u - 2] && h[u - 1] === h[u - 3] && h.splice(u - 1, 2);
        return this.poly(h, true, n);
      }
      ellipse(t, e, r, s, o) {
        return this.drawShape(new Dn2(t, e, r, s), o), this;
      }
      roundRect(t, e, r, s, o, n) {
        return this.drawShape(new Ln2(t, e, r, s, o), n), this;
      }
      drawShape(t, e) {
        return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: e }), this;
      }
      startPoly(t, e) {
        let r = this._currentPoly;
        return r && this.endPoly(), r = new hi(), r.points.push(t, e), this._currentPoly = r, this;
      }
      endPoly(t = false) {
        let e = this._currentPoly;
        return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({ shape: e })), this._currentPoly = null, this;
      }
      _ensurePoly(t = true) {
        if (!this._currentPoly && (this._currentPoly = new hi(), t)) {
          let e = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (e) {
            let r = e.shape.x, s = e.shape.y;
            if (e.transform && !e.transform.isIdentity()) {
              let o = e.transform, n = r;
              r = o.a * r + o.c * s + o.tx, s = o.b * n + o.d * s + o.ty;
            }
            this._currentPoly.points.push(r, s);
          } else this._currentPoly.points.push(0, 0);
        }
      }
      buildPath() {
        let t = this._graphicsPath2D;
        this.shapePrimitives.length = 0, this._currentPoly = null;
        for (let e = 0; e < t.instructions.length; e++) {
          let r = t.instructions[e];
          this[r.action](...r.data);
        }
        this.finish();
      }
      get bounds() {
        let t = this._bounds;
        t.clear();
        let e = this.shapePrimitives;
        for (let r = 0; r < e.length; r++) {
          let s = e[r], o = s.shape.getBounds(_S);
          s.transform ? t.addRect(o, s.transform) : t.addRect(o);
        }
        return t;
      }
    };
  });
  function Ts(i3, t) {
    return i3 ? i3.prepend(t) : t.clone();
  }
  var er2;
  var Zl = p(() => {
    oe2();
    It2();
    ot2();
    Cg();
    Xg();
    er2 = class i3 {
      constructor(t, e = false) {
        this.instructions = [], this.uid = q2("graphicsPath"), this._dirty = true, this.checkForHoles = e, typeof t == "string" ? Ag(t, this) : this.instructions = t?.slice() ?? [];
      }
      get shapePath() {
        return this._shapePath || (this._shapePath = new zn2(this)), this._dirty && (this._dirty = false, this._shapePath.buildPath()), this._shapePath;
      }
      addPath(t, e) {
        return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, e] }), this._dirty = true, this;
      }
      arc(...t) {
        return this.instructions.push({ action: "arc", data: t }), this._dirty = true, this;
      }
      arcTo(...t) {
        return this.instructions.push({ action: "arcTo", data: t }), this._dirty = true, this;
      }
      arcToSvg(...t) {
        return this.instructions.push({ action: "arcToSvg", data: t }), this._dirty = true, this;
      }
      bezierCurveTo(...t) {
        return this.instructions.push({ action: "bezierCurveTo", data: t }), this._dirty = true, this;
      }
      bezierCurveToShort(t, e, r, s, o) {
        let n = this.instructions[this.instructions.length - 1], a = this.getLastPoint(Z2.shared), c = 0, l = 0;
        if (!n || n.action !== "bezierCurveTo") c = a.x, l = a.y;
        else {
          c = n.data[2], l = n.data[3];
          let h = a.x, u = a.y;
          c = h + (h - c), l = u + (u - l);
        }
        return this.instructions.push({ action: "bezierCurveTo", data: [c, l, t, e, r, s, o] }), this._dirty = true, this;
      }
      closePath() {
        return this.instructions.push({ action: "closePath", data: [] }), this._dirty = true, this;
      }
      ellipse(...t) {
        return this.instructions.push({ action: "ellipse", data: t }), this._dirty = true, this;
      }
      lineTo(...t) {
        return this.instructions.push({ action: "lineTo", data: t }), this._dirty = true, this;
      }
      moveTo(...t) {
        return this.instructions.push({ action: "moveTo", data: t }), this;
      }
      quadraticCurveTo(...t) {
        return this.instructions.push({ action: "quadraticCurveTo", data: t }), this._dirty = true, this;
      }
      quadraticCurveToShort(t, e, r) {
        let s = this.instructions[this.instructions.length - 1], o = this.getLastPoint(Z2.shared), n = 0, a = 0;
        if (!s || s.action !== "quadraticCurveTo") n = o.x, a = o.y;
        else {
          n = s.data[0], a = s.data[1];
          let c = o.x, l = o.y;
          n = c + (c - n), a = l + (l - a);
        }
        return this.instructions.push({ action: "quadraticCurveTo", data: [n, a, t, e, r] }), this._dirty = true, this;
      }
      rect(t, e, r, s, o) {
        return this.instructions.push({ action: "rect", data: [t, e, r, s, o] }), this._dirty = true, this;
      }
      circle(t, e, r, s) {
        return this.instructions.push({ action: "circle", data: [t, e, r, s] }), this._dirty = true, this;
      }
      roundRect(...t) {
        return this.instructions.push({ action: "roundRect", data: t }), this._dirty = true, this;
      }
      poly(...t) {
        return this.instructions.push({ action: "poly", data: t }), this._dirty = true, this;
      }
      regularPoly(...t) {
        return this.instructions.push({ action: "regularPoly", data: t }), this._dirty = true, this;
      }
      roundPoly(...t) {
        return this.instructions.push({ action: "roundPoly", data: t }), this._dirty = true, this;
      }
      roundShape(...t) {
        return this.instructions.push({ action: "roundShape", data: t }), this._dirty = true, this;
      }
      filletRect(...t) {
        return this.instructions.push({ action: "filletRect", data: t }), this._dirty = true, this;
      }
      chamferRect(...t) {
        return this.instructions.push({ action: "chamferRect", data: t }), this._dirty = true, this;
      }
      star(t, e, r, s, o, n, a) {
        o || (o = s / 2);
        let c = -1 * Math.PI / 2 + n, l = r * 2, h = Math.PI * 2 / l, u = [];
        for (let f = 0; f < l; f++) {
          let d2 = f % 2 ? o : s, m = f * h + c;
          u.push(t + d2 * Math.cos(m), e + d2 * Math.sin(m));
        }
        return this.poly(u, true, a), this;
      }
      clone(t = false) {
        let e = new i3();
        if (e.checkForHoles = this.checkForHoles, !t) e.instructions = this.instructions.slice();
        else for (let r = 0; r < this.instructions.length; r++) {
          let s = this.instructions[r];
          e.instructions.push({ action: s.action, data: s.data.slice() });
        }
        return e;
      }
      clear() {
        return this.instructions.length = 0, this._dirty = true, this;
      }
      transform(t) {
        if (t.isIdentity()) return this;
        let e = t.a, r = t.b, s = t.c, o = t.d, n = t.tx, a = t.ty, c = 0, l = 0, h = 0, u = 0, f = 0, d2 = 0, m = 0, g = 0;
        for (let x2 = 0; x2 < this.instructions.length; x2++) {
          let b = this.instructions[x2], y = b.data;
          switch (b.action) {
            case "moveTo":
            case "lineTo":
              c = y[0], l = y[1], y[0] = e * c + s * l + n, y[1] = r * c + o * l + a;
              break;
            case "bezierCurveTo":
              h = y[0], u = y[1], f = y[2], d2 = y[3], c = y[4], l = y[5], y[0] = e * h + s * u + n, y[1] = r * h + o * u + a, y[2] = e * f + s * d2 + n, y[3] = r * f + o * d2 + a, y[4] = e * c + s * l + n, y[5] = r * c + o * l + a;
              break;
            case "quadraticCurveTo":
              h = y[0], u = y[1], c = y[2], l = y[3], y[0] = e * h + s * u + n, y[1] = r * h + o * u + a, y[2] = e * c + s * l + n, y[3] = r * c + o * l + a;
              break;
            case "arcToSvg":
              c = y[5], l = y[6], m = y[0], g = y[1], y[0] = e * m + s * g, y[1] = r * m + o * g, y[5] = e * c + s * l + n, y[6] = r * c + o * l + a;
              break;
            case "circle":
              y[4] = Ts(y[3], t);
              break;
            case "rect":
              y[4] = Ts(y[4], t);
              break;
            case "ellipse":
              y[8] = Ts(y[8], t);
              break;
            case "roundRect":
              y[5] = Ts(y[5], t);
              break;
            case "addPath":
              y[0].transform(t);
              break;
            case "poly":
              y[2] = Ts(y[2], t);
              break;
            default:
              O2("unknown transform action", b.action);
              break;
          }
        }
        return this._dirty = true, this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      getLastPoint(t) {
        let e = this.instructions.length - 1, r = this.instructions[e];
        if (!r) return t.x = 0, t.y = 0, t;
        for (; r.action === "closePath"; ) {
          if (e--, e < 0) return t.x = 0, t.y = 0, t;
          r = this.instructions[e];
        }
        switch (r.action) {
          case "moveTo":
          case "lineTo":
            t.x = r.data[0], t.y = r.data[1];
            break;
          case "quadraticCurveTo":
            t.x = r.data[2], t.y = r.data[3];
            break;
          case "bezierCurveTo":
            t.x = r.data[4], t.y = r.data[5];
            break;
          case "arc":
          case "arcToSvg":
            t.x = r.data[5], t.y = r.data[6];
            break;
          case "addPath":
            r.data[0].getLastPoint(t);
            break;
        }
        return t;
      }
    };
  });
  function dt2(i3, t, e) {
    let r = i3.getAttribute(t);
    return r ? Number(r) : e;
  }
  var Ql = p(() => {
    "use strict";
  });
  function Yg(i3, t) {
    let e = i3.querySelectorAll("defs");
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      for (let o = 0; o < s.children.length; o++) {
        let n = s.children[o];
        switch (n.nodeName.toLowerCase()) {
          case "lineargradient":
            t.defs[n.id] = yS(n);
            break;
          case "radialgradient":
            t.defs[n.id] = bS(n);
            break;
          default:
            break;
        }
      }
    }
  }
  function yS(i3) {
    let t = dt2(i3, "x1", 0), e = dt2(i3, "y1", 0), r = dt2(i3, "x2", 1), s = dt2(i3, "y2", 0), o = i3.getAttribute("gradientUnits") || "objectBoundingBox", n = new Qt2(t, e, r, s, o === "objectBoundingBox" ? "local" : "global");
    for (let a = 0; a < i3.children.length; a++) {
      let c = i3.children[a], l = dt2(c, "offset", 0), h = $.shared.setValue(c.getAttribute("stop-color")).toNumber();
      n.addColorStop(l, h);
    }
    return n;
  }
  function bS(i3) {
    return O2("[SVG Parser] Radial gradients are not yet supported"), new Qt2(0, 0, 1, 0);
  }
  var $g = p(() => {
    Gt2();
    ot2();
    oi();
    Ql();
  });
  function Jl(i3) {
    let t = i3.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return t ? t[1] : "";
  }
  var jg = p(() => {
    "use strict";
  });
  function th(i3, t) {
    let e = i3.getAttribute("style"), r = {}, s = {}, o = { strokeStyle: r, fillStyle: s, useFill: false, useStroke: false };
    for (let n in Kg) {
      let a = i3.getAttribute(n);
      a && qg(t, o, n, a.trim());
    }
    if (e) {
      let n = e.split(";");
      for (let a = 0; a < n.length; a++) {
        let c = n[a].trim(), [l, h] = c.split(":");
        Kg[l] && qg(t, o, l, h.trim());
      }
    }
    return { strokeStyle: o.useStroke ? r : null, fillStyle: o.useFill ? s : null, useFill: o.useFill, useStroke: o.useStroke };
  }
  function qg(i3, t, e, r) {
    switch (e) {
      case "stroke":
        if (r !== "none") {
          if (r.startsWith("url(")) {
            let s = Jl(r);
            t.strokeStyle.fill = i3.defs[s];
          } else t.strokeStyle.color = $.shared.setValue(r).toNumber();
          t.useStroke = true;
        }
        break;
      case "stroke-width":
        t.strokeStyle.width = Number(r);
        break;
      case "fill":
        if (r !== "none") {
          if (r.startsWith("url(")) {
            let s = Jl(r);
            t.fillStyle.fill = i3.defs[s];
          } else t.fillStyle.color = $.shared.setValue(r).toNumber();
          t.useFill = true;
        }
        break;
      case "fill-opacity":
        t.fillStyle.alpha = Number(r);
        break;
      case "stroke-opacity":
        t.strokeStyle.alpha = Number(r);
        break;
      case "opacity":
        t.fillStyle.alpha = Number(r), t.strokeStyle.alpha = Number(r);
        break;
    }
  }
  var Kg;
  var Zg = p(() => {
    Gt2();
    jg();
    Kg = { fill: { type: "paint", default: 0 }, "fill-opacity": { type: "number", default: 1 }, stroke: { type: "paint", default: 0 }, "stroke-width": { type: "number", default: 1 }, "stroke-opacity": { type: "number", default: 1 }, "stroke-linecap": { type: "string", default: "butt" }, "stroke-linejoin": { type: "string", default: "miter" }, "stroke-miterlimit": { type: "number", default: 10 }, "stroke-dasharray": { type: "string", default: "none" }, "stroke-dashoffset": { type: "number", default: 0 }, opacity: { type: "number", default: 1 } };
  });
  function Qg(i3, t) {
    if (typeof i3 == "string") {
      let n = document.createElement("div");
      n.innerHTML = i3.trim(), i3 = n.querySelector("svg");
    }
    let e = { context: t, defs: {}, path: new er2() };
    Yg(i3, e);
    let r = i3.children, { fillStyle: s, strokeStyle: o } = th(i3, e);
    for (let n = 0; n < r.length; n++) {
      let a = r[n];
      a.nodeName.toLowerCase() !== "defs" && Jg(a, e, s, o);
    }
    return t;
  }
  function Jg(i3, t, e, r) {
    let s = i3.children, { fillStyle: o, strokeStyle: n } = th(i3, t);
    o && e ? e = { ...e, ...o } : o && (e = o), n && r ? r = { ...r, ...n } : n && (r = n);
    let a = !e && !r;
    a && (e = { color: 0 });
    let c, l, h, u, f, d2, m, g, x2, b, y, v, T2, P, w, C, G2;
    switch (i3.nodeName.toLowerCase()) {
      case "path":
        P = i3.getAttribute("d"), i3.getAttribute("fill-rule") === "evenodd" && O2("SVG Evenodd fill rule not supported, your svg may render incorrectly"), w = new er2(P, true), t.context.path(w), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "circle":
        m = dt2(i3, "cx", 0), g = dt2(i3, "cy", 0), x2 = dt2(i3, "r", 0), t.context.ellipse(m, g, x2, x2), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "rect":
        c = dt2(i3, "x", 0), l = dt2(i3, "y", 0), C = dt2(i3, "width", 0), G2 = dt2(i3, "height", 0), b = dt2(i3, "rx", 0), y = dt2(i3, "ry", 0), b || y ? t.context.roundRect(c, l, C, G2, b || y) : t.context.rect(c, l, C, G2), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "ellipse":
        m = dt2(i3, "cx", 0), g = dt2(i3, "cy", 0), b = dt2(i3, "rx", 0), y = dt2(i3, "ry", 0), t.context.beginPath(), t.context.ellipse(m, g, b, y), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "line":
        h = dt2(i3, "x1", 0), u = dt2(i3, "y1", 0), f = dt2(i3, "x2", 0), d2 = dt2(i3, "y2", 0), t.context.beginPath(), t.context.moveTo(h, u), t.context.lineTo(f, d2), r && t.context.stroke(r);
        break;
      case "polygon":
        T2 = i3.getAttribute("points"), v = T2.match(/\d+/g).map((M2) => parseInt(M2, 10)), t.context.poly(v, true), e && t.context.fill(e), r && t.context.stroke(r);
        break;
      case "polyline":
        T2 = i3.getAttribute("points"), v = T2.match(/\d+/g).map((M2) => parseInt(M2, 10)), t.context.poly(v, false), r && t.context.stroke(r);
        break;
      case "g":
      case "svg":
        break;
      default: {
        O2(`[SVG parser] <${i3.nodeName}> elements unsupported`);
        break;
      }
    }
    a && (e = null);
    for (let M2 = 0; M2 < s.length; M2++) Jg(s[M2], t, e, r);
  }
  var tx = p(() => {
    ot2();
    Zl();
    $g();
    Ql();
    Zg();
  });
  function vS(i3) {
    return $.isColorLike(i3);
  }
  function ex(i3) {
    return i3 instanceof Ne2;
  }
  function rx(i3) {
    return i3 instanceof Qt2;
  }
  function TS(i3) {
    return i3 instanceof B;
  }
  function SS(i3, t, e) {
    let r = $.shared.setValue(t ?? 0);
    return i3.color = r.toNumber(), i3.alpha = r.alpha === 1 ? e.alpha : r.alpha, i3.texture = B.WHITE, { ...e, ...i3 };
  }
  function wS(i3, t, e) {
    return i3.texture = t, { ...e, ...i3 };
  }
  function ix(i3, t, e) {
    return i3.fill = t, i3.color = 16777215, i3.texture = t.texture, i3.matrix = t.transform, { ...e, ...i3 };
  }
  function sx(i3, t, e) {
    return t.buildGradient(), i3.fill = t, i3.color = 16777215, i3.texture = t.texture, i3.matrix = t.transform, i3.textureSpace = t.textureSpace, { ...e, ...i3 };
  }
  function PS(i3, t) {
    let e = { ...t, ...i3 }, r = $.shared.setValue(e.color);
    return e.alpha *= r.alpha, e.color = r.toNumber(), e;
  }
  function He2(i3, t) {
    if (i3 == null) return null;
    let e = {}, r = i3;
    return vS(i3) ? SS(e, i3, t) : TS(i3) ? wS(e, i3, t) : ex(i3) ? ix(e, i3, t) : rx(i3) ? sx(e, i3, t) : r.fill && ex(r.fill) ? ix(r, r.fill, t) : r.fill && rx(r.fill) ? sx(r, r.fill, t) : PS(r, t);
  }
  function di(i3, t) {
    let { width: e, alignment: r, miterLimit: s, cap: o, join: n, pixelLine: a, ...c } = t, l = He2(i3, c);
    return l ? { width: e, alignment: r, miterLimit: s, cap: o, join: n, pixelLine: a, ...l } : null;
  }
  var eh = p(() => {
    Gt2();
    rt2();
    oi();
    Fn2();
  });
  var AS;
  var ox;
  var rh;
  var Vt2;
  var Vn2 = p(() => {
    Dt2();
    Gt2();
    Q2();
    oe2();
    rt2();
    It2();
    ft2();
    $t2();
    Zl();
    tx();
    eh();
    AS = new Z2(), ox = new I(), rh = class Me2 extends at2 {
      constructor() {
        super(...arguments), this.uid = q2("graphicsContext"), this.dirty = true, this.batchMode = "auto", this.instructions = [], this._activePath = new er2(), this._transform = new I(), this._fillStyle = { ...Me2.defaultFillStyle }, this._strokeStyle = { ...Me2.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new st2(), this._boundsDirty = true;
      }
      clone() {
        let t = new Me2();
        return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = { ...this._fillStyle }, t._strokeStyle = { ...this._strokeStyle }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = true, t;
      }
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(t) {
        this._fillStyle = He2(t, Me2.defaultFillStyle);
      }
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(t) {
        this._strokeStyle = di(t, Me2.defaultStrokeStyle);
      }
      setFillStyle(t) {
        return this._fillStyle = He2(t, Me2.defaultFillStyle), this;
      }
      setStrokeStyle(t) {
        return this._strokeStyle = He2(t, Me2.defaultStrokeStyle), this;
      }
      texture(t, e, r, s, o, n) {
        return this.instructions.push({ action: "texture", data: { image: t, dx: r || 0, dy: s || 0, dw: o || t.frame.width, dh: n || t.frame.height, transform: this._transform.clone(), alpha: this._fillStyle.alpha, style: e ? $.shared.setValue(e).toNumber() : 16777215 } }), this.onUpdate(), this;
      }
      beginPath() {
        return this._activePath = new er2(), this;
      }
      fill(t, e) {
        let r, s = this.instructions[this.instructions.length - 1];
        return this._tick === 0 && s && s.action === "stroke" ? r = s.data.path : r = this._activePath.clone(), r ? (t != null && (e !== void 0 && typeof t == "number" && (L2(z, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = { color: t, alpha: e }), this._fillStyle = He2(t, Me2.defaultFillStyle)), this.instructions.push({ action: "fill", data: { style: this.fillStyle, path: r } }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
      }
      _initNextPathLocation() {
        let { x: t, y: e } = this._activePath.getLastPoint(Z2.shared);
        this._activePath.clear(), this._activePath.moveTo(t, e);
      }
      stroke(t) {
        let e, r = this.instructions[this.instructions.length - 1];
        return this._tick === 0 && r && r.action === "fill" ? e = r.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = di(t, Me2.defaultStrokeStyle)), this.instructions.push({ action: "stroke", data: { style: this.strokeStyle, path: e } }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
      }
      cut() {
        for (let t = 0; t < 2; t++) {
          let e = this.instructions[this.instructions.length - 1 - t], r = this._activePath.clone();
          if (e && (e.action === "stroke" || e.action === "fill")) if (e.data.hole) e.data.hole.addPath(r);
          else {
            e.data.hole = r;
            break;
          }
        }
        return this._initNextPathLocation(), this;
      }
      arc(t, e, r, s, o, n) {
        this._tick++;
        let a = this._transform;
        return this._activePath.arc(a.a * t + a.c * e + a.tx, a.b * t + a.d * e + a.ty, r, s, o, n), this;
      }
      arcTo(t, e, r, s, o) {
        this._tick++;
        let n = this._transform;
        return this._activePath.arcTo(n.a * t + n.c * e + n.tx, n.b * t + n.d * e + n.ty, n.a * r + n.c * s + n.tx, n.b * r + n.d * s + n.ty, o), this;
      }
      arcToSvg(t, e, r, s, o, n, a) {
        this._tick++;
        let c = this._transform;
        return this._activePath.arcToSvg(t, e, r, s, o, c.a * n + c.c * a + c.tx, c.b * n + c.d * a + c.ty), this;
      }
      bezierCurveTo(t, e, r, s, o, n, a) {
        this._tick++;
        let c = this._transform;
        return this._activePath.bezierCurveTo(c.a * t + c.c * e + c.tx, c.b * t + c.d * e + c.ty, c.a * r + c.c * s + c.tx, c.b * r + c.d * s + c.ty, c.a * o + c.c * n + c.tx, c.b * o + c.d * n + c.ty, a), this;
      }
      closePath() {
        return this._tick++, this._activePath?.closePath(), this;
      }
      ellipse(t, e, r, s) {
        return this._tick++, this._activePath.ellipse(t, e, r, s, this._transform.clone()), this;
      }
      circle(t, e, r) {
        return this._tick++, this._activePath.circle(t, e, r, this._transform.clone()), this;
      }
      path(t) {
        return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
      }
      lineTo(t, e) {
        this._tick++;
        let r = this._transform;
        return this._activePath.lineTo(r.a * t + r.c * e + r.tx, r.b * t + r.d * e + r.ty), this;
      }
      moveTo(t, e) {
        this._tick++;
        let r = this._transform, s = this._activePath.instructions, o = r.a * t + r.c * e + r.tx, n = r.b * t + r.d * e + r.ty;
        return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = o, s[0].data[1] = n, this) : (this._activePath.moveTo(o, n), this);
      }
      quadraticCurveTo(t, e, r, s, o) {
        this._tick++;
        let n = this._transform;
        return this._activePath.quadraticCurveTo(n.a * t + n.c * e + n.tx, n.b * t + n.d * e + n.ty, n.a * r + n.c * s + n.tx, n.b * r + n.d * s + n.ty, o), this;
      }
      rect(t, e, r, s) {
        return this._tick++, this._activePath.rect(t, e, r, s, this._transform.clone()), this;
      }
      roundRect(t, e, r, s, o) {
        return this._tick++, this._activePath.roundRect(t, e, r, s, o, this._transform.clone()), this;
      }
      poly(t, e) {
        return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
      }
      regularPoly(t, e, r, s, o = 0, n) {
        return this._tick++, this._activePath.regularPoly(t, e, r, s, o, n), this;
      }
      roundPoly(t, e, r, s, o, n) {
        return this._tick++, this._activePath.roundPoly(t, e, r, s, o, n), this;
      }
      roundShape(t, e, r, s) {
        return this._tick++, this._activePath.roundShape(t, e, r, s), this;
      }
      filletRect(t, e, r, s, o) {
        return this._tick++, this._activePath.filletRect(t, e, r, s, o), this;
      }
      chamferRect(t, e, r, s, o, n) {
        return this._tick++, this._activePath.chamferRect(t, e, r, s, o, n), this;
      }
      star(t, e, r, s, o = 0, n = 0) {
        return this._tick++, this._activePath.star(t, e, r, s, o, n, this._transform.clone()), this;
      }
      svg(t) {
        return this._tick++, Qg(t, this), this;
      }
      restore() {
        let t = this._stateStack.pop();
        return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
      }
      save() {
        return this._stateStack.push({ transform: this._transform.clone(), fillStyle: { ...this._fillStyle }, strokeStyle: { ...this._strokeStyle } }), this;
      }
      getTransform() {
        return this._transform;
      }
      resetTransform() {
        return this._transform.identity(), this;
      }
      rotate(t) {
        return this._transform.rotate(t), this;
      }
      scale(t, e = t) {
        return this._transform.scale(t, e), this;
      }
      setTransform(t, e, r, s, o, n) {
        return t instanceof I ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, r, s, o, n), this);
      }
      transform(t, e, r, s, o, n) {
        return t instanceof I ? (this._transform.append(t), this) : (ox.set(t, e, r, s, o, n), this._transform.append(ox), this);
      }
      translate(t, e = t) {
        return this._transform.translate(t, e), this;
      }
      clear() {
        return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
      }
      onUpdate() {
        this.dirty || (this.emit("update", this, 16), this.dirty = true, this._boundsDirty = true);
      }
      get bounds() {
        if (!this._boundsDirty) return this._bounds;
        let t = this._bounds;
        t.clear();
        for (let e = 0; e < this.instructions.length; e++) {
          let r = this.instructions[e], s = r.action;
          if (s === "fill") {
            let o = r.data;
            t.addBounds(o.path.bounds);
          } else if (s === "texture") {
            let o = r.data;
            t.addFrame(o.dx, o.dy, o.dx + o.dw, o.dy + o.dh, o.transform);
          }
          if (s === "stroke") {
            let o = r.data, n = o.style.alignment, a = o.style.width * (1 - n), c = o.path.bounds;
            t.addFrame(c.minX - a, c.minY - a, c.maxX + a, c.maxY + a);
          }
        }
        return t;
      }
      containsPoint(t) {
        if (!this.bounds.containsPoint(t.x, t.y)) return false;
        let e = this.instructions, r = false;
        for (let s = 0; s < e.length; s++) {
          let o = e[s], n = o.data, a = n.path;
          if (!o.action || !a) continue;
          let c = n.style, l = a.shapePath.shapePrimitives;
          for (let h = 0; h < l.length; h++) {
            let u = l[h].shape;
            if (!c || !u) continue;
            let f = l[h].transform, d2 = f ? f.applyInverse(t, AS) : t;
            if (o.action === "fill") r = u.contains(d2.x, d2.y);
            else {
              let g = c;
              r = u.strokeContains(d2.x, d2.y, g.width, g.alignment);
            }
            let m = n.hole;
            if (m) {
              let g = m.shapePath?.shapePrimitives;
              if (g) for (let x2 = 0; x2 < g.length; x2++) g[x2].shape.contains(d2.x, d2.y) && (r = false);
            }
            if (r) return true;
          }
        }
        return r;
      }
      destroy(t = false) {
        if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) {
          let r = typeof t == "boolean" ? t : t?.textureSource;
          this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r);
        }
        this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
      }
    };
    rh.defaultFillStyle = { color: 16777215, alpha: 1, texture: B.WHITE, matrix: null, fill: null, textureSpace: "local" };
    rh.defaultStrokeStyle = { width: 1, color: 16777215, alpha: 1, alignment: 0.5, miterLimit: 10, cap: "butt", join: "miter", texture: B.WHITE, matrix: null, fill: null, textureSpace: "local", pixelLine: false };
    Vt2 = rh;
  });
  function Xn2(i3) {
    let t = [], e = 0;
    for (let r = 0; r < nx.length; r++) {
      let s = `_${nx[r]}`;
      t[e++] = i3[s];
    }
    return e = ax(i3._fill, t, e), e = CS(i3._stroke, t, e), e = ES(i3.dropShadow, t, e), t.join("-");
  }
  function ax(i3, t, e) {
    return i3 && (t[e++] = i3.color, t[e++] = i3.alpha, t[e++] = i3.fill?.styleKey), e;
  }
  function CS(i3, t, e) {
    return i3 && (e = ax(i3, t, e), t[e++] = i3.width, t[e++] = i3.alignment, t[e++] = i3.cap, t[e++] = i3.join, t[e++] = i3.miterLimit), e;
  }
  function ES(i3, t, e) {
    return i3 && (t[e++] = i3.alpha, t[e++] = i3.angle, t[e++] = i3.blur, t[e++] = i3.distance, t[e++] = $.shared.setValue(i3.color).toNumber()), e;
  }
  var nx;
  var ih = p(() => {
    Gt2();
    nx = ["align", "breakWords", "cssOverrides", "fontVariant", "fontWeight", "leading", "letterSpacing", "lineHeight", "padding", "textBaseline", "trim", "whiteSpace", "wordWrap", "wordWrapWidth", "fontFamily", "fontStyle", "fontSize"];
  });
  function MS(i3) {
    let t = i3;
    if (typeof t.dropShadow == "boolean" && t.dropShadow) {
      let e = Pt2.defaultDropShadow;
      i3.dropShadow = { alpha: t.dropShadowAlpha ?? e.alpha, angle: t.dropShadowAngle ?? e.angle, blur: t.dropShadowBlur ?? e.blur, color: t.dropShadowColor ?? e.color, distance: t.dropShadowDistance ?? e.distance };
    }
    if (t.strokeThickness !== void 0) {
      L2(z, "strokeThickness is now a part of stroke");
      let e = t.stroke, r = {};
      if ($.isColorLike(e)) r.color = e;
      else if (e instanceof Qt2 || e instanceof Ne2) r.fill = e;
      else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill")) r = e;
      else throw new Error("Invalid stroke value.");
      i3.stroke = { ...r, width: t.strokeThickness };
    }
    if (Array.isArray(t.fillGradientStops)) {
      L2(z, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let e;
      i3.fontSize == null ? i3.fontSize = Pt2.defaultTextStyle.fontSize : typeof i3.fontSize == "string" ? e = parseInt(i3.fontSize, 10) : e = i3.fontSize;
      let r = new Qt2({ start: { x: 0, y: 0 }, end: { x: 0, y: (e || 0) * 1.7 } }), s = t.fillGradientStops.map((o) => $.shared.setValue(o).toNumber());
      s.forEach((o, n) => {
        let a = n / (s.length - 1);
        r.addColorStop(a, o);
      }), i3.fill = { fill: r };
    }
  }
  var sh;
  var Pt2;
  var Br2 = p(() => {
    Dt2();
    Gt2();
    ft2();
    oi();
    Fn2();
    Vn2();
    eh();
    ih();
    sh = class fi extends at2 {
      constructor(t = {}) {
        super(), MS(t);
        let e = { ...fi.defaultTextStyle, ...t };
        for (let r in e) {
          let s = r;
          this[s] = e[r];
        }
        this.update();
      }
      get align() {
        return this._align;
      }
      set align(t) {
        this._align = t, this.update();
      }
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(t) {
        this._breakWords = t, this.update();
      }
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(t) {
        t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({ ...fi.defaultDropShadow, ...t }) : this._dropShadow = t ? this._createProxy({ ...fi.defaultDropShadow }) : null, this.update();
      }
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(t) {
        this._fontFamily = t, this.update();
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(t) {
        typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
      }
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(t) {
        this._fontStyle = t.toLowerCase(), this.update();
      }
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(t) {
        this._fontVariant = t, this.update();
      }
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(t) {
        this._fontWeight = t, this.update();
      }
      get leading() {
        return this._leading;
      }
      set leading(t) {
        this._leading = t, this.update();
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(t) {
        this._letterSpacing = t, this.update();
      }
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(t) {
        this._lineHeight = t, this.update();
      }
      get padding() {
        return this._padding;
      }
      set padding(t) {
        this._padding = t, this.update();
      }
      get trim() {
        return this._trim;
      }
      set trim(t) {
        this._trim = t, this.update();
      }
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(t) {
        this._textBaseline = t, this.update();
      }
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(t) {
        this._whiteSpace = t, this.update();
      }
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(t) {
        this._wordWrap = t, this.update();
      }
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(t) {
        this._wordWrapWidth = t, this.update();
      }
      get fill() {
        return this._originalFill;
      }
      set fill(t) {
        t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({ ...Vt2.defaultFillStyle, ...t }, () => {
          this._fill = He2({ ...this._originalFill }, Vt2.defaultFillStyle);
        })), this._fill = He2(t === 0 ? "black" : t, Vt2.defaultFillStyle), this.update());
      }
      get stroke() {
        return this._originalStroke;
      }
      set stroke(t) {
        t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({ ...Vt2.defaultStrokeStyle, ...t }, () => {
          this._stroke = di({ ...this._originalStroke }, Vt2.defaultStrokeStyle);
        })), this._stroke = di(t, Vt2.defaultStrokeStyle), this.update());
      }
      _generateKey() {
        return this._styleKey = Xn2(this), this._styleKey;
      }
      update() {
        this._styleKey = null, this.emit("update", this);
      }
      reset() {
        let t = fi.defaultTextStyle;
        for (let e in t) this[e] = t[e];
      }
      get styleKey() {
        return this._styleKey || this._generateKey();
      }
      clone() {
        return new fi({ align: this.align, breakWords: this.breakWords, dropShadow: this._dropShadow ? { ...this._dropShadow } : null, fill: this._fill, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, leading: this.leading, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this._stroke, textBaseline: this.textBaseline, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth });
      }
      destroy(t = false) {
        if (this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) {
          let r = typeof t == "boolean" ? t : t?.textureSource;
          this._fill?.texture && this._fill.texture.destroy(r), this._originalFill?.texture && this._originalFill.texture.destroy(r), this._stroke?.texture && this._stroke.texture.destroy(r), this._originalStroke?.texture && this._originalStroke.texture.destroy(r);
        }
        this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
      }
      _createProxy(t, e) {
        return new Proxy(t, { set: (r, s, o) => (r[s] = o, e?.(s, o), this.update(), true) });
      }
      _isFillStyle(t) {
        return (t ?? null) !== null && !($.isColorLike(t) || t instanceof Qt2 || t instanceof Ne2);
      }
    };
    sh.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: "black", distance: 5 };
    sh.defaultTextStyle = { align: "left", breakWords: false, dropShadow: null, fill: "black", fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", leading: 0, letterSpacing: 0, lineHeight: 0, padding: 0, stroke: null, textBaseline: "alphabetic", trim: false, whiteSpace: "pre", wordWrap: false, wordWrapWidth: 100 };
    Pt2 = sh;
  });
  function Yn2(i3, t, e, r) {
    let s = BS;
    s.minX = 0, s.minY = 0, s.maxX = i3.width / r | 0, s.maxY = i3.height / r | 0;
    let o = pt2.getOptimalTexture(s.width, s.height, r, false);
    return o.source.uploadMethodId = "image", o.source.resource = i3, o.source.alphaMode = "premultiply-alpha-on-upload", o.frame.width = t / r, o.frame.height = e / r, o.source.emit("update", o.source), o.updateUvs(), o;
  }
  var BS;
  var oh = p(() => {
    Ve2();
    $t2();
    BS = new st2();
  });
  function Rr2(i3) {
    let t = typeof i3.fontSize == "number" ? `${i3.fontSize}px` : i3.fontSize, e = i3.fontFamily;
    Array.isArray(i3.fontFamily) || (e = i3.fontFamily.split(","));
    for (let r = e.length - 1; r >= 0; r--) {
      let s = e[r].trim();
      !/([\"\'])[^\'\"]+\1/.test(s) && !RS.includes(s) && (s = `"${s}"`), e[r] = s;
    }
    return `${i3.fontStyle} ${i3.fontVariant} ${i3.fontWeight} ${t} ${e.join(",")}`;
  }
  var RS;
  var $n2 = p(() => {
    "use strict";
    RS = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
  });
  var nh;
  var xe2;
  var it2;
  var Ss = p(() => {
    lt2();
    $n2();
    nh = { willReadFrequently: true }, xe2 = class H {
      static get experimentalLetterSpacingSupported() {
        let t = H._experimentalLetterSpacingSupported;
        if (t !== void 0) {
          let e = N.get().getCanvasRenderingContext2D().prototype;
          t = H._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
        }
        return t;
      }
      constructor(t, e, r, s, o, n, a, c, l) {
        this.text = t, this.style = e, this.width = r, this.height = s, this.lines = o, this.lineWidths = n, this.lineHeight = a, this.maxLineWidth = c, this.fontProperties = l;
      }
      static measureText(t = " ", e, r = H._canvas, s = e.wordWrap) {
        let o = `${t}:${e.styleKey}`;
        if (H._measurementCache[o]) return H._measurementCache[o];
        let n = Rr2(e), a = H.measureFont(n);
        a.fontSize === 0 && (a.fontSize = e.fontSize, a.ascent = e.fontSize);
        let c = H.__context;
        c.font = n;
        let h = (s ? H._wordWrap(t, e, r) : t).split(/(?:\r\n|\r|\n)/), u = new Array(h.length), f = 0;
        for (let y = 0; y < h.length; y++) {
          let v = H._measureText(h[y], e.letterSpacing, c);
          u[y] = v, f = Math.max(f, v);
        }
        let d2 = e._stroke?.width || 0, m = f + d2;
        e.dropShadow && (m += e.dropShadow.distance);
        let g = e.lineHeight || a.fontSize, x2 = Math.max(g, a.fontSize + d2) + (h.length - 1) * (g + e.leading);
        return e.dropShadow && (x2 += e.dropShadow.distance), new H(t, e, m, x2, h, u, g + e.leading, f, a);
      }
      static _measureText(t, e, r) {
        let s = false;
        H.experimentalLetterSpacingSupported && (H.experimentalLetterSpacing ? (r.letterSpacing = `${e}px`, r.textLetterSpacing = `${e}px`, s = true) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
        let o = r.measureText(t), n = o.width, a = -o.actualBoundingBoxLeft, l = o.actualBoundingBoxRight - a;
        if (n > 0) if (s) n -= e, l -= e;
        else {
          let h = (H.graphemeSegmenter(t).length - 1) * e;
          n += h, l += h;
        }
        return Math.max(n, l);
      }
      static _wordWrap(t, e, r = H._canvas) {
        let s = r.getContext("2d", nh), o = 0, n = "", a = "", c = /* @__PURE__ */ Object.create(null), { letterSpacing: l, whiteSpace: h } = e, u = H._collapseSpaces(h), f = H._collapseNewlines(h), d2 = !u, m = e.wordWrapWidth + l, g = H._tokenize(t);
        for (let x2 = 0; x2 < g.length; x2++) {
          let b = g[x2];
          if (H._isNewline(b)) {
            if (!f) {
              a += H._addLine(n), d2 = !u, n = "", o = 0;
              continue;
            }
            b = " ";
          }
          if (u) {
            let v = H.isBreakingSpace(b), T2 = H.isBreakingSpace(n[n.length - 1]);
            if (v && T2) continue;
          }
          let y = H._getFromCache(b, l, c, s);
          if (y > m) if (n !== "" && (a += H._addLine(n), n = "", o = 0), H.canBreakWords(b, e.breakWords)) {
            let v = H.wordWrapSplit(b);
            for (let T2 = 0; T2 < v.length; T2++) {
              let P = v[T2], w = P, C = 1;
              for (; v[T2 + C]; ) {
                let M2 = v[T2 + C];
                if (!H.canBreakChars(w, M2, b, T2, e.breakWords)) P += M2;
                else break;
                w = M2, C++;
              }
              T2 += C - 1;
              let G2 = H._getFromCache(P, l, c, s);
              G2 + o > m && (a += H._addLine(n), d2 = false, n = "", o = 0), n += P, o += G2;
            }
          } else {
            n.length > 0 && (a += H._addLine(n), n = "", o = 0);
            let v = x2 === g.length - 1;
            a += H._addLine(b, !v), d2 = false, n = "", o = 0;
          }
          else y + o > m && (d2 = false, a += H._addLine(n), n = "", o = 0), (n.length > 0 || !H.isBreakingSpace(b) || d2) && (n += b, o += y);
        }
        return a += H._addLine(n, false), a;
      }
      static _addLine(t, e = true) {
        return t = H._trimRight(t), t = e ? `${t}
` : t, t;
      }
      static _getFromCache(t, e, r, s) {
        let o = r[t];
        return typeof o != "number" && (o = H._measureText(t, e, s) + e, r[t] = o), o;
      }
      static _collapseSpaces(t) {
        return t === "normal" || t === "pre-line";
      }
      static _collapseNewlines(t) {
        return t === "normal";
      }
      static _trimRight(t) {
        if (typeof t != "string") return "";
        for (let e = t.length - 1; e >= 0; e--) {
          let r = t[e];
          if (!H.isBreakingSpace(r)) break;
          t = t.slice(0, -1);
        }
        return t;
      }
      static _isNewline(t) {
        return typeof t != "string" ? false : H._newlines.includes(t.charCodeAt(0));
      }
      static isBreakingSpace(t, e) {
        return typeof t != "string" ? false : H._breakingSpaces.includes(t.charCodeAt(0));
      }
      static _tokenize(t) {
        let e = [], r = "";
        if (typeof t != "string") return e;
        for (let s = 0; s < t.length; s++) {
          let o = t[s], n = t[s + 1];
          if (H.isBreakingSpace(o, n) || H._isNewline(o)) {
            r !== "" && (e.push(r), r = ""), e.push(o);
            continue;
          }
          r += o;
        }
        return r !== "" && e.push(r), e;
      }
      static canBreakWords(t, e) {
        return e;
      }
      static canBreakChars(t, e, r, s, o) {
        return true;
      }
      static wordWrapSplit(t) {
        return H.graphemeSegmenter(t);
      }
      static measureFont(t) {
        if (H._fonts[t]) return H._fonts[t];
        let e = H._context;
        e.font = t;
        let r = e.measureText(H.METRICS_STRING + H.BASELINE_SYMBOL), s = { ascent: r.actualBoundingBoxAscent, descent: r.actualBoundingBoxDescent, fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent };
        return H._fonts[t] = s, s;
      }
      static clearMetrics(t = "") {
        t ? delete H._fonts[t] : H._fonts = {};
      }
      static get _canvas() {
        if (!H.__canvas) {
          let t;
          try {
            let e = new OffscreenCanvas(0, 0);
            if (e.getContext("2d", nh)?.measureText) return H.__canvas = e, e;
            t = N.get().createCanvas();
          } catch {
            t = N.get().createCanvas();
          }
          t.width = t.height = 10, H.__canvas = t;
        }
        return H.__canvas;
      }
      static get _context() {
        return H.__context || (H.__context = H._canvas.getContext("2d", nh)), H.__context;
      }
    };
    xe2.METRICS_STRING = "|\xC9q\xC5";
    xe2.BASELINE_SYMBOL = "M";
    xe2.BASELINE_MULTIPLIER = 1.4;
    xe2.HEIGHT_MULTIPLIER = 2;
    xe2.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter == "function") {
        let i3 = new Intl.Segmenter();
        return (t) => [...i3.segment(t)].map((e) => e.segment);
      }
      return (i3) => [...i3];
    })();
    xe2.experimentalLetterSpacing = false;
    xe2._fonts = {};
    xe2._newlines = [10, 13];
    xe2._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
    xe2._measurementCache = {};
    it2 = xe2;
  });
  function pi(i3, t, e, r = 0) {
    if (i3.texture === B.WHITE && !i3.fill) return $.shared.setValue(i3.color).setAlpha(i3.alpha ?? 1).toHexa();
    if (i3.fill) {
      if (i3.fill instanceof Ne2) {
        let s = i3.fill, o = t.createPattern(s.texture.source.resource, "repeat"), n = s.transform.copyTo(I.shared);
        return n.scale(s.texture.frame.width, s.texture.frame.height), o.setTransform(n), o;
      } else if (i3.fill instanceof Qt2) {
        let s = i3.fill, o = s.type === "linear", n = s.textureSpace === "local", a = 1, c = 1;
        n && e && (a = e.width + r, c = e.height + r);
        let l, h = false;
        if (o) {
          let { start: u, end: f } = s;
          l = t.createLinearGradient(u.x * a, u.y * c, f.x * a, f.y * c), h = Math.abs(f.x - u.x) < Math.abs((f.y - u.y) * 0.1);
        } else {
          let { center: u, innerRadius: f, outerCenter: d2, outerRadius: m } = s;
          l = t.createRadialGradient(u.x * a, u.y * c, f * a, d2.x * a, d2.y * c, m * a);
        }
        if (h && n && e) {
          let u = e.lineHeight / c;
          for (let f = 0; f < e.lines.length; f++) {
            let d2 = (f * e.lineHeight + r / 2) / c;
            s.colorStops.forEach((m) => {
              let g = d2 + m.offset * u;
              l.addColorStop(Math.floor(g * cx) / cx, $.shared.setValue(m.color).toHex());
            });
          }
        } else s.colorStops.forEach((u) => {
          l.addColorStop(u.offset, $.shared.setValue(u.color).toHex());
        });
        return l;
      }
    } else {
      let s = t.createPattern(i3.texture.source.resource, "repeat"), o = i3.matrix.copyTo(I.shared);
      return o.scale(i3.texture.frame.width, i3.texture.frame.height), s.setTransform(o), s;
    }
    return O2("FillStyle not recognised", i3), "red";
  }
  var cx;
  var ah = p(() => {
    Gt2();
    Q2();
    rt2();
    ot2();
    oi();
    Fn2();
    cx = 1e5;
  });
  var ws;
  var lx = p(() => {
    Gt2();
    E();
    zi();
    li();
    Ve2();
    vg();
    ft2();
    Br2();
    oh();
    Ss();
    $n2();
    ah();
    ws = class {
      constructor(t) {
        this._activeTextures = {}, this._renderer = t;
      }
      getTextureSize(t, e, r) {
        let s = it2.measureText(t || " ", r), o = Math.ceil(Math.ceil(Math.max(1, s.width) + r.padding * 2) * e), n = Math.ceil(Math.ceil(Math.max(1, s.height) + r.padding * 2) * e);
        return o = Math.ceil(o - 1e-6), n = Math.ceil(n - 1e-6), o = ke2(o), n = ke2(n), { width: o, height: n };
      }
      getTexture(t, e, r, s) {
        typeof t == "string" && (L2("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), t = { text: t, style: r, resolution: e }), t.style instanceof Pt2 || (t.style = new Pt2(t.style));
        let { texture: o, canvasAndContext: n } = this.createTextureAndCanvas(t);
        return this._renderer.texture.initSource(o._source), Jt2.returnCanvasAndContext(n), o;
      }
      createTextureAndCanvas(t) {
        let { text: e, style: r } = t, s = t.resolution ?? this._renderer.resolution, o = it2.measureText(e || " ", r), n = Math.ceil(Math.ceil(Math.max(1, o.width) + r.padding * 2) * s), a = Math.ceil(Math.ceil(Math.max(1, o.height) + r.padding * 2) * s), c = Jt2.getOptimalCanvasAndContext(n, a), { canvas: l } = c;
        this.renderTextToCanvas(e, r, s, c);
        let h = Yn2(l, n, a, s);
        if (r.trim) {
          let u = bg(l, s);
          h.frame.copyFrom(u), h.updateUvs();
        }
        return { texture: h, canvasAndContext: c };
      }
      getManagedTexture(t) {
        t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution;
        let e = t._getKey();
        if (this._activeTextures[e]) return this._increaseReferenceCount(e), this._activeTextures[e].texture;
        let { texture: r, canvasAndContext: s } = this.createTextureAndCanvas(t);
        return this._activeTextures[e] = { canvasAndContext: s, texture: r, usageCount: 1 }, r;
      }
      _increaseReferenceCount(t) {
        this._activeTextures[t].usageCount++;
      }
      returnTexture(t) {
        let e = t.source;
        e.resource = null, e.uploadMethodId = "unknown", e.alphaMode = "no-premultiply-alpha", pt2.returnTexture(t);
      }
      decreaseReferenceCount(t) {
        let e = this._activeTextures[t];
        e.usageCount--, e.usageCount === 0 && (Jt2.returnCanvasAndContext(e.canvasAndContext), this.returnTexture(e.texture), this._activeTextures[t] = null);
      }
      getReferenceCount(t) {
        return this._activeTextures[t].usageCount;
      }
      renderTextToCanvas(t, e, r, s) {
        let { canvas: o, context: n } = s, a = Rr2(e), c = it2.measureText(t || " ", e), l = c.lines, h = c.lineHeight, u = c.lineWidths, f = c.maxLineWidth, d2 = c.fontProperties, m = o.height;
        if (n.resetTransform(), n.scale(r, r), n.textBaseline = e.textBaseline, e._stroke?.width) {
          let y = e._stroke;
          n.lineWidth = y.width, n.miterLimit = y.miterLimit, n.lineJoin = y.join, n.lineCap = y.cap;
        }
        n.font = a;
        let g, x2, b = e.dropShadow ? 2 : 1;
        for (let y = 0; y < b; ++y) {
          let v = e.dropShadow && y === 0, T2 = v ? Math.ceil(Math.max(1, m) + e.padding * 2) : 0, P = T2 * r;
          if (v) {
            n.fillStyle = "black", n.strokeStyle = "black";
            let G2 = e.dropShadow, M2 = G2.color, S2 = G2.alpha;
            n.shadowColor = $.shared.setValue(M2).setAlpha(S2).toRgbaString();
            let A2 = G2.blur * r, R2 = G2.distance * r;
            n.shadowBlur = A2, n.shadowOffsetX = Math.cos(G2.angle) * R2, n.shadowOffsetY = Math.sin(G2.angle) * R2 + P;
          } else {
            if (n.fillStyle = e._fill ? pi(e._fill, n, c) : null, e._stroke?.width) {
              let G2 = e._stroke.width * e._stroke.alignment;
              n.strokeStyle = pi(e._stroke, n, c, G2);
            }
            n.shadowColor = "black";
          }
          let w = (h - d2.fontSize) / 2;
          h - d2.fontSize < 0 && (w = 0);
          let C = e._stroke?.width ?? 0;
          for (let G2 = 0; G2 < l.length; G2++) g = C / 2, x2 = C / 2 + G2 * h + d2.ascent + w, e.align === "right" ? g += f - u[G2] : e.align === "center" && (g += (f - u[G2]) / 2), e._stroke?.width && this._drawLetterSpacing(l[G2], e, s, g + e.padding, x2 + e.padding - T2, true), e._fill !== void 0 && this._drawLetterSpacing(l[G2], e, s, g + e.padding, x2 + e.padding - T2);
        }
      }
      _drawLetterSpacing(t, e, r, s, o, n = false) {
        let { context: a } = r, c = e.letterSpacing, l = false;
        if (it2.experimentalLetterSpacingSupported && (it2.experimentalLetterSpacing ? (a.letterSpacing = `${c}px`, a.textLetterSpacing = `${c}px`, l = true) : (a.letterSpacing = "0px", a.textLetterSpacing = "0px")), c === 0 || l) {
          n ? a.strokeText(t, s, o) : a.fillText(t, s, o);
          return;
        }
        let h = s, u = it2.graphemeSegmenter(t), f = a.measureText(t).width, d2 = 0;
        for (let m = 0; m < u.length; ++m) {
          let g = u[m];
          n ? a.strokeText(g, h, o) : a.fillText(g, h, o);
          let x2 = "";
          for (let b = m + 1; b < u.length; ++b) x2 += u[b];
          d2 = a.measureText(x2).width, h += f - d2 + c, f = d2;
        }
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    ws.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "canvasText" };
  });
  var ch = p(() => {
    E();
    xg();
    lx();
    U2.add(ws);
    U2.add(bs);
  });
  var Xt2;
  var lh = p(() => {
    ft2();
    rn2();
    Vn2();
    Xt2 = class i3 extends $e2 {
      constructor(t) {
        t instanceof Vt2 && (t = { context: t });
        let { context: e, roundPixels: r, ...s } = t || {};
        super({ label: "Graphics", ...s }), this.renderPipeId = "graphics", e ? this._context = e : this._context = this._ownedContext = new Vt2(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = false, this.roundPixels = r ?? false;
      }
      set context(t) {
        t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
      }
      get context() {
        return this._context;
      }
      get bounds() {
        return this._context.bounds;
      }
      updateBounds() {
      }
      containsPoint(t) {
        return this._context.containsPoint(t);
      }
      destroy(t) {
        this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === true || t?.context === true) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
      }
      _callContextMethod(t, e) {
        return this.context[t](...e), this;
      }
      setFillStyle(...t) {
        return this._callContextMethod("setFillStyle", t);
      }
      setStrokeStyle(...t) {
        return this._callContextMethod("setStrokeStyle", t);
      }
      fill(...t) {
        return this._callContextMethod("fill", t);
      }
      stroke(...t) {
        return this._callContextMethod("stroke", t);
      }
      texture(...t) {
        return this._callContextMethod("texture", t);
      }
      beginPath() {
        return this._callContextMethod("beginPath", []);
      }
      cut() {
        return this._callContextMethod("cut", []);
      }
      arc(...t) {
        return this._callContextMethod("arc", t);
      }
      arcTo(...t) {
        return this._callContextMethod("arcTo", t);
      }
      arcToSvg(...t) {
        return this._callContextMethod("arcToSvg", t);
      }
      bezierCurveTo(...t) {
        return this._callContextMethod("bezierCurveTo", t);
      }
      closePath() {
        return this._callContextMethod("closePath", []);
      }
      ellipse(...t) {
        return this._callContextMethod("ellipse", t);
      }
      circle(...t) {
        return this._callContextMethod("circle", t);
      }
      path(...t) {
        return this._callContextMethod("path", t);
      }
      lineTo(...t) {
        return this._callContextMethod("lineTo", t);
      }
      moveTo(...t) {
        return this._callContextMethod("moveTo", t);
      }
      quadraticCurveTo(...t) {
        return this._callContextMethod("quadraticCurveTo", t);
      }
      rect(...t) {
        return this._callContextMethod("rect", t);
      }
      roundRect(...t) {
        return this._callContextMethod("roundRect", t);
      }
      poly(...t) {
        return this._callContextMethod("poly", t);
      }
      regularPoly(...t) {
        return this._callContextMethod("regularPoly", t);
      }
      roundPoly(...t) {
        return this._callContextMethod("roundPoly", t);
      }
      roundShape(...t) {
        return this._callContextMethod("roundShape", t);
      }
      filletRect(...t) {
        return this._callContextMethod("filletRect", t);
      }
      chamferRect(...t) {
        return this._callContextMethod("chamferRect", t);
      }
      star(...t) {
        return this._callContextMethod("star", t);
      }
      svg(...t) {
        return this._callContextMethod("svg", t);
      }
      restore(...t) {
        return this._callContextMethod("restore", t);
      }
      save() {
        return this._callContextMethod("save", []);
      }
      getTransform() {
        return this.context.getTransform();
      }
      resetTransform() {
        return this._callContextMethod("resetTransform", []);
      }
      rotateTransform(...t) {
        return this._callContextMethod("rotate", t);
      }
      scaleTransform(...t) {
        return this._callContextMethod("scale", t);
      }
      setTransform(...t) {
        return this._callContextMethod("setTransform", t);
      }
      transform(...t) {
        return this._callContextMethod("transform", t);
      }
      translateTransform(...t) {
        return this._callContextMethod("translate", t);
      }
      clear() {
        return this._callContextMethod("clear", []);
      }
      get fillStyle() {
        return this._context.fillStyle;
      }
      set fillStyle(t) {
        this._context.fillStyle = t;
      }
      get strokeStyle() {
        return this._context.strokeStyle;
      }
      set strokeStyle(t) {
        this._context.strokeStyle = t;
      }
      clone(t = false) {
        return t ? new i3(this._context.clone()) : (this._ownedContext = null, new i3(this._context));
      }
      lineStyle(t, e, r) {
        L2(z, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
        let s = {};
        return t && (s.width = t), e && (s.color = e), r && (s.alpha = r), this.context.strokeStyle = s, this;
      }
      beginFill(t, e) {
        L2(z, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        let r = {};
        return t !== void 0 && (r.color = t), e !== void 0 && (r.alpha = e), this.context.fillStyle = r, this;
      }
      endFill() {
        L2(z, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
        let t = this.context.strokeStyle;
        return (t.width !== Vt2.defaultStrokeStyle.width || t.color !== Vt2.defaultStrokeStyle.color || t.alpha !== Vt2.defaultStrokeStyle.alpha) && this.context.stroke(), this;
      }
      drawCircle(...t) {
        return L2(z, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
      }
      drawEllipse(...t) {
        return L2(z, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
      }
      drawPolygon(...t) {
        return L2(z, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
      }
      drawRect(...t) {
        return L2(z, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
      }
      drawRoundedRect(...t) {
        return L2(z, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
      }
      drawStar(...t) {
        return L2(z, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
      }
    };
  });
  var hx;
  var ux;
  var dx = p(() => {
    "use strict";
    hx = { name: "local-uniform-msdf-bit", vertex: { header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `, main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `, end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        ` }, fragment: { header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `, main: ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        ` } }, ux = { name: "local-uniform-msdf-bit", vertex: { header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `, main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `, end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        ` }, fragment: { header: `
            uniform float uDistance;
         `, main: ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        ` } };
  });
  var fx;
  var px;
  var mx = p(() => {
    "use strict";
    fx = { name: "msdf-bit", fragment: { header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        ` } }, px = { name: "msdf-bit", fragment: { header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        ` } };
  });
  var hh;
  var uh;
  var jn2;
  var gx = p(() => {
    Q2();
    Tr2();
    Qe2();
    cs();
    ls();
    Je2();
    vn2();
    me2();
    zt2();
    dx();
    mx();
    jn2 = class extends yt2 {
      constructor() {
        let t = new nt2({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new I(), type: "mat3x3<f32>" }, uDistance: { value: 4, type: "f32" }, uRound: { value: 0, type: "f32" } }), e = ne2();
        hh ?? (hh = Te2({ name: "sdf-shader", bits: [Qr2, ti2(e), hx, fx, we2] })), uh ?? (uh = Se2({ name: "sdf-shader", bits: [Jr2, ei2(e), ux, px, Pe2] })), super({ glProgram: uh, gpuProgram: hh, resources: { localUniforms: t, batchSamplers: ri(e) } });
      }
    };
  });
  var mi;
  var dh = p(() => {
    Dt2();
    ft2();
    mi = class extends at2 {
      constructor() {
        super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = true, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
      }
      get font() {
        return L2(z, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
      }
      get pageTextures() {
        return L2(z, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
      }
      get size() {
        return L2(z, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
      }
      get distanceFieldRange() {
        return L2(z, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
      }
      get distanceFieldType() {
        return L2(z, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
      }
      destroy(t = false) {
        this.emit("destroy", this), this.removeAllListeners();
        for (let e in this.chars) this.chars[e].texture?.destroy();
        this.chars = null, t && (this.pages.forEach((e) => e.texture.destroy(true)), this.pages = null);
      }
    };
  });
  function Kn2(i3) {
    if (i3 === "") return [];
    typeof i3 == "string" && (i3 = [i3]);
    let t = [];
    for (let e = 0, r = i3.length; e < r; e++) {
      let s = i3[e];
      if (Array.isArray(s)) {
        if (s.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);
        if (s[0].length === 0 || s[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter.");
        let o = s[0].charCodeAt(0), n = s[1].charCodeAt(0);
        if (n < o) throw new Error("[BitmapFont]: Invalid character range.");
        for (let a = o, c = n; a <= c; a++) t.push(String.fromCharCode(a));
      } else t.push(...Array.from(s));
    }
    if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t;
  }
  var fh = p(() => {
    "use strict";
  });
  var xx;
  var ph;
  var yx = p(() => {
    Gt2();
    St2();
    li();
    Xr2();
    rt2();
    ft2();
    Ss();
    $n2();
    ah();
    Br2();
    dh();
    fh();
    xx = class _x extends mi {
      constructor(t) {
        super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = false;
        let e = { ..._x.defaultOptions, ...t };
        this._textureSize = e.textureSize, this._mipmap = e.mipmap;
        let r = e.style.clone();
        e.overrideFill && (r._fill.color = 16777215, r._fill.alpha = 1, r._fill.texture = B.WHITE, r._fill.fill = null), this.applyFillAsTint = e.overrideFill;
        let s = r.fontSize;
        r.fontSize = this.baseMeasurementFontSize;
        let o = Rr2(r);
        e.overrideSize ? r._stroke && (r._stroke.width *= this.baseRenderedFontSize / s) : r.fontSize = this.baseRenderedFontSize = s, this._style = r, this._skipKerning = e.skipKerning ?? false, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, this.fontMetrics = it2.measureFont(o), this.lineHeight = r.lineHeight || this.fontMetrics.fontSize || r.fontSize;
      }
      ensureCharacters(t) {
        let e = Kn2(t).filter((x2) => !this._currentChars.includes(x2)).filter((x2, b, y) => y.indexOf(x2) === b);
        if (!e.length) return;
        this._currentChars = [...this._currentChars, ...e];
        let r;
        this._currentPageIndex === -1 ? r = this._nextPage() : r = this.pages[this._currentPageIndex];
        let { canvas: s, context: o } = r.canvasAndContext, n = r.texture.source, a = this._style, c = this._currentX, l = this._currentY, h = this.baseRenderedFontSize / this.baseMeasurementFontSize, u = this._padding * h, f = 0, d2 = false, m = s.width / this.resolution, g = s.height / this.resolution;
        for (let x2 = 0; x2 < e.length; x2++) {
          let b = e[x2], y = it2.measureText(b, a, s, false);
          y.lineHeight = y.height;
          let v = y.width * h, T2 = Math.ceil((a.fontStyle === "italic" ? 2 : 1) * v), P = y.height * h, w = T2 + u * 2, C = P + u * 2;
          if (d2 = false, b !== `
` && b !== "\r" && b !== "	" && b !== " " && (d2 = true, f = Math.ceil(Math.max(C, f))), c + w > m && (l += f, f = C, c = 0, l + f > g)) {
            n.update();
            let M2 = this._nextPage();
            s = M2.canvasAndContext.canvas, o = M2.canvasAndContext.context, n = M2.texture.source, l = 0;
          }
          let G2 = v / h - (a.dropShadow?.distance ?? 0) - (a._stroke?.width ?? 0);
          if (this.chars[b] = { id: b.codePointAt(0), xOffset: -this._padding, yOffset: -this._padding, xAdvance: G2, kerning: {} }, d2) {
            this._drawGlyph(o, y, c + u, l + u, h, a);
            let M2 = n.width * h, S2 = n.height * h, A2 = new Y2(c / M2 * n.width, l / S2 * n.height, w / M2 * n.width, C / S2 * n.height);
            this.chars[b].texture = new B({ source: n, frame: A2 }), c += Math.ceil(w);
          }
        }
        n.update(), this._currentX = c, this._currentY = l, this._skipKerning && this._applyKerning(e, o);
      }
      get pageTextures() {
        return L2(z, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
      }
      _applyKerning(t, e) {
        let r = this._measureCache;
        for (let s = 0; s < t.length; s++) {
          let o = t[s];
          for (let n = 0; n < this._currentChars.length; n++) {
            let a = this._currentChars[n], c = r[o];
            c || (c = r[o] = e.measureText(o).width);
            let l = r[a];
            l || (l = r[a] = e.measureText(a).width);
            let h = e.measureText(o + a).width, u = h - (c + l);
            u && (this.chars[o].kerning[a] = u), h = e.measureText(o + a).width, u = h - (c + l), u && (this.chars[a].kerning[o] = u);
          }
        }
      }
      _nextPage() {
        this._currentPageIndex++;
        let t = this.resolution, e = Jt2.getOptimalCanvasAndContext(this._textureSize, this._textureSize, t);
        this._setupContext(e.context, this._style, t);
        let r = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), s = new B({ source: new qt2({ resource: e.canvas, resolution: r, alphaMode: "premultiply-alpha-on-upload", autoGenerateMipmaps: this._mipmap }) }), o = { canvasAndContext: e, texture: s };
        return this.pages[this._currentPageIndex] = o, o;
      }
      _setupContext(t, e, r) {
        e.fontSize = this.baseRenderedFontSize, t.scale(r, r), t.font = Rr2(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline;
        let s = e._stroke, o = s?.width ?? 0;
        if (s && (t.lineWidth = o, t.lineJoin = s.join, t.miterLimit = s.miterLimit, t.strokeStyle = pi(s, t)), e._fill && (t.fillStyle = pi(e._fill, t)), e.dropShadow) {
          let n = e.dropShadow, a = $.shared.setValue(n.color).toArray(), c = n.blur * r, l = n.distance * r;
          t.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${n.alpha})`, t.shadowBlur = c, t.shadowOffsetX = Math.cos(n.angle) * l, t.shadowOffsetY = Math.sin(n.angle) * l;
        } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
      }
      _drawGlyph(t, e, r, s, o, n) {
        let a = e.text, c = e.fontProperties, h = (n._stroke?.width ?? 0) * o, u = r + h / 2, f = s - h / 2, d2 = c.descent * o, m = e.lineHeight * o;
        n.stroke && h && t.strokeText(a, u, f + m - d2), n._fill && t.fillText(a, u, f + m - d2);
      }
      destroy() {
        super.destroy();
        for (let t = 0; t < this.pages.length; t++) {
          let { canvasAndContext: e, texture: r } = this.pages[t];
          Jt2.returnCanvasAndContext(e), r.destroy(true);
        }
        this.pages = null;
      }
    };
    xx.defaultOptions = { textureSize: 512, style: new Pt2(), mipmap: true };
    ph = xx;
  });
  function qn2(i3, t, e, r) {
    let s = { width: 0, height: 0, offsetY: 0, scale: t.fontSize / e.baseMeasurementFontSize, lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }] };
    s.offsetY = e.baseLineOffset;
    let o = s.lines[0], n = null, a = true, c = { spaceWord: false, width: 0, start: 0, index: 0, positions: [], chars: [] }, l = (m) => {
      let g = o.width;
      for (let x2 = 0; x2 < c.index; x2++) {
        let b = m.positions[x2];
        o.chars.push(m.chars[x2]), o.charPositions.push(b + g);
      }
      o.width += m.width, a = false, c.width = 0, c.index = 0, c.chars.length = 0;
    }, h = () => {
      let m = o.chars.length - 1;
      if (r) {
        let g = o.chars[m];
        for (; g === " "; ) o.width -= e.chars[g].xAdvance, g = o.chars[--m];
      }
      s.width = Math.max(s.width, o.width), o = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }, a = true, s.lines.push(o), s.height += e.lineHeight;
    }, u = e.baseMeasurementFontSize / t.fontSize, f = t.letterSpacing * u, d2 = t.wordWrapWidth * u;
    for (let m = 0; m < i3.length + 1; m++) {
      let g, x2 = m === i3.length;
      x2 || (g = i3[m]);
      let b = e.chars[g] || e.chars[" "];
      if (/(?:\s)/.test(g) || g === "\r" || g === `
` || x2) {
        if (!a && t.wordWrap && o.width + c.width - f > d2 ? (h(), l(c), x2 || o.charPositions.push(0)) : (c.start = o.width, l(c), x2 || o.charPositions.push(0)), g === "\r" || g === `
`) o.width !== 0 && h();
        else if (!x2) {
          let P = b.xAdvance + (b.kerning[n] || 0) + f;
          o.width += P, o.spaceWidth = P, o.spacesIndex.push(o.charPositions.length), o.chars.push(g);
        }
      } else {
        let T2 = b.kerning[n] || 0, P = b.xAdvance + T2 + f;
        c.positions[c.index++] = c.width + T2, c.chars.push(g), c.width += P;
      }
      n = g;
    }
    return h(), t.align === "center" ? GS(s) : t.align === "right" ? kS(s) : t.align === "justify" && IS(s), s;
  }
  function GS(i3) {
    for (let t = 0; t < i3.lines.length; t++) {
      let e = i3.lines[t], r = i3.width / 2 - e.width / 2;
      for (let s = 0; s < e.charPositions.length; s++) e.charPositions[s] += r;
    }
  }
  function kS(i3) {
    for (let t = 0; t < i3.lines.length; t++) {
      let e = i3.lines[t], r = i3.width - e.width;
      for (let s = 0; s < e.charPositions.length; s++) e.charPositions[s] += r;
    }
  }
  function IS(i3) {
    let t = i3.width;
    for (let e = 0; e < i3.lines.length; e++) {
      let r = i3.lines[e], s = 0, o = r.spacesIndex[s++], n = 0, a = r.spacesIndex.length, l = (t - r.width) / a;
      for (let h = 0; h < r.charPositions.length; h++) h === o && (o = r.spacesIndex[s++], n += l), r.charPositions[h] += n;
    }
  }
  var mh = p(() => {
    "use strict";
  });
  var Zn2;
  var gh;
  var Ps;
  var xh = p(() => {
    je2();
    ft2();
    ot2();
    Br2();
    yx();
    mh();
    fh();
    Zn2 = 0, gh = class {
      constructor() {
        this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = { chars: this.ALPHANUMERIC, resolution: 1, padding: 4, skipKerning: false };
      }
      getFont(t, e) {
        let r = `${e.fontFamily}-bitmap`, s = true;
        if (e._fill.fill && !e._stroke) r += e._fill.fill.styleKey, s = false;
        else if (e._stroke || e.dropShadow) {
          let n = e.styleKey;
          n = n.substring(0, n.lastIndexOf("-")), r = `${n}-bitmap`, s = false;
        }
        if (!tt2.has(r)) {
          let n = new ph({ style: e, overrideFill: s, overrideSize: true, ...this.defaultOptions });
          Zn2++, Zn2 > 50 && O2("BitmapText", `You have dynamically created ${Zn2} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), n.once("destroy", () => {
            Zn2--, tt2.remove(r);
          }), tt2.set(r, n);
        }
        let o = tt2.get(r);
        return o.ensureCharacters?.(t), o;
      }
      getLayout(t, e, r = true) {
        let s = this.getFont(t, e);
        return qn2([...t], e, s, r);
      }
      measureText(t, e, r = true) {
        return this.getLayout(t, e, r);
      }
      install(...t) {
        let e = t[0];
        typeof e == "string" && (e = { name: e, style: t[1], chars: t[2]?.chars, resolution: t[2]?.resolution, padding: t[2]?.padding, skipKerning: t[2]?.skipKerning }, L2(z, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
        let r = e?.name;
        if (!r) throw new Error("[BitmapFontManager] Property `name` is required.");
        e = { ...this.defaultOptions, ...e };
        let s = e.style, o = s instanceof Pt2 ? s : new Pt2(s), n = o._fill.fill !== null && o._fill.fill !== void 0, a = new ph({ style: o, overrideFill: n, skipKerning: e.skipKerning, padding: e.padding, resolution: e.resolution, overrideSize: false }), c = Kn2(e.chars);
        return a.ensureCharacters(c.join("")), tt2.set(`${r}-bitmap`, a), a.once("destroy", () => tt2.remove(`${r}-bitmap`)), a;
      }
      uninstall(t) {
        let e = `${t}-bitmap`, r = tt2.get(e);
        r && r.destroy();
      }
    }, Ps = new gh();
  });
  function bx(i3, t) {
    t.groupTransform = i3.groupTransform, t.groupColorAlpha = i3.groupColorAlpha, t.groupColor = i3.groupColor, t.groupBlendMode = i3.groupBlendMode, t.globalDisplayStatus = i3.globalDisplayStatus, t.groupTransform = i3.groupTransform, t.localDisplayStatus = i3.localDisplayStatus, t.groupAlpha = i3.groupAlpha, t._roundPixels = i3._roundPixels;
  }
  var As;
  var vx = p(() => {
    je2();
    E();
    Nt2();
    lh();
    gx();
    xh();
    mh();
    As = class {
      constructor(t) {
        this._gpuBitmapText = {}, this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText");
      }
      validateRenderable(t) {
        let e = this._getGpuBitmapText(t);
        return t._didTextUpdate && (t._didTextUpdate = false, this._updateContext(t, e)), this._renderer.renderPipes.graphics.validateRenderable(e);
      }
      addRenderable(t, e) {
        let r = this._getGpuBitmapText(t);
        bx(t, r), t._didTextUpdate && (t._didTextUpdate = false, this._updateContext(t, r)), this._renderer.renderPipes.graphics.addRenderable(r, e), r.context.customShader && this._updateDistanceField(t);
      }
      destroyRenderable(t) {
        t.off("destroyed", this._destroyRenderableBound), this._destroyRenderableByUid(t.uid);
      }
      _destroyRenderableByUid(t) {
        let e = this._gpuBitmapText[t].context;
        e.customShader && (V2.return(e.customShader), e.customShader = null), V2.return(this._gpuBitmapText[t]), this._gpuBitmapText[t] = null;
      }
      updateRenderable(t) {
        let e = this._getGpuBitmapText(t);
        bx(t, e), this._renderer.renderPipes.graphics.updateRenderable(e), e.context.customShader && this._updateDistanceField(t);
      }
      _updateContext(t, e) {
        let { context: r } = e, s = Ps.getFont(t.text, t._style);
        r.clear(), s.distanceField.type !== "none" && (r.customShader || (r.customShader = V2.get(jn2)));
        let o = Array.from(t.text), n = t._style, a = s.baseLineOffset, c = qn2(o, n, s, true), l = 0, h = n.padding, u = c.scale, f = c.width, d2 = c.height + c.offsetY;
        n._stroke && (f += n._stroke.width / u, d2 += n._stroke.width / u), r.translate(-t._anchor._x * f - h, -t._anchor._y * d2 - h).scale(u, u);
        let m = s.applyFillAsTint ? n._fill.color : 16777215;
        for (let g = 0; g < c.lines.length; g++) {
          let x2 = c.lines[g];
          for (let b = 0; b < x2.charPositions.length; b++) {
            let y = o[l++], v = s.chars[y];
            v?.texture && r.texture(v.texture, m || "black", Math.round(x2.charPositions[b] + v.xOffset), Math.round(a + v.yOffset));
          }
          a += s.lineHeight;
        }
      }
      _getGpuBitmapText(t) {
        return this._gpuBitmapText[t.uid] || this.initGpuText(t);
      }
      initGpuText(t) {
        let e = V2.get(Xt2);
        return this._gpuBitmapText[t.uid] = e, this._updateContext(t, e), t.on("destroyed", this._destroyRenderableBound), this._gpuBitmapText[t.uid];
      }
      _updateDistanceField(t) {
        let e = this._getGpuBitmapText(t).context, r = t._style.fontFamily, s = tt2.get(`${r}-bitmap`), { a: o, b: n, c: a, d: c } = t.groupTransform, l = Math.sqrt(o * o + n * n), h = Math.sqrt(a * a + c * c), u = (Math.abs(l) + Math.abs(h)) / 2, f = s.baseRenderedFontSize / t._style.fontSize, d2 = u * s.distanceField.range * (1 / f);
        e.customShader.resources.localUniforms.uniforms.uDistance = d2;
      }
      destroy() {
        for (let t in this._gpuBitmapText) this._destroyRenderableByUid(t);
        this._gpuBitmapText = null, this._renderer = null;
      }
    };
    As.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "bitmapText" };
  });
  var _h = p(() => {
    E();
    vx();
    U2.add(As);
  });
  var Cs;
  var Tx = p(() => {
    E();
    rt2();
    Nt2();
    _s();
    Hl();
    Cs = class {
      constructor(t) {
        this._gpuText = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.runners.resolutionChange.add(this), this._renderer.renderableGC.addManagedHash(this, "_gpuText");
      }
      resolutionChange() {
        for (let t in this._gpuText) {
          let e = this._gpuText[t];
          if (!e) continue;
          let r = e.batchableSprite.renderable;
          r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate());
        }
      }
      validateRenderable(t) {
        let e = this._getGpuText(t), r = t._getKey();
        return e.textureNeedsUploading ? (e.textureNeedsUploading = false, true) : e.currentKey !== r;
      }
      addRenderable(t, e) {
        let s = this._getGpuText(t).batchableSprite;
        t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(s, e);
      }
      updateRenderable(t) {
        let r = this._getGpuText(t).batchableSprite;
        t._didTextUpdate && this._updateText(t), r._batcher.updateElement(r);
      }
      destroyRenderable(t) {
        t.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(t.uid);
      }
      _destroyRenderableById(t) {
        let e = this._gpuText[t];
        this._renderer.htmlText.decreaseReferenceCount(e.currentKey), V2.return(e.batchableSprite), this._gpuText[t] = null;
      }
      _updateText(t) {
        let e = t._getKey(), r = this._getGpuText(t), s = r.batchableSprite;
        r.currentKey !== e && this._updateGpuText(t).catch((o) => {
          console.error(o);
        }), t._didTextUpdate = false, ys(s, t);
      }
      async _updateGpuText(t) {
        t._didTextUpdate = false;
        let e = this._getGpuText(t);
        if (e.generatingTexture) return;
        let r = t._getKey();
        this._renderer.htmlText.decreaseReferenceCount(e.currentKey), e.generatingTexture = true, e.currentKey = r;
        let s = t.resolution ?? this._renderer.resolution, o = await this._renderer.htmlText.getManagedTexture(t.text, s, t._style, t._getKey()), n = e.batchableSprite;
        n.texture = e.texture = o, e.generatingTexture = false, e.textureNeedsUploading = true, t.onViewUpdate(), ys(n, t);
      }
      _getGpuText(t) {
        return this._gpuText[t.uid] || this.initGpuText(t);
      }
      initGpuText(t) {
        let e = { texture: B.EMPTY, currentKey: "--", batchableSprite: V2.get(Ee2), textureNeedsUploading: false, generatingTexture: false }, r = e.batchableSprite;
        return r.renderable = t, r.transform = t.groupTransform, r.texture = B.EMPTY, r.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, r.roundPixels = this._renderer._roundPixels | t._roundPixels, t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution, this._gpuText[t.uid] = e, t.on("destroyed", this._destroyRenderableBound), e;
      }
      destroy() {
        for (let t in this._gpuText) this._destroyRenderableById(t);
        this._gpuText = null, this._renderer = null;
      }
    };
    Cs.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "htmlText" };
  });
  function Sx() {
    let { userAgent: i3 } = N.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(i3);
  }
  var wx = p(() => {
    lt2();
  });
  var Px;
  var Ax;
  var gi;
  var yh = p(() => {
    "use strict";
    Px = "http://www.w3.org/2000/svg", Ax = "http://www.w3.org/1999/xhtml", gi = class {
      constructor() {
        this.svgRoot = document.createElementNS(Px, "svg"), this.foreignObject = document.createElementNS(Px, "foreignObject"), this.domElement = document.createElementNS(Ax, "div"), this.styleElement = document.createElementNS(Ax, "style"), this.image = new Image();
        let { foreignObject: t, svgRoot: e, styleElement: r, domElement: s } = this;
        t.setAttribute("width", "10000"), t.setAttribute("height", "10000"), t.style.overflow = "hidden", e.appendChild(t), t.appendChild(r), t.appendChild(s);
      }
    };
  });
  function Mx(i3) {
    let t = i3._stroke, e = i3._fill, s = [`div { ${[`color: ${$.shared.setValue(e.color).toHex()}`, `font-size: ${i3.fontSize}px`, `font-family: ${i3.fontFamily}`, `font-weight: ${i3.fontWeight}`, `font-style: ${i3.fontStyle}`, `font-variant: ${i3.fontVariant}`, `letter-spacing: ${i3.letterSpacing}px`, `text-align: ${i3.align}`, `padding: ${i3.padding}px`, `white-space: ${i3.whiteSpace === "pre" && i3.wordWrap ? "pre-wrap" : i3.whiteSpace}`, ...i3.lineHeight ? [`line-height: ${i3.lineHeight}px`] : [], ...i3.wordWrap ? [`word-wrap: ${i3.breakWords ? "break-all" : "break-word"}`, `max-width: ${i3.wordWrapWidth}px`] : [], ...t ? [Rx(t)] : [], ...i3.dropShadow ? [Bx(i3.dropShadow)] : [], ...i3.cssOverrides].join(";")} }`];
    return FS(i3.tagStyles, s), s.join(" ");
  }
  function Bx(i3) {
    let t = $.shared.setValue(i3.color).setAlpha(i3.alpha).toHexa(), e = Math.round(Math.cos(i3.angle) * i3.distance), r = Math.round(Math.sin(i3.angle) * i3.distance), s = `${e}px ${r}px`;
    return i3.blur > 0 ? `text-shadow: ${s} ${i3.blur}px ${t}` : `text-shadow: ${s} ${t}`;
  }
  function Rx(i3) {
    return [`-webkit-text-stroke-width: ${i3.width}px`, `-webkit-text-stroke-color: ${$.shared.setValue(i3.color).toHex()}`, `text-stroke-width: ${i3.width}px`, `text-stroke-color: ${$.shared.setValue(i3.color).toHex()}`, "paint-order: stroke"].join(";");
  }
  function FS(i3, t) {
    for (let e in i3) {
      let r = i3[e], s = [];
      for (let o in r) Ex[o] ? s.push(Ex[o](r[o])) : Cx[o] && s.push(Cx[o].replace("{{VALUE}}", r[o]));
      t.push(`${e} { ${s.join(";")} }`);
    }
  }
  var Cx;
  var Ex;
  var Gx = p(() => {
    Gt2();
    Cx = { fontSize: "font-size: {{VALUE}}px", fontFamily: "font-family: {{VALUE}}", fontWeight: "font-weight: {{VALUE}}", fontStyle: "font-style: {{VALUE}}", fontVariant: "font-variant: {{VALUE}}", letterSpacing: "letter-spacing: {{VALUE}}px", align: "text-align: {{VALUE}}", padding: "padding: {{VALUE}}px", whiteSpace: "white-space: {{VALUE}}", lineHeight: "line-height: {{VALUE}}px", wordWrapWidth: "max-width: {{VALUE}}px" }, Ex = { fill: (i3) => `color: ${$.shared.setValue(i3).toHex()}`, breakWords: (i3) => `word-wrap: ${i3 ? "break-all" : "break-word"}`, stroke: Rx, dropShadow: Bx };
  });
  var Qn2;
  var kx = p(() => {
    ot2();
    Br2();
    ih();
    Gx();
    Qn2 = class i3 extends Pt2 {
      constructor(t = {}) {
        super(t), this._cssOverrides = [], this.cssOverrides ?? (this.cssOverrides = t.cssOverrides), this.tagStyles = t.tagStyles ?? {};
      }
      set cssOverrides(t) {
        this._cssOverrides = t instanceof Array ? t : [t], this.update();
      }
      get cssOverrides() {
        return this._cssOverrides;
      }
      _generateKey() {
        return this._styleKey = Xn2(this) + this._cssOverrides.join("-"), this._styleKey;
      }
      update() {
        this._cssStyle = null, super.update();
      }
      clone() {
        return new i3({ align: this.align, breakWords: this.breakWords, dropShadow: this.dropShadow ? { ...this.dropShadow } : null, fill: this._fill, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this._stroke, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth, cssOverrides: this.cssOverrides });
      }
      get cssStyle() {
        return this._cssStyle || (this._cssStyle = Mx(this)), this._cssStyle;
      }
      addOverride(...t) {
        let e = t.filter((r) => !this.cssOverrides.includes(r));
        e.length > 0 && (this.cssOverrides.push(...e), this.update());
      }
      removeOverride(...t) {
        let e = t.filter((r) => this.cssOverrides.includes(r));
        e.length > 0 && (this.cssOverrides = this.cssOverrides.filter((r) => !e.includes(r)), this.update());
      }
      set fill(t) {
        typeof t != "string" && typeof t != "number" && O2("[HTMLTextStyle] only color fill is not supported by HTMLText"), super.fill = t;
      }
      set stroke(t) {
        t && typeof t != "string" && typeof t != "number" && O2("[HTMLTextStyle] only color stroke is not supported by HTMLText"), super.stroke = t;
      }
    };
  });
  function Ix(i3, t) {
    let e = t.fontFamily, r = [], s = {}, o = /font-family:([^;"\s]+)/g, n = i3.match(o);
    function a(c) {
      s[c] || (r.push(c), s[c] = true);
    }
    if (Array.isArray(e)) for (let c = 0; c < e.length; c++) a(e[c]);
    else a(e);
    n && n.forEach((c) => {
      let l = c.split(":")[1].trim();
      a(l);
    });
    for (let c in t.tagStyles) {
      let l = t.tagStyles[c].fontFamily;
      a(l);
    }
    return r;
  }
  var Fx = p(() => {
    "use strict";
  });
  async function Ux(i3) {
    let e = await (await N.get().fetch(i3)).blob(), r = new FileReader();
    return await new Promise((o, n) => {
      r.onloadend = () => o(r.result), r.onerror = n, r.readAsDataURL(e);
    });
  }
  var Dx = p(() => {
    lt2();
  });
  async function bh(i3, t) {
    let e = await Ux(t);
    return `@font-face {
        font-family: "${i3.fontFamily}";
        src: url('${e}');
        font-weight: ${i3.fontWeight};
        font-style: ${i3.fontStyle};
    }`;
  }
  var Ox = p(() => {
    Dx();
  });
  async function Lx(i3, t, e) {
    let r = i3.filter((s) => tt2.has(`${s}-and-url`)).map((s, o) => {
      if (!Jn2.has(s)) {
        let { url: n } = tt2.get(`${s}-and-url`);
        o === 0 ? Jn2.set(s, bh({ fontWeight: t.fontWeight, fontStyle: t.fontStyle, fontFamily: s }, n)) : Jn2.set(s, bh({ fontWeight: e.fontWeight, fontStyle: e.fontStyle, fontFamily: s }, n));
      }
      return Jn2.get(s);
    });
    return (await Promise.all(r)).join(`
`);
  }
  var Jn2;
  var Nx = p(() => {
    je2();
    Ox();
    Jn2 = /* @__PURE__ */ new Map();
  });
  function Hx(i3, t, e, r, s) {
    let { domElement: o, styleElement: n, svgRoot: a } = s;
    o.innerHTML = `<style>${t.cssStyle}</style><div style='padding:0;'>${i3}</div>`, o.setAttribute("style", `transform: scale(${e});transform-origin: top left; display: inline-block`), n.textContent = r;
    let { width: c, height: l } = s.image;
    return a.setAttribute("width", c.toString()), a.setAttribute("height", l.toString()), new XMLSerializer().serializeToString(a);
  }
  var Wx = p(() => {
    "use strict";
  });
  function zx(i3, t) {
    let e = Jt2.getOptimalCanvasAndContext(i3.width, i3.height, t), { context: r } = e;
    return r.clearRect(0, 0, i3.width, i3.height), r.drawImage(i3, 0, 0), e;
  }
  var Vx = p(() => {
    li();
  });
  function Xx(i3, t, e) {
    return new Promise(async (r) => {
      e && await new Promise((s) => setTimeout(s, 100)), i3.onload = () => {
        r();
      }, i3.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`, i3.crossOrigin = "anonymous";
    });
  }
  var Yx = p(() => {
    "use strict";
  });
  function jx(i3, t, e, r) {
    r || (r = $x || ($x = new gi()));
    let { domElement: s, styleElement: o, svgRoot: n } = r;
    s.innerHTML = `<style>${t.cssStyle};</style><div style='padding:0'>${i3}</div>`, s.setAttribute("style", "transform-origin: top left; display: inline-block"), e && (o.textContent = e), document.body.appendChild(n);
    let a = s.getBoundingClientRect();
    n.remove();
    let c = t.padding * 2;
    return { width: a.width - c, height: a.height - c };
  }
  var $x;
  var Kx = p(() => {
    yh();
  });
  var xi;
  var qx = p(() => {
    E();
    li();
    Ve2();
    Ae2();
    wx();
    ot2();
    Nt2();
    oh();
    yh();
    kx();
    Fx();
    Nx();
    Wx();
    Vx();
    Yx();
    Kx();
    xi = class {
      constructor(t) {
        this._activeTextures = {}, this._renderer = t, this._createCanvas = t.type === Tt2.WEBGPU;
      }
      getTexture(t) {
        return this._buildTexturePromise(t.text, t.resolution, t.style);
      }
      getManagedTexture(t, e, r, s) {
        if (this._activeTextures[s]) return this._increaseReferenceCount(s), this._activeTextures[s].promise;
        let o = this._buildTexturePromise(t, e, r).then((n) => (this._activeTextures[s].texture = n, n));
        return this._activeTextures[s] = { texture: null, promise: o, usageCount: 1 }, o;
      }
      async _buildTexturePromise(t, e, r) {
        let s = V2.get(gi), o = Ix(t, r), n = await Lx(o, r, Qn2.defaultTextStyle), a = jx(t, r, n, s), c = Math.ceil(Math.ceil(Math.max(1, a.width) + r.padding * 2) * e), l = Math.ceil(Math.ceil(Math.max(1, a.height) + r.padding * 2) * e), h = s.image, u = 2;
        h.width = (c | 0) + u, h.height = (l | 0) + u;
        let f = Hx(t, r, e, n, s);
        await Xx(h, f, Sx() && o.length > 0);
        let d2 = h, m;
        this._createCanvas && (m = zx(h, e));
        let g = Yn2(m ? m.canvas : d2, h.width - u, h.height - u, e);
        return this._createCanvas && (this._renderer.texture.initSource(g.source), Jt2.returnCanvasAndContext(m)), V2.return(s), g;
      }
      _increaseReferenceCount(t) {
        this._activeTextures[t].usageCount++;
      }
      decreaseReferenceCount(t) {
        let e = this._activeTextures[t];
        e && (e.usageCount--, e.usageCount === 0 && (e.texture ? this._cleanUp(e) : e.promise.then((r) => {
          e.texture = r, this._cleanUp(e);
        }).catch(() => {
          O2("HTMLTextSystem: Failed to clean texture");
        }), this._activeTextures[t] = null));
      }
      _cleanUp(t) {
        pt2.returnTexture(t.texture), t.texture.source.resource = null, t.texture.source.uploadMethodId = "unknown";
      }
      getReferenceCount(t) {
        return this._activeTextures[t].usageCount;
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    xi.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "htmlText" };
    xi.defaultFontOptions = { fontFamily: "Arial", fontStyle: "normal", fontWeight: "normal" };
  });
  var vh = p(() => {
    E();
    Tx();
    qx();
    U2.add(xi);
    U2.add(Cs);
  });
  var Zx;
  var _i;
  var ta = p(() => {
    qe2();
    Oe2();
    Kr2();
    ft2();
    Zx = class Qx extends ae2 {
      constructor(...t) {
        let e = t[0] ?? {};
        e instanceof Float32Array && (L2(z, "use new MeshGeometry({ positions, uvs, indices }) instead"), e = { positions: e, uvs: t[1], indices: t[2] }), e = { ...Qx.defaultOptions, ...e };
        let r = e.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), s = e.uvs;
        s || (e.positions ? s = new Float32Array(r.length) : s = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
        let o = e.indices || new Uint32Array([0, 1, 2, 0, 2, 3]), n = e.shrinkBuffersToFit, a = new _t2({ data: r, label: "attribute-mesh-positions", shrinkToFit: n, usage: K2.VERTEX | K2.COPY_DST }), c = new _t2({ data: s, label: "attribute-mesh-uvs", shrinkToFit: n, usage: K2.VERTEX | K2.COPY_DST }), l = new _t2({ data: o, label: "index-mesh-buffer", shrinkToFit: n, usage: K2.INDEX | K2.COPY_DST });
        super({ attributes: { aPosition: { buffer: a, format: "float32x2", stride: 2 * 4, offset: 0 }, aUV: { buffer: c, format: "float32x2", stride: 2 * 4, offset: 0 } }, indexBuffer: l, topology: e.topology }), this.batchMode = "auto";
      }
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      set positions(t) {
        this.attributes.aPosition.buffer.data = t;
      }
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      set uvs(t) {
        this.attributes.aUV.buffer.data = t;
      }
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(t) {
        this.indexBuffer.data = t;
      }
    };
    Zx.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: false };
    _i = Zx;
  });
  var Gr2;
  var Jx;
  var yi;
  var bi = p(() => {
    "use strict";
    Gr2 = { name: "local-uniform-bit", vertex: { header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `, main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `, end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        ` } }, Jx = { ...Gr2, vertex: { ...Gr2.vertex, header: Gr2.vertex.header.replace("group(1)", "group(2)") } }, yi = { name: "local-uniform-bit", vertex: { header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `, main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `, end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        ` } };
  });
  var t_;
  var e_;
  var r_ = p(() => {
    "use strict";
    t_ = { name: "tiling-bit", vertex: { header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `, main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        ` }, fragment: { header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `, main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        ` } }, e_ = { name: "tiling-bit", vertex: { header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `, main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        ` }, fragment: { header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `, main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        ` } };
  });
  var Th;
  var Sh;
  var ea;
  var i_ = p(() => {
    Q2();
    Qe2();
    bi();
    Je2();
    me2();
    zt2();
    rt2();
    r_();
    ea = class extends yt2 {
      constructor() {
        Th ?? (Th = Te2({ name: "tiling-sprite-shader", bits: [Gr2, t_, we2] })), Sh ?? (Sh = Se2({ name: "tiling-sprite-shader", bits: [yi, e_, Pe2] }));
        let t = new nt2({ uMapCoord: { value: new I(), type: "mat3x3<f32>" }, uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" }, uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" }, uTextureTransform: { value: new I(), type: "mat3x3<f32>" }, uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" } });
        super({ glProgram: Sh, gpuProgram: Th, resources: { localUniforms: new nt2({ uTransformMatrix: { value: new I(), type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), tilingUniforms: t, uTexture: B.EMPTY.source, uSampler: B.EMPTY.source.style } });
      }
      updateUniforms(t, e, r, s, o, n) {
        let a = this.resources.tilingUniforms, c = n.width, l = n.height, h = n.textureMatrix, u = a.uniforms.uTextureTransform;
        u.set(r.a * c / t, r.b * c / e, r.c * l / t, r.d * l / e, r.tx / t, r.ty / e), u.invert(), a.uniforms.uMapCoord = h.mapCoord, a.uniforms.uClampFrame = h.uClampFrame, a.uniforms.uClampOffset = h.uClampOffset, a.uniforms.uTextureTransform = u, a.uniforms.uSizeAnchor[0] = t, a.uniforms.uSizeAnchor[1] = e, a.uniforms.uSizeAnchor[2] = s, a.uniforms.uSizeAnchor[3] = o, n && (this.resources.uTexture = n.source, this.resources.uSampler = n.source.style);
      }
    };
  });
  var ra;
  var s_ = p(() => {
    ta();
    ra = class extends _i {
      constructor() {
        super({ positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), indices: new Uint32Array([0, 1, 2, 0, 2, 3]) });
      }
    };
  });
  function o_(i3, t) {
    let e = i3.anchor.x, r = i3.anchor.y;
    t[0] = -e * i3.width, t[1] = -r * i3.height, t[2] = (1 - e) * i3.width, t[3] = -r * i3.height, t[4] = (1 - e) * i3.width, t[5] = (1 - r) * i3.height, t[6] = -e * i3.width, t[7] = (1 - r) * i3.height;
  }
  var n_ = p(() => {
    "use strict";
  });
  function a_(i3, t, e, r) {
    let s = 0, o = i3.length / (t || 2), n = r.a, a = r.b, c = r.c, l = r.d, h = r.tx, u = r.ty;
    for (e *= t; s < o; ) {
      let f = i3[e], d2 = i3[e + 1];
      i3[e] = n * f + c * d2 + h, i3[e + 1] = a * f + l * d2 + u, e += t, s++;
    }
  }
  var c_ = p(() => {
    "use strict";
  });
  function l_(i3, t) {
    let e = i3.texture, r = e.frame.width, s = e.frame.height, o = 0, n = 0;
    i3.applyAnchorToTexture && (o = i3.anchor.x, n = i3.anchor.y), t[0] = t[6] = -o, t[2] = t[4] = 1 - o, t[1] = t[3] = -n, t[5] = t[7] = 1 - n;
    let a = I.shared;
    a.copyFrom(i3._tileTransform.matrix), a.tx /= i3.width, a.ty /= i3.height, a.invert(), a.scale(i3.width / r, i3.height / s), a_(t, 2, 0, a);
  }
  var h_ = p(() => {
    Q2();
    c_();
  });
  var ia;
  var Es;
  var u_ = p(() => {
    E();
    os();
    ge2();
    Ae2();
    ai();
    Bn2();
    ta();
    i_();
    s_();
    n_();
    h_();
    ia = new ra(), Es = class {
      constructor(t) {
        this._state = bt2.default2d, this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash");
      }
      validateRenderable(t) {
        let e = this._getTilingSpriteData(t), r = e.canBatch;
        this._updateCanBatch(t);
        let s = e.canBatch;
        if (s && s === r) {
          let { batchableMesh: o } = e;
          return !o._batcher.checkAndUpdateTexture(o, t.texture);
        }
        return r !== s;
      }
      addRenderable(t, e) {
        let r = this._renderer.renderPipes.batch;
        this._updateCanBatch(t);
        let s = this._getTilingSpriteData(t), { geometry: o, canBatch: n } = s;
        if (n) {
          s.batchableMesh || (s.batchableMesh = new tr2());
          let a = s.batchableMesh;
          t.didViewUpdate && (this._updateBatchableMesh(t), a.geometry = o, a.renderable = t, a.transform = t.groupTransform, a.setTexture(t._texture)), a.roundPixels = this._renderer._roundPixels | t._roundPixels, r.addToBatch(a, e);
        } else r.break(e), s.shader || (s.shader = new ea()), this.updateRenderable(t), e.add(t);
      }
      execute(t) {
        let { shader: e } = this._tilingSpriteDataHash[t.uid];
        e.groups[0] = this._renderer.globalUniforms.bindGroup;
        let r = e.resources.localUniforms.uniforms;
        r.uTransformMatrix = t.groupTransform, r.uRound = this._renderer._roundPixels | t._roundPixels, Ce2(t.groupColorAlpha, r.uColor, 0), this._state.blendMode = De2(t.groupBlendMode, t.texture._source), this._renderer.encoder.draw({ geometry: ia, shader: e, state: this._state });
      }
      updateRenderable(t) {
        let e = this._getTilingSpriteData(t), { canBatch: r } = e;
        if (r) {
          let { batchableMesh: s } = e;
          t.didViewUpdate && this._updateBatchableMesh(t), s._batcher.updateElement(s);
        } else if (t.didViewUpdate) {
          let { shader: s } = e;
          s.updateUniforms(t.width, t.height, t._tileTransform.matrix, t.anchor.x, t.anchor.y, t.texture);
        }
      }
      destroyRenderable(t) {
        let e = this._getTilingSpriteData(t);
        e.batchableMesh = null, e.shader?.destroy(), this._tilingSpriteDataHash[t.uid] = null, t.off("destroyed", this._destroyRenderableBound);
      }
      _getTilingSpriteData(t) {
        return this._tilingSpriteDataHash[t.uid] || this._initTilingSpriteData(t);
      }
      _initTilingSpriteData(t) {
        let e = new _i({ indices: ia.indices, positions: ia.positions.slice(), uvs: ia.uvs.slice() });
        return this._tilingSpriteDataHash[t.uid] = { canBatch: true, renderable: t, geometry: e }, t.on("destroyed", this._destroyRenderableBound), this._tilingSpriteDataHash[t.uid];
      }
      _updateBatchableMesh(t) {
        let e = this._getTilingSpriteData(t), { geometry: r } = e, s = t.texture.source.style;
        s.addressMode !== "repeat" && (s.addressMode = "repeat", s.update()), l_(t, r.uvs), o_(t, r.positions);
      }
      destroy() {
        for (let t in this._tilingSpriteDataHash) this.destroyRenderable(this._tilingSpriteDataHash[t].renderable);
        this._tilingSpriteDataHash = null, this._renderer = null;
      }
      _updateCanBatch(t) {
        let e = this._getTilingSpriteData(t), r = t.texture, s = true;
        return this._renderer.type === Tt2.WEBGL && (s = this._renderer.context.supports.nonPowOf2wrapping), e.canBatch = r.textureMatrix.isSimple && (s || r.source.isPowerOfTwo), e.canBatch;
      }
    };
    Es.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "tilingSprite" };
  });
  var wh = p(() => {
    E();
    u_();
    U2.add(Es);
  });
  var d_;
  var p_;
  var m_ = p(() => {
    ft2();
    ta();
    d_ = class f_ extends _i {
      constructor(...t) {
        super({});
        let e = t[0] ?? {};
        typeof e == "number" && (L2(z, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), e = { width: e, height: t[1], verticesX: t[2], verticesY: t[3] }), this.build(e);
      }
      build(t) {
        t = { ...f_.defaultOptions, ...t }, this.verticesX = this.verticesX ?? t.verticesX, this.verticesY = this.verticesY ?? t.verticesY, this.width = this.width ?? t.width, this.height = this.height ?? t.height;
        let e = this.verticesX * this.verticesY, r = [], s = [], o = [], n = this.verticesX - 1, a = this.verticesY - 1, c = this.width / n, l = this.height / a;
        for (let u = 0; u < e; u++) {
          let f = u % this.verticesX, d2 = u / this.verticesX | 0;
          r.push(f * c, d2 * l), s.push(f / n, d2 / a);
        }
        let h = n * a;
        for (let u = 0; u < h; u++) {
          let f = u % n, d2 = u / n | 0, m = d2 * this.verticesX + f, g = d2 * this.verticesX + f + 1, x2 = (d2 + 1) * this.verticesX + f, b = (d2 + 1) * this.verticesX + f + 1;
          o.push(m, g, x2, g, b, x2);
        }
        this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(s), this.indexBuffer.data = new Uint32Array(o), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
      }
    };
    d_.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 };
    p_ = d_;
  });
  var g_;
  var __;
  var y_ = p(() => {
    m_();
    g_ = class x_ extends p_ {
      constructor(t = {}) {
        t = { ...x_.defaultOptions, ...t }, super({ width: t.width, height: t.height, verticesX: 4, verticesY: 4 }), this.update(t);
      }
      update(t) {
        this.width = t.width ?? this.width, this.height = t.height ?? this.height, this._originalWidth = t.originalWidth ?? this._originalWidth, this._originalHeight = t.originalHeight ?? this._originalHeight, this._leftWidth = t.leftWidth ?? this._leftWidth, this._rightWidth = t.rightWidth ?? this._rightWidth, this._topHeight = t.topHeight ?? this._topHeight, this._bottomHeight = t.bottomHeight ?? this._bottomHeight, this._anchorX = t.anchor?.x, this._anchorY = t.anchor?.y, this.updateUvs(), this.updatePositions();
      }
      updatePositions() {
        let t = this.positions, { width: e, height: r, _leftWidth: s, _rightWidth: o, _topHeight: n, _bottomHeight: a, _anchorX: c, _anchorY: l } = this, h = s + o, u = e > h ? 1 : e / h, f = n + a, d2 = r > f ? 1 : r / f, m = Math.min(u, d2), g = c * e, x2 = l * r;
        t[0] = t[8] = t[16] = t[24] = -g, t[2] = t[10] = t[18] = t[26] = s * m - g, t[4] = t[12] = t[20] = t[28] = e - o * m - g, t[6] = t[14] = t[22] = t[30] = e - g, t[1] = t[3] = t[5] = t[7] = -x2, t[9] = t[11] = t[13] = t[15] = n * m - x2, t[17] = t[19] = t[21] = t[23] = r - a * m - x2, t[25] = t[27] = t[29] = t[31] = r - x2, this.getBuffer("aPosition").update();
      }
      updateUvs() {
        let t = this.uvs;
        t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1;
        let e = 1 / this._originalWidth, r = 1 / this._originalHeight;
        t[2] = t[10] = t[18] = t[26] = e * this._leftWidth, t[9] = t[11] = t[13] = t[15] = r * this._topHeight, t[4] = t[12] = t[20] = t[28] = 1 - e * this._rightWidth, t[17] = t[19] = t[21] = t[23] = 1 - r * this._bottomHeight, this.getBuffer("aUV").update();
      }
    };
    g_.defaultOptions = { width: 100, height: 100, leftWidth: 10, topHeight: 10, rightWidth: 10, bottomHeight: 10, originalWidth: 100, originalHeight: 100 };
    __ = g_;
  });
  var Ms;
  var b_ = p(() => {
    E();
    Nt2();
    Bn2();
    y_();
    Ms = class {
      constructor(t) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
      }
      addRenderable(t, e) {
        let r = this._getGpuSprite(t);
        t.didViewUpdate && this._updateBatchableSprite(t, r), this._renderer.renderPipes.batch.addToBatch(r, e);
      }
      updateRenderable(t) {
        let e = this._gpuSpriteHash[t.uid];
        t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e);
      }
      validateRenderable(t) {
        let e = this._getGpuSprite(t);
        return !e._batcher.checkAndUpdateTexture(e, t._texture);
      }
      destroyRenderable(t) {
        let e = this._gpuSpriteHash[t.uid];
        V2.return(e.geometry), V2.return(e), this._gpuSpriteHash[t.uid] = null, t.off("destroyed", this._destroyRenderableBound);
      }
      _updateBatchableSprite(t, e) {
        e.geometry.update(t), e.setTexture(t._texture);
      }
      _getGpuSprite(t) {
        return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
      }
      _initGPUSprite(t) {
        let e = V2.get(tr2);
        return e.geometry = V2.get(__), e.renderable = t, e.transform = t.groupTransform, e.texture = t._texture, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t.didViewUpdate || this._updateBatchableSprite(t, e), t.on("destroyed", this._destroyRenderableBound), e;
      }
      destroy() {
        for (let t in this._gpuSpriteHash) this._gpuSpriteHash[t].geometry.destroy();
        this._gpuSpriteHash = null, this._renderer = null;
      }
    };
    Ms.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "nineSliceSprite" };
  });
  var Ph = p(() => {
    E();
    b_();
    U2.add(Ms);
  });
  var Bs;
  var v_ = p(() => {
    E();
    Bs = class {
      constructor(t) {
        this._renderer = t;
      }
      push(t, e, r) {
        this._renderer.renderPipes.batch.break(r), r.add({ renderPipeId: "filter", canBundle: false, action: "pushFilter", container: e, filterEffect: t });
      }
      pop(t, e, r) {
        this._renderer.renderPipes.batch.break(r), r.add({ renderPipeId: "filter", action: "popFilter", canBundle: false });
      }
      execute(t) {
        t.action === "pushFilter" ? this._renderer.filter.push(t) : t.action === "popFilter" && this._renderer.filter.pop();
      }
      destroy() {
        this._renderer = null;
      }
    };
    Bs.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "filter" };
  });
  function T_(i3, t) {
    t.clear();
    let e = t.matrix;
    for (let r = 0; r < i3.length; r++) {
      let s = i3[r];
      s.globalDisplayStatus < 7 || (t.matrix = s.worldTransform, t.addBounds(s.bounds));
    }
    return t.matrix = e, t;
  }
  var S_ = p(() => {
    "use strict";
  });
  var US;
  var Rs;
  var w_ = p(() => {
    E();
    Q2();
    oe2();
    Ke2();
    Kr2();
    zt2();
    rt2();
    Ve2();
    Ae2();
    $t2();
    S_();
    ot2();
    US = new ae2({ attributes: { aPosition: { buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), format: "float32x2", stride: 2 * 4, offset: 0 } }, indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]) }), Rs = class {
      constructor(t) {
        this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new nt2({ uInputSize: { value: new Float32Array(4), type: "vec4<f32>" }, uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" }, uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" } }), this._globalFilterBindGroup = new Mt2({}), this.renderer = t;
      }
      get activeBackTexture() {
        return this._activeFilterData?.backTexture;
      }
      push(t) {
        let e = this.renderer, r = t.filterEffect.filters;
        this._filterStack[this._filterStackIndex] || (this._filterStack[this._filterStackIndex] = this._getFilterData());
        let s = this._filterStack[this._filterStackIndex];
        if (this._filterStackIndex++, r.length === 0) {
          s.skip = true;
          return;
        }
        let o = s.bounds;
        if (t.renderables ? T_(t.renderables, o) : t.filterEffect.filterArea ? (o.clear(), o.addRect(t.filterEffect.filterArea), o.applyMatrix(t.container.worldTransform)) : t.container.getFastGlobalBounds(true, o), t.container) {
          let m = (t.container.renderGroup || t.container.parentRenderGroup).cacheToLocalTransform;
          m && o.applyMatrix(m);
        }
        let n = e.renderTarget.renderTarget.colorTexture.source, a = 1 / 0, c = 0, l = true, h = false, u = false, f = true;
        for (let d2 = 0; d2 < r.length; d2++) {
          let m = r[d2];
          if (a = Math.min(a, m.resolution === "inherit" ? n._resolution : m.resolution), c += m.padding, m.antialias === "off" ? l = false : m.antialias === "inherit" && l && (l = n.antialias), m.clipToViewport || (f = false), !!!(m.compatibleRenderers & e.type)) {
            u = false;
            break;
          }
          if (m.blendRequired && !(e.backBuffer?.useBackBuffer ?? true)) {
            O2("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), u = false;
            break;
          }
          u = m.enabled || u, h || (h = m.blendRequired);
        }
        if (!u) {
          s.skip = true;
          return;
        }
        if (f) {
          let d2 = e.renderTarget.rootViewPort, m = e.renderTarget.renderTarget.resolution;
          o.fitBounds(0, d2.width / m, 0, d2.height / m);
        }
        if (o.scale(a).ceil().scale(1 / a).pad(c | 0), !o.isPositive) {
          s.skip = true;
          return;
        }
        s.skip = false, s.bounds = o, s.blendRequired = h, s.container = t.container, s.filterEffect = t.filterEffect, s.previousRenderSurface = e.renderTarget.renderSurface, s.inputTexture = pt2.getOptimalTexture(o.width, o.height, a, l), e.renderTarget.bind(s.inputTexture, true), e.globalUniforms.push({ offset: o });
      }
      pop() {
        let t = this.renderer;
        this._filterStackIndex--;
        let e = this._filterStack[this._filterStackIndex];
        if (e.skip) return;
        this._activeFilterData = e;
        let r = e.inputTexture, s = e.bounds, o = B.EMPTY;
        if (t.renderTarget.finishRenderPass(), e.blendRequired) {
          let a = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null, c = t.renderTarget.getRenderTarget(e.previousRenderSurface);
          o = this.getBackTexture(c, s, a);
        }
        e.backTexture = o;
        let n = e.filterEffect.filters;
        if (this._globalFilterBindGroup.setResource(r.source.style, 2), this._globalFilterBindGroup.setResource(o.source, 3), t.globalUniforms.pop(), n.length === 1) n[0].apply(this, r, e.previousRenderSurface, false), pt2.returnTexture(r);
        else {
          let a = e.inputTexture, c = pt2.getOptimalTexture(s.width, s.height, a.source._resolution, false), l = 0;
          for (l = 0; l < n.length - 1; ++l) {
            n[l].apply(this, a, c, true);
            let u = a;
            a = c, c = u;
          }
          n[l].apply(this, a, e.previousRenderSurface, false), pt2.returnTexture(a), pt2.returnTexture(c);
        }
        e.blendRequired && pt2.returnTexture(o);
      }
      getBackTexture(t, e, r) {
        let s = t.colorTexture.source._resolution, o = pt2.getOptimalTexture(e.width, e.height, s, false), n = e.minX, a = e.minY;
        r && (n -= r.minX, a -= r.minY), n = Math.floor(n * s), a = Math.floor(a * s);
        let c = Math.ceil(e.width * s), l = Math.ceil(e.height * s);
        return this.renderer.renderTarget.copyToTexture(t, o, { x: n, y: a }, { width: c, height: l }, { x: 0, y: 0 }), o;
      }
      applyFilter(t, e, r, s) {
        let o = this.renderer, n = this._filterStack[this._filterStackIndex], a = n.bounds, c = Z2.shared, h = n.previousRenderSurface === r, u = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution, f = this._filterStackIndex - 1;
        for (; f > 0 && this._filterStack[f].skip; ) --f;
        f > 0 && (u = this._filterStack[f].inputTexture.source._resolution);
        let d2 = this._filterGlobalUniforms, m = d2.uniforms, g = m.uOutputFrame, x2 = m.uInputSize, b = m.uInputPixel, y = m.uInputClamp, v = m.uGlobalFrame, T2 = m.uOutputTexture;
        if (h) {
          let C = this._filterStackIndex;
          for (; C > 0; ) {
            C--;
            let G2 = this._filterStack[this._filterStackIndex - 1];
            if (!G2.skip) {
              c.x = G2.bounds.minX, c.y = G2.bounds.minY;
              break;
            }
          }
          g[0] = a.minX - c.x, g[1] = a.minY - c.y;
        } else g[0] = 0, g[1] = 0;
        g[2] = e.frame.width, g[3] = e.frame.height, x2[0] = e.source.width, x2[1] = e.source.height, x2[2] = 1 / x2[0], x2[3] = 1 / x2[1], b[0] = e.source.pixelWidth, b[1] = e.source.pixelHeight, b[2] = 1 / b[0], b[3] = 1 / b[1], y[0] = 0.5 * b[2], y[1] = 0.5 * b[3], y[2] = e.frame.width * x2[2] - 0.5 * b[2], y[3] = e.frame.height * x2[3] - 0.5 * b[3];
        let P = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        v[0] = c.x * u, v[1] = c.y * u, v[2] = P.source.width * u, v[3] = P.source.height * u;
        let w = this.renderer.renderTarget.getRenderTarget(r);
        if (o.renderTarget.bind(r, !!s), r instanceof B ? (T2[0] = r.frame.width, T2[1] = r.frame.height) : (T2[0] = w.width, T2[1] = w.height), T2[2] = w.isRoot ? -1 : 1, d2.update(), o.renderPipes.uniformBatch) {
          let C = o.renderPipes.uniformBatch.getUboResource(d2);
          this._globalFilterBindGroup.setResource(C, 0);
        } else this._globalFilterBindGroup.setResource(d2, 0);
        this._globalFilterBindGroup.setResource(e.source, 1), this._globalFilterBindGroup.setResource(e.source.style, 2), t.groups[0] = this._globalFilterBindGroup, o.encoder.draw({ geometry: US, shader: t, state: t._state, topology: "triangle-list" }), o.type === Tt2.WEBGL && o.renderTarget.finishRenderPass();
      }
      _getFilterData() {
        return { skip: false, inputTexture: null, bounds: new st2(), container: null, filterEffect: null, blendRequired: false, previousRenderSurface: null };
      }
      calculateSpriteMatrix(t, e) {
        let r = this._activeFilterData, s = t.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY), o = e.worldTransform.copyTo(I.shared), n = e.renderGroup || e.parentRenderGroup;
        return n && n.cacheToLocalTransform && o.prepend(n.cacheToLocalTransform), o.invert(), s.prepend(o), s.scale(1 / e.texture.frame.width, 1 / e.texture.frame.height), s.translate(e.anchor.x, e.anchor.y), s;
      }
    };
    Rs.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem], name: "filter" };
  });
  var Ah = p(() => {
    E();
    v_();
    w_();
    U2.add(Rs);
    U2.add(Bs);
  });
  var DS = {};
  var P_ = p(() => {
    Af();
    Ec();
    If();
    Uf();
    on2();
    dn2();
    Fl();
    Ul();
    Nl();
    ch();
    _h();
    vh();
    wh();
    Ph();
    Ah();
  });
  var OS = {};
  var C_ = p(() => {
    Ec();
    on2();
    dn2();
    Fl();
    Ul();
    Nl();
    ch();
    _h();
    vh();
    wh();
    Ph();
    Ah();
  });
  var M_;
  var B_;
  var R_ = p(() => {
    wr2();
    Zr2();
    me2();
    ge2();
    M_ = class Ch extends yt2 {
      constructor(t) {
        t = { ...Ch.defaultOptions, ...t }, super(t), this.enabled = true, this._state = bt2.for2d(), this.blendMode = t.blendMode, this.padding = t.padding, typeof t.antialias == "boolean" ? this.antialias = t.antialias ? "on" : "off" : this.antialias = t.antialias, this.resolution = t.resolution, this.blendRequired = t.blendRequired, this.clipToViewport = t.clipToViewport, this.addResource("uTexture", 0, 1);
      }
      apply(t, e, r, s) {
        t.applyFilter(this, e, r, s);
      }
      get blendMode() {
        return this._state.blendMode;
      }
      set blendMode(t) {
        this._state.blendMode = t;
      }
      static from(t) {
        let { gpu: e, gl: r, ...s } = t, o, n;
        return e && (o = le2.from(e)), r && (n = ce2.from(r)), new Ch({ gpuProgram: o, glProgram: n, ...s });
      }
    };
    M_.defaultOptions = { blendMode: "normal", resolution: 1, padding: 0, antialias: "off", blendRequired: false, clipToViewport: true };
    B_ = M_;
  });
  async function G_(i3) {
    if (!i3) for (let t = 0; t < Eh.length; t++) {
      let e = Eh[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
  }
  var Eh;
  var k_ = p(() => {
    E();
    Eh = [];
    U2.handleByNamedList(_2.Environment, Eh);
  });
  function sa() {
    if (typeof Gs == "boolean") return Gs;
    try {
      Gs = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === true;
    } catch {
      Gs = false;
    }
    return Gs;
  }
  var Gs;
  var Mh = p(() => {
    "use strict";
  });
  var Bt2;
  var vi = p(() => {
    "use strict";
    Bt2 = ((i3) => (i3[i3.NONE = 0] = "NONE", i3[i3.COLOR = 16384] = "COLOR", i3[i3.STENCIL = 1024] = "STENCIL", i3[i3.DEPTH = 256] = "DEPTH", i3[i3.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i3[i3.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i3[i3.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i3[i3.ALL = 17664] = "ALL", i3))(Bt2 || {});
  });
  var Ti;
  var Bh = p(() => {
    "use strict";
    Ti = class {
      constructor(t) {
        this.items = [], this._name = t;
      }
      emit(t, e, r, s, o, n, a, c) {
        let { name: l, items: h } = this;
        for (let u = 0, f = h.length; u < f; u++) h[u][l](t, e, r, s, o, n, a, c);
        return this;
      }
      add(t) {
        return t[this._name] && (this.remove(t), this.items.push(t)), this;
      }
      remove(t) {
        let e = this.items.indexOf(t);
        return e !== -1 && this.items.splice(e, 1), this;
      }
      contains(t) {
        return this.items.indexOf(t) !== -1;
      }
      removeAll() {
        return this.items.length = 0, this;
      }
      destroy() {
        this.removeAll(), this.items = null, this._name = null;
      }
      get empty() {
        return this.items.length === 0;
      }
      get name() {
        return this._name;
      }
    };
  });
  var LS;
  var I_;
  var rr2;
  var ks = p(() => {
    Gt2();
    k_();
    fe2();
    Mh();
    ft2();
    vi();
    Bh();
    Dt2();
    LS = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"], I_ = class F_ extends at2 {
      constructor(t) {
        super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
        let e = [...LS, ...this.config.runners ?? []];
        this._addRunners(...e), this._unsafeEvalCheck();
      }
      async init(t = {}) {
        let e = t.skipExtensionImports === true ? true : t.manageImports === false;
        await G_(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
        for (let r in this._systemsHash) t = { ...this._systemsHash[r].constructor.defaultOptions, ...t };
        t = { ...F_.defaultOptions, ...t }, this._roundPixels = t.roundPixels ? 1 : 0;
        for (let r = 0; r < this.runners.init.items.length; r++) await this.runners.init.items[r].init(t);
        this._initOptions = t;
      }
      render(t, e) {
        let r = t;
        if (r instanceof ct2 && (r = { container: r }, e && (L2(z, "passing a second argument is deprecated, please use render options instead"), r.target = e.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor ?? (r.clearColor = this.background.colorRgba), r.clear ?? (r.clear = this.background.clearBeforeRender)), r.clearColor) {
          let s = Array.isArray(r.clearColor) && r.clearColor.length === 4;
          r.clearColor = s ? r.clearColor : $.shared.setValue(r.clearColor).toArray();
        }
        r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), r.container.enableRenderGroup(), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r);
      }
      resize(t, e, r) {
        let s = this.view.resolution;
        this.view.resize(t, e, r), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), r !== void 0 && r !== s && this.runners.resolutionChange.emit(r);
      }
      clear(t = {}) {
        let e = this;
        t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = Bt2.ALL);
        let { clear: r, clearColor: s, target: o } = t;
        $.shared.setValue(s ?? this.background.colorRgba), e.renderTarget.clear(o, r, $.shared.toArray());
      }
      get resolution() {
        return this.view.resolution;
      }
      set resolution(t) {
        this.view.resolution = t, this.runners.resolutionChange.emit(t);
      }
      get width() {
        return this.view.texture.frame.width;
      }
      get height() {
        return this.view.texture.frame.height;
      }
      get canvas() {
        return this.view.canvas;
      }
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      get renderingToScreen() {
        return this.renderTarget.renderingToScreen;
      }
      get screen() {
        return this.view.screen;
      }
      _addRunners(...t) {
        t.forEach((e) => {
          this.runners[e] = new Ti(e);
        });
      }
      _addSystems(t) {
        let e;
        for (e in t) {
          let r = t[e];
          this._addSystem(r.value, r.name);
        }
      }
      _addSystem(t, e) {
        let r = new t(this);
        if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`);
        this[e] = r, this._systemsHash[e] = r;
        for (let s in this.runners) this.runners[s].add(r);
        return this;
      }
      _addPipes(t, e) {
        let r = e.reduce((s, o) => (s[o.name] = o.value, s), {});
        t.forEach((s) => {
          let o = s.value, n = s.name, a = r[n];
          this.renderPipes[n] = new o(this, a ? new a() : null);
        });
      }
      destroy(t = false) {
        this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
          e.destroy();
        }), this._systemsHash = null, this.renderPipes = null;
      }
      generateTexture(t) {
        return this.textureGenerator.generateTexture(t);
      }
      get roundPixels() {
        return !!this._roundPixels;
      }
      _unsafeEvalCheck() {
        if (!sa()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
      }
      resetState() {
        this.runners.resetState.emit();
      }
    };
    I_.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: false, roundPixels: false };
    rr2 = I_;
  });
  var Is;
  var O_ = p(() => {
    E();
    Q2();
    Tr2();
    mn2();
    Qe2();
    cs();
    ls();
    bi();
    Je2();
    me2();
    zt2();
    Is = class {
      init() {
        let t = new nt2({ uTransformMatrix: { value: new I(), type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), e = Te2({ name: "graphics", bits: [Qr2, ti2(ne2()), Jx, we2] });
        this.shader = new yt2({ gpuProgram: e, resources: { localUniforms: t } });
      }
      execute(t, e) {
        let r = e.context, s = r.customShader || this.shader, o = t.renderer, n = o.graphicsContext, { batcher: a, instructions: c } = n.getContextRenderData(r), l = o.encoder;
        l.setGeometry(a.geometry, s.gpuProgram);
        let h = o.globalUniforms.bindGroup;
        l.setBindGroup(0, h, s.gpuProgram);
        let u = o.renderPipes.uniformBatch.getUniformBindGroup(s.resources.localUniforms, true);
        l.setBindGroup(2, u, s.gpuProgram);
        let f = c.instructions, d2 = null;
        for (let m = 0; m < c.instructionSize; m++) {
          let g = f[m];
          if (g.topology !== d2 && (d2 = g.topology, l.setPipelineFromGeometryProgramAndState(a.geometry, s.gpuProgram, t.state, g.topology)), s.groups[1] = g.bindGroup, !g.gpuBindGroup) {
            let x2 = g.textures;
            g.bindGroup = jr2(x2.textures, x2.count), g.gpuBindGroup = o.bindGroup.getBindGroup(g.bindGroup, s.gpuProgram, 1);
          }
          l.setBindGroup(1, g.bindGroup, s.gpuProgram), l.renderPassEncoder.drawIndexed(g.size, 1, g.start);
        }
      }
      destroy() {
        this.shader.destroy(true), this.shader = null;
      }
    };
    Is.extension = { type: [_2.WebGPUPipesAdaptor], name: "graphics" };
  });
  var L_;
  var N_;
  var Rh = p(() => {
    "use strict";
    L_ = { name: "texture-bit", vertex: { header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `, main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        ` }, fragment: { header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `, main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        ` } }, N_ = { name: "texture-bit", vertex: { header: `
            uniform mat3 uTextureMatrix;
        `, main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        ` }, fragment: { header: `
        uniform sampler2D uTexture;

         
        `, main: `
            outColor = texture(uTexture, vUV);
        ` } };
  });
  var Fs;
  var H_ = p(() => {
    E();
    Q2();
    Qe2();
    bi();
    Je2();
    Rh();
    me2();
    rt2();
    ot2();
    Fs = class {
      init() {
        let t = Te2({ name: "mesh", bits: [Gr2, L_, we2] });
        this._shader = new yt2({ gpuProgram: t, resources: { uTexture: B.EMPTY._source, uSampler: B.EMPTY._source.style, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new I() } } } });
      }
      execute(t, e) {
        let r = t.renderer, s = e._shader;
        if (!s) s = this._shader, s.groups[2] = r.texture.getTextureBindGroup(e.texture);
        else if (!s.gpuProgram) {
          O2("Mesh shader has no gpuProgram", e.shader);
          return;
        }
        let o = s.gpuProgram;
        if (o.autoAssignGlobalUniforms && (s.groups[0] = r.globalUniforms.bindGroup), o.autoAssignLocalUniforms) {
          let n = t.localUniforms;
          s.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(n, true);
        }
        r.encoder.draw({ geometry: e._geometry, shader: s, state: e.state });
      }
      destroy() {
        this._shader.destroy(true), this._shader = null;
      }
    };
    Fs.extension = { type: [_2.WebGPUPipesAdaptor], name: "mesh" };
  });
  var aa;
  var Us;
  var W_ = p(() => {
    E();
    ge2();
    mn2();
    aa = bt2.for2d(), Us = class {
      start(t, e, r) {
        let s = t.renderer, o = s.encoder, n = r.gpuProgram;
        this._shader = r, this._geometry = e, o.setGeometry(e, n), aa.blendMode = "normal", s.pipeline.getPipeline(e, n, aa);
        let a = s.globalUniforms.bindGroup;
        o.resetBindGroup(1), o.setBindGroup(0, a, n);
      }
      execute(t, e) {
        let r = this._shader.gpuProgram, s = t.renderer, o = s.encoder;
        if (!e.bindGroup) {
          let c = e.textures;
          e.bindGroup = jr2(c.textures, c.count);
        }
        aa.blendMode = e.blendMode;
        let n = s.bindGroup.getBindGroup(e.bindGroup, r, 1), a = s.pipeline.getPipeline(this._geometry, r, aa, e.topology);
        e.bindGroup._touch(s.textureGC.count), o.setPipeline(a), o.renderPassEncoder.setBindGroup(1, n), o.renderPassEncoder.drawIndexed(e.size, 1, e.start);
      }
    };
    Us.extension = { type: [_2.WebGPUPipesAdaptor], name: "batch" };
  });
  var Ds;
  var z_ = p(() => {
    E();
    Ds = class {
      constructor(t) {
        this._renderer = t;
      }
      updateRenderable() {
      }
      destroyRenderable() {
      }
      validateRenderable() {
        return false;
      }
      addRenderable(t, e) {
        this._renderer.renderPipes.batch.break(e), e.add(t);
      }
      execute(t) {
        t.isRenderable && t.render(this._renderer);
      }
      destroy() {
        this._renderer = null;
      }
    };
    Ds.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "customRender" };
  });
  function Os(i3, t) {
    let e = i3.instructionSet, r = e.instructions;
    for (let s = 0; s < e.instructionSize; s++) {
      let o = r[s];
      t[o.renderPipeId].execute(o);
    }
  }
  var Gh = p(() => {
    "use strict";
  });
  var NS;
  var Ls;
  var V_ = p(() => {
    E();
    Q2();
    Nt2();
    _s();
    Gh();
    NS = new I(), Ls = class {
      constructor(t) {
        this._renderer = t;
      }
      addRenderGroup(t, e) {
        t.isCachedAsTexture ? this._addRenderableCacheAsTexture(t, e) : this._addRenderableDirect(t, e);
      }
      execute(t) {
        t.isRenderable && (t.isCachedAsTexture ? this._executeCacheAsTexture(t) : this._executeDirect(t));
      }
      destroy() {
        this._renderer = null;
      }
      _addRenderableDirect(t, e) {
        this._renderer.renderPipes.batch.break(e), t._batchableRenderGroup && (V2.return(t._batchableRenderGroup), t._batchableRenderGroup = null), e.add(t);
      }
      _addRenderableCacheAsTexture(t, e) {
        let r = t._batchableRenderGroup ?? (t._batchableRenderGroup = V2.get(Ee2));
        r.renderable = t.root, r.transform = t.root.relativeGroupTransform, r.texture = t.texture, r.bounds = t._textureBounds, e.add(t), this._renderer.renderPipes.batch.addToBatch(r, e);
      }
      _executeCacheAsTexture(t) {
        if (t.textureNeedsUpdate) {
          t.textureNeedsUpdate = false;
          let e = NS.identity().translate(-t._textureBounds.x, -t._textureBounds.y);
          this._renderer.renderTarget.push(t.texture, true, null, t.texture.frame), this._renderer.globalUniforms.push({ worldTransformMatrix: e, worldColor: 4294967295 }), Os(t, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop();
        }
        t._batchableRenderGroup._batcher.updateElement(t._batchableRenderGroup), t._batchableRenderGroup._batcher.geometry.buffers[0].update();
      }
      _executeDirect(t) {
        this._renderer.globalUniforms.push({ worldTransformMatrix: t.inverseParentTextureTransform, worldColor: t.worldColorAlpha }), Os(t, this._renderer.renderPipes), this._renderer.globalUniforms.pop();
      }
    };
    Ls.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "renderGroup" };
  });
  function Ns(i3, t) {
    t || (t = 0);
    for (let e = t; e < i3.length && i3[e]; e++) i3[e] = null;
  }
  var kh = p(() => {
    "use strict";
  });
  function Ih(i3, t = false) {
    WS(i3);
    let e = i3.childrenToUpdate, r = i3.updateTick++;
    for (let s in e) {
      let o = Number(s), n = e[s], a = n.list, c = n.index;
      for (let l = 0; l < c; l++) {
        let h = a[l];
        h.parentRenderGroup === i3 && h.relativeRenderGroupDepth === o && $_(h, r, 0);
      }
      Ns(a, c), n.index = 0;
    }
    if (t) for (let s = 0; s < i3.renderGroupChildren.length; s++) Ih(i3.renderGroupChildren[s], t);
  }
  function WS(i3) {
    let t = i3.root, e;
    if (i3.renderGroupParent) {
      let r = i3.renderGroupParent;
      i3.worldTransform.appendFrom(t.relativeGroupTransform, r.worldTransform), i3.worldColor = Ur2(t.groupColor, r.worldColor), e = t.groupAlpha * r.worldAlpha;
    } else i3.worldTransform.copyFrom(t.localTransform), i3.worldColor = t.localColor, e = t.localAlpha;
    e = e < 0 ? 0 : e > 1 ? 1 : e, i3.worldAlpha = e, i3.worldColorAlpha = i3.worldColor + ((e * 255 | 0) << 24);
  }
  function $_(i3, t, e) {
    if (t === i3.updateTick) return;
    i3.updateTick = t, i3.didChange = false;
    let r = i3.localTransform;
    i3.updateLocalTransform();
    let s = i3.parent;
    if (s && !s.renderGroup ? (e |= i3._updateFlags, i3.relativeGroupTransform.appendFrom(r, s.relativeGroupTransform), e & X_ && Y_(i3, s, e)) : (e = i3._updateFlags, i3.relativeGroupTransform.copyFrom(r), e & X_ && Y_(i3, HS, e)), !i3.renderGroup) {
      let o = i3.children, n = o.length;
      for (let l = 0; l < n; l++) $_(o[l], t, e);
      let a = i3.parentRenderGroup, c = i3;
      c.renderPipeId && !a.structureDidChange && a.updateRenderable(c);
    }
  }
  function Y_(i3, t, e) {
    if (e & Nr2) {
      i3.groupColor = Ur2(i3.localColor, t.groupColor);
      let r = i3.localAlpha * t.groupAlpha;
      r = r < 0 ? 0 : r > 1 ? 1 : r, i3.groupAlpha = r, i3.groupColorAlpha = i3.groupColor + ((r * 255 | 0) << 24);
    }
    e & Vi && (i3.groupBlendMode = i3.localBlendMode === "inherit" ? t.groupBlendMode : i3.localBlendMode), e & yr2 && (i3.globalDisplayStatus = i3.localDisplayStatus & t.globalDisplayStatus), i3._updateFlags = 0;
  }
  var HS;
  var X_;
  var j_ = p(() => {
    fe2();
    kh();
    lc();
    HS = new ct2(), X_ = yr2 | Nr2 | Vi;
  });
  function K_(i3, t) {
    let { list: e, index: r } = i3.childrenRenderablesToUpdate, s = false;
    for (let o = 0; o < r; o++) {
      let n = e[o];
      if (s = t[n.renderPipeId].validateRenderable(n), s) break;
    }
    return i3.structureDidChange = s, s;
  }
  var q_ = p(() => {
    "use strict";
  });
  var zS;
  var Hs;
  var Z_ = p(() => {
    E();
    Q2();
    Ve2();
    $t2();
    kh();
    Gh();
    j_();
    q_();
    zS = new I(), Hs = class {
      constructor(t) {
        this._renderer = t;
      }
      render({ container: t, transform: e }) {
        let r = t.parent, s = t.renderGroup.renderGroupParent;
        t.parent = null, t.renderGroup.renderGroupParent = null;
        let o = this._renderer, n = zS;
        e && (n = n.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(e));
        let a = o.renderPipes;
        this._updateCachedRenderGroups(t.renderGroup, null), this._updateRenderGroups(t.renderGroup), o.globalUniforms.start({ worldTransformMatrix: e ? t.renderGroup.localTransform : t.renderGroup.worldTransform, worldColor: t.renderGroup.worldColorAlpha }), Os(t.renderGroup, a), a.uniformBatch && a.uniformBatch.renderEnd(), e && t.renderGroup.localTransform.copyFrom(n), t.parent = r, t.renderGroup.renderGroupParent = s;
      }
      destroy() {
        this._renderer = null;
      }
      _updateCachedRenderGroups(t, e) {
        if (t.isCachedAsTexture) {
          if (!t.updateCacheTexture) return;
          e = t;
        }
        t._parentCacheAsTextureRenderGroup = e;
        for (let r = t.renderGroupChildren.length - 1; r >= 0; r--) this._updateCachedRenderGroups(t.renderGroupChildren[r], e);
        if (t.invalidateMatrices(), t.isCachedAsTexture) {
          if (t.textureNeedsUpdate) {
            let r = t.root.getLocalBounds();
            r.ceil();
            let s = t.texture;
            t.texture && pt2.returnTexture(t.texture);
            let o = this._renderer, n = t.textureOptions.resolution || o.view.resolution, a = t.textureOptions.antialias ?? o.view.antialias;
            t.texture = pt2.getOptimalTexture(r.width, r.height, n, a), t._textureBounds || (t._textureBounds = new st2()), t._textureBounds.copyFrom(r), s !== t.texture && t.renderGroupParent && (t.renderGroupParent.structureDidChange = true);
          }
        } else t.texture && (pt2.returnTexture(t.texture), t.texture = null);
      }
      _updateRenderGroups(t) {
        let e = this._renderer, r = e.renderPipes;
        if (t.runOnRender(e), t.instructionSet.renderPipes = r, t.structureDidChange ? Ns(t.childrenRenderablesToUpdate.list, 0) : K_(t, r), Ih(t), t.structureDidChange ? (t.structureDidChange = false, this._buildInstructions(t, e)) : this._updateRenderables(t), t.childrenRenderablesToUpdate.index = 0, e.renderPipes.batch.upload(t.instructionSet), !(t.isCachedAsTexture && !t.textureNeedsUpdate)) for (let s = 0; s < t.renderGroupChildren.length; s++) this._updateRenderGroups(t.renderGroupChildren[s]);
      }
      _updateRenderables(t) {
        let { list: e, index: r } = t.childrenRenderablesToUpdate;
        for (let s = 0; s < r; s++) {
          let o = e[s];
          o.didViewUpdate && t.updateRenderable(o);
        }
        Ns(e, r);
      }
      _buildInstructions(t, e) {
        let r = t.root, s = t.instructionSet;
        s.reset();
        let o = e.renderPipes ? e : e.batch.renderer, n = o.renderPipes;
        n.batch.buildStart(s), n.blendMode.buildStart(), n.colorMask.buildStart(), r.sortableChildren && r.sortChildren(), r.collectRenderablesWithEffects(s, o, null), n.batch.buildEnd(s), n.blendMode.buildEnd(s);
      }
    };
    Hs.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "renderGroup" };
  });
  var Ws;
  var Q_ = p(() => {
    E();
    Nt2();
    _s();
    Ws = class {
      constructor(t) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
      }
      addRenderable(t, e) {
        let r = this._getGpuSprite(t);
        t.didViewUpdate && this._updateBatchableSprite(t, r), this._renderer.renderPipes.batch.addToBatch(r, e);
      }
      updateRenderable(t) {
        let e = this._gpuSpriteHash[t.uid];
        t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e);
      }
      validateRenderable(t) {
        let e = this._getGpuSprite(t);
        return !e._batcher.checkAndUpdateTexture(e, t._texture);
      }
      destroyRenderable(t) {
        let e = this._gpuSpriteHash[t.uid];
        V2.return(e), this._gpuSpriteHash[t.uid] = null, t.off("destroyed", this._destroyRenderableBound);
      }
      _updateBatchableSprite(t, e) {
        e.bounds = t.visualBounds, e.texture = t._texture;
      }
      _getGpuSprite(t) {
        return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
      }
      _initGPUSprite(t) {
        let e = V2.get(Ee2);
        return e.renderable = t, e.transform = t.groupTransform, e.texture = t._texture, e.bounds = t.visualBounds, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t.on("destroyed", this._destroyRenderableBound), e;
      }
      destroy() {
        for (let t in this._gpuSpriteHash) V2.return(this._gpuSpriteHash[t]);
        this._gpuSpriteHash = null, this._renderer = null;
      }
    };
    Ws.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "sprite" };
  });
  var Si;
  var Fh = p(() => {
    Dt2();
    Si = "8.9.2";
  });
  var zs;
  var Vs;
  var Uh = p(() => {
    E();
    Fh();
    zs = class {
      static init() {
        globalThis.__PIXI_APP_INIT__?.(this, Si);
      }
      static destroy() {
      }
    };
    zs.extension = _2.Application;
    Vs = class {
      constructor(t) {
        this._renderer = t;
      }
      init() {
        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, Si);
      }
      destroy() {
        this._renderer = null;
      }
    };
    Vs.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem], name: "initHook", priority: -10 };
  });
  var Dh;
  var Oh;
  var ty = p(() => {
    E();
    ge2();
    fl2();
    Dh = class J_ {
      constructor(t, e) {
        this.state = bt2.for2d(), this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null), this._activeBatches = /* @__PURE__ */ Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init?.(this);
      }
      static getBatcher(t) {
        return new this._availableBatchers[t]();
      }
      buildStart(t) {
        let e = this._batchersByInstructionSet[t.uid];
        e || (e = this._batchersByInstructionSet[t.uid] = /* @__PURE__ */ Object.create(null), e.default || (e.default = new hs())), this._activeBatches = e, this._activeBatch = this._activeBatches.default;
        for (let r in this._activeBatches) this._activeBatches[r].begin();
      }
      addToBatch(t, e) {
        if (this._activeBatch.name !== t.batcherName) {
          this._activeBatch.break(e);
          let r = this._activeBatches[t.batcherName];
          r || (r = this._activeBatches[t.batcherName] = J_.getBatcher(t.batcherName), r.begin()), this._activeBatch = r;
        }
        this._activeBatch.add(t);
      }
      break(t) {
        this._activeBatch.break(t);
      }
      buildEnd(t) {
        this._activeBatch.break(t);
        let e = this._activeBatches;
        for (let r in e) {
          let s = e[r], o = s.geometry;
          o.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, true), o.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, false);
        }
      }
      upload(t) {
        let e = this._batchersByInstructionSet[t.uid];
        for (let r in e) {
          let s = e[r], o = s.geometry;
          s.dirty && (s.dirty = false, o.buffers[0].update(s.attributeSize * 4));
        }
      }
      execute(t) {
        if (t.action === "startBatch") {
          let e = t.batcher, r = e.geometry, s = e.shader;
          this._adaptor.start(this, r, s);
        }
        this._adaptor.execute(this, t);
      }
      destroy() {
        this.state = null, this.renderer = null, this._adaptor = null;
        for (let t in this._activeBatches) this._activeBatches[t].destroy();
        this._activeBatches = null;
      }
    };
    Dh.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "batch" };
    Dh._availableBatchers = /* @__PURE__ */ Object.create(null);
    Oh = Dh;
    U2.handleByMap(_2.Batcher, Oh._availableBatchers);
    U2.add(hs);
  });
  var ey;
  var ry = p(() => {
    ey = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`;
  });
  var iy;
  var sy = p(() => {
    iy = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`;
  });
  var Lh;
  var oy = p(() => {
    Lh = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
  });
  var ca;
  var ny = p(() => {
    Q2();
    wr2();
    Zr2();
    zt2();
    yc();
    R_();
    ry();
    sy();
    oy();
    ca = class extends B_ {
      constructor(t) {
        let { sprite: e, ...r } = t, s = new Lr2(e.texture), o = new nt2({ uFilterMatrix: { value: new I(), type: "mat3x3<f32>" }, uMaskClamp: { value: s.uClampFrame, type: "vec4<f32>" }, uAlpha: { value: 1, type: "f32" }, uInverse: { value: t.inverse ? 1 : 0, type: "f32" } }), n = le2.from({ vertex: { source: Lh, entryPoint: "mainVertex" }, fragment: { source: Lh, entryPoint: "mainFragment" } }), a = ce2.from({ vertex: iy, fragment: ey, name: "mask-filter" });
        super({ ...r, gpuProgram: n, glProgram: a, resources: { filterUniforms: o, uMaskTexture: e.texture.source } }), this.sprite = e, this._textureMatrix = s;
      }
      set inverse(t) {
        this.resources.filterUniforms.uniforms.uInverse = t ? 1 : 0;
      }
      get inverse() {
        return this.resources.filterUniforms.uniforms.uInverse === 1;
      }
      apply(t, e, r, s) {
        this._textureMatrix.texture = this.sprite.texture, t.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, e, r, s);
      }
    };
  });
  var VS;
  var Nh;
  var Xs;
  var ay = p(() => {
    E();
    Lo();
    ny();
    $t2();
    Hi();
    an2();
    Nt2();
    rt2();
    Ve2();
    Ae2();
    VS = new st2(), Nh = class extends Ge2 {
      constructor() {
        super(), this.filters = [new ca({ sprite: new Ft2(B.EMPTY), inverse: false, resolution: "inherit", antialias: "inherit" })];
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(t) {
        this.filters[0].sprite = t;
      }
      get inverse() {
        return this.filters[0].inverse;
      }
      set inverse(t) {
        this.filters[0].inverse = t;
      }
    }, Xs = class {
      constructor(t) {
        this._activeMaskStage = [], this._renderer = t;
      }
      push(t, e, r) {
        let s = this._renderer;
        if (s.renderPipes.batch.break(r), r.add({ renderPipeId: "alphaMask", action: "pushMaskBegin", mask: t, inverse: e._maskOptions.inverse, canBundle: false, maskedContainer: e }), t.inverse = e._maskOptions.inverse, t.renderMaskToTexture) {
          let o = t.mask;
          o.includeInBuild = true, o.collectRenderables(r, s, null), o.includeInBuild = false;
        }
        s.renderPipes.batch.break(r), r.add({ renderPipeId: "alphaMask", action: "pushMaskEnd", mask: t, maskedContainer: e, inverse: e._maskOptions.inverse, canBundle: false });
      }
      pop(t, e, r) {
        this._renderer.renderPipes.batch.break(r), r.add({ renderPipeId: "alphaMask", action: "popMaskEnd", mask: t, inverse: e._maskOptions.inverse, canBundle: false });
      }
      execute(t) {
        let e = this._renderer, r = t.mask.renderMaskToTexture;
        if (t.action === "pushMaskBegin") {
          let s = V2.get(Nh);
          if (s.inverse = t.inverse, r) {
            t.mask.mask.measurable = true;
            let o = Fr2(t.mask.mask, true, VS);
            t.mask.mask.measurable = false, o.ceil();
            let n = e.renderTarget.renderTarget.colorTexture.source, a = pt2.getOptimalTexture(o.width, o.height, n._resolution, n.antialias);
            e.renderTarget.push(a, true), e.globalUniforms.push({ offset: o, worldColor: 4294967295 });
            let c = s.sprite;
            c.texture = a, c.worldTransform.tx = o.minX, c.worldTransform.ty = o.minY, this._activeMaskStage.push({ filterEffect: s, maskedContainer: t.maskedContainer, filterTexture: a });
          } else s.sprite = t.mask.mask, this._activeMaskStage.push({ filterEffect: s, maskedContainer: t.maskedContainer });
        } else if (t.action === "pushMaskEnd") {
          let s = this._activeMaskStage[this._activeMaskStage.length - 1];
          r && (e.type === Tt2.WEBGL && e.renderTarget.finishRenderPass(), e.renderTarget.pop(), e.globalUniforms.pop()), e.filter.push({ renderPipeId: "filter", action: "pushFilter", container: s.maskedContainer, filterEffect: s.filterEffect, canBundle: false });
        } else if (t.action === "popMaskEnd") {
          e.filter.pop();
          let s = this._activeMaskStage.pop();
          r && pt2.returnTexture(s.filterTexture), V2.return(s.filterEffect);
        }
      }
      destroy() {
        this._renderer = null, this._activeMaskStage = null;
      }
    };
    Xs.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "alphaMask" };
  });
  var Ys;
  var cy = p(() => {
    E();
    Ys = class {
      constructor(t) {
        this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = t;
      }
      buildStart() {
        this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15;
      }
      push(t, e, r) {
        this._renderer.renderPipes.batch.break(r);
        let o = this._colorStack;
        o[this._colorStackIndex] = o[this._colorStackIndex - 1] & t.mask;
        let n = this._colorStack[this._colorStackIndex];
        n !== this._currentColor && (this._currentColor = n, r.add({ renderPipeId: "colorMask", colorMask: n, canBundle: false })), this._colorStackIndex++;
      }
      pop(t, e, r) {
        this._renderer.renderPipes.batch.break(r);
        let o = this._colorStack;
        this._colorStackIndex--;
        let n = o[this._colorStackIndex - 1];
        n !== this._currentColor && (this._currentColor = n, r.add({ renderPipeId: "colorMask", colorMask: n, canBundle: false }));
      }
      execute(t) {
        this._renderer.colorMask.setMask(t.colorMask);
      }
      destroy() {
        this._colorStack = null;
      }
    };
    Ys.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "colorMask" };
  });
  var $s;
  var ly = p(() => {
    E();
    vi();
    Sr2();
    $s = class {
      constructor(t) {
        this._maskStackHash = {}, this._maskHash = /* @__PURE__ */ new WeakMap(), this._renderer = t;
      }
      push(t, e, r) {
        var s;
        let o = t, n = this._renderer;
        n.renderPipes.batch.break(r), n.renderPipes.blendMode.setBlendMode(o.mask, "none", r), r.add({ renderPipeId: "stencilMask", action: "pushMaskBegin", mask: t, inverse: e._maskOptions.inverse, canBundle: false });
        let a = o.mask;
        a.includeInBuild = true, this._maskHash.has(o) || this._maskHash.set(o, { instructionsStart: 0, instructionsLength: 0 });
        let c = this._maskHash.get(o);
        c.instructionsStart = r.instructionSize, a.collectRenderables(r, n, null), a.includeInBuild = false, n.renderPipes.batch.break(r), r.add({ renderPipeId: "stencilMask", action: "pushMaskEnd", mask: t, inverse: e._maskOptions.inverse, canBundle: false });
        let l = r.instructionSize - c.instructionsStart - 1;
        c.instructionsLength = l;
        let h = n.renderTarget.renderTarget.uid;
        (s = this._maskStackHash)[h] ?? (s[h] = 0);
      }
      pop(t, e, r) {
        let s = t, o = this._renderer;
        o.renderPipes.batch.break(r), o.renderPipes.blendMode.setBlendMode(s.mask, "none", r), r.add({ renderPipeId: "stencilMask", action: "popMaskBegin", inverse: e._maskOptions.inverse, canBundle: false });
        let n = this._maskHash.get(t);
        for (let a = 0; a < n.instructionsLength; a++) r.instructions[r.instructionSize++] = r.instructions[n.instructionsStart++];
        r.add({ renderPipeId: "stencilMask", action: "popMaskEnd", canBundle: false });
      }
      execute(t) {
        var e;
        let r = this._renderer, s = r.renderTarget.renderTarget.uid, o = (e = this._maskStackHash)[s] ?? (e[s] = 0);
        t.action === "pushMaskBegin" ? (r.renderTarget.ensureDepthStencil(), r.stencil.setStencilMode(ht2.RENDERING_MASK_ADD, o), o++, r.colorMask.setMask(0)) : t.action === "pushMaskEnd" ? (t.inverse ? r.stencil.setStencilMode(ht2.INVERSE_MASK_ACTIVE, o) : r.stencil.setStencilMode(ht2.MASK_ACTIVE, o), r.colorMask.setMask(15)) : t.action === "popMaskBegin" ? (r.colorMask.setMask(0), o !== 0 ? r.stencil.setStencilMode(ht2.RENDERING_MASK_REMOVE, o) : (r.renderTarget.clear(null, Bt2.STENCIL), r.stencil.setStencilMode(ht2.DISABLED, o)), o--) : t.action === "popMaskEnd" && (t.inverse ? r.stencil.setStencilMode(ht2.INVERSE_MASK_ACTIVE, o) : r.stencil.setStencilMode(ht2.MASK_ACTIVE, o), r.colorMask.setMask(15)), this._maskStackHash[s] = o;
      }
      destroy() {
        this._renderer = null, this._maskStackHash = null, this._maskHash = null;
      }
    };
    $s.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "stencilMask" };
  });
  var Hh;
  var uy;
  var dy = p(() => {
    Gt2();
    E();
    Hh = class hy {
      constructor() {
        this.clearBeforeRender = true, this._backgroundColor = new $(0), this.color = this._backgroundColor, this.alpha = 1;
      }
      init(t) {
        t = { ...hy.defaultOptions, ...t }, this.clearBeforeRender = t.clearBeforeRender, this.color = t.background || t.backgroundColor || this._backgroundColor, this.alpha = t.backgroundAlpha, this._backgroundColor.setAlpha(t.backgroundAlpha);
      }
      get color() {
        return this._backgroundColor;
      }
      set color(t) {
        this._backgroundColor.setValue(t);
      }
      get alpha() {
        return this._backgroundColor.alpha;
      }
      set alpha(t) {
        this._backgroundColor.setAlpha(t);
      }
      get colorRgba() {
        return this._backgroundColor.toArray();
      }
      destroy() {
      }
    };
    Hh.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "background", priority: 0 };
    Hh.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: true };
    uy = Hh;
  });
  var js;
  var Ks;
  var fy = p(() => {
    E();
    Lo();
    ot2();
    js = {};
    U2.handle(_2.BlendMode, (i3) => {
      if (!i3.name) throw new Error("BlendMode extension must have a name property");
      js[i3.name] = i3.ref;
    }, (i3) => {
      delete js[i3.name];
    });
    Ks = class {
      constructor(t) {
        this._isAdvanced = false, this._filterHash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.runners.prerender.add(this);
      }
      prerender() {
        this._activeBlendMode = "normal", this._isAdvanced = false;
      }
      setBlendMode(t, e, r) {
        if (this._activeBlendMode === e) {
          this._isAdvanced && this._renderableList.push(t);
          return;
        }
        this._activeBlendMode = e, this._isAdvanced && this._endAdvancedBlendMode(r), this._isAdvanced = !!js[e], this._isAdvanced && (this._beginAdvancedBlendMode(r), this._renderableList.push(t));
      }
      _beginAdvancedBlendMode(t) {
        this._renderer.renderPipes.batch.break(t);
        let e = this._activeBlendMode;
        if (!js[e]) {
          O2(`Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
          return;
        }
        let r = this._filterHash[e];
        r || (r = this._filterHash[e] = new Ge2(), r.filters = [new js[e]()]);
        let s = { renderPipeId: "filter", action: "pushFilter", renderables: [], filterEffect: r, canBundle: false };
        this._renderableList = s.renderables, t.add(s);
      }
      _endAdvancedBlendMode(t) {
        this._renderableList = null, this._renderer.renderPipes.batch.break(t), t.add({ renderPipeId: "filter", action: "popFilter", canBundle: false });
      }
      buildStart() {
        this._isAdvanced = false;
      }
      buildEnd(t) {
        this._isAdvanced && this._endAdvancedBlendMode(t);
      }
      destroy() {
        this._renderer = null, this._renderableList = null;
        for (let t in this._filterHash) this._filterHash[t].destroy();
        this._filterHash = null;
      }
    };
    Ks.extension = { type: [_2.WebGLPipes, _2.WebGPUPipes, _2.CanvasPipes], name: "blendMode" };
  });
  var Wh;
  var zh;
  var my;
  var gy = p(() => {
    E();
    fe2();
    rt2();
    Wh = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, zh = class py {
      constructor(t) {
        this._renderer = t;
      }
      _normalizeOptions(t, e = {}) {
        return t instanceof ct2 || t instanceof B ? { target: t, ...e } : { ...e, ...t };
      }
      async image(t) {
        let e = new Image();
        return e.src = await this.base64(t), e;
      }
      async base64(t) {
        t = this._normalizeOptions(t, py.defaultImageOptions);
        let { format: e, quality: r } = t, s = this.canvas(t);
        if (s.toBlob !== void 0) return new Promise((o, n) => {
          s.toBlob((a) => {
            if (!a) {
              n(new Error("ICanvas.toBlob failed!"));
              return;
            }
            let c = new FileReader();
            c.onload = () => o(c.result), c.onerror = n, c.readAsDataURL(a);
          }, Wh[e], r);
        });
        if (s.toDataURL !== void 0) return s.toDataURL(Wh[e], r);
        if (s.convertToBlob !== void 0) {
          let o = await s.convertToBlob({ type: Wh[e], quality: r });
          return new Promise((n, a) => {
            let c = new FileReader();
            c.onload = () => n(c.result), c.onerror = a, c.readAsDataURL(o);
          });
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
      }
      canvas(t) {
        t = this._normalizeOptions(t);
        let e = t.target, r = this._renderer;
        if (e instanceof B) return r.texture.generateCanvas(e);
        let s = r.textureGenerator.generateTexture(t), o = r.texture.generateCanvas(s);
        return s.destroy(true), o;
      }
      pixels(t) {
        t = this._normalizeOptions(t);
        let e = t.target, r = this._renderer, s = e instanceof B ? e : r.textureGenerator.generateTexture(t), o = r.texture.getPixels(s);
        return e instanceof ct2 && s.destroy(true), o;
      }
      texture(t) {
        return t = this._normalizeOptions(t), t.target instanceof B ? t.target : this._renderer.textureGenerator.generateTexture(t);
      }
      download(t) {
        t = this._normalizeOptions(t);
        let e = this.canvas(t), r = document.createElement("a");
        r.download = t.filename ?? "image.png", r.href = e.toDataURL("image/png"), document.body.appendChild(r), r.click(), document.body.removeChild(r);
      }
      log(t) {
        let e = t.width ?? 200;
        t = this._normalizeOptions(t);
        let r = this.canvas(t), s = r.toDataURL();
        console.log(`[Pixi Texture] ${r.width}px ${r.height}px`);
        let o = ["font-size: 1px;", `padding: ${e}px 300px;`, `background: url(${s}) no-repeat;`, "background-size: contain;"].join(" ");
        console.log("%c ", o);
      }
      destroy() {
        this._renderer = null;
      }
    };
    zh.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem], name: "extract" };
    zh.defaultImageOptions = { format: "png", quality: 1 };
    my = zh;
  });
  var la;
  var xy = p(() => {
    jt2();
    rt2();
    la = class i3 extends B {
      static create(t) {
        return new i3({ source: new et3(t) });
      }
      resize(t, e, r) {
        return this.source.resize(t, e, r), this;
      }
    };
  });
  var XS;
  var YS;
  var $S;
  var qs;
  var _y = p(() => {
    Gt2();
    E();
    Q2();
    St2();
    $t2();
    Vo();
    fe2();
    xy();
    XS = new Y2(), YS = new st2(), $S = [0, 0, 0, 0], qs = class {
      constructor(t) {
        this._renderer = t;
      }
      generateTexture(t) {
        t instanceof ct2 && (t = { target: t, frame: void 0, textureSourceOptions: {}, resolution: void 0 });
        let e = t.resolution || this._renderer.resolution, r = t.antialias || this._renderer.view.antialias, s = t.target, o = t.clearColor;
        o ? o = Array.isArray(o) && o.length === 4 ? o : $.shared.setValue(o).toArray() : o = $S;
        let n = t.frame?.copyTo(XS) || Dr2(s, YS).rectangle;
        n.width = Math.max(n.width, 1 / e) | 0, n.height = Math.max(n.height, 1 / e) | 0;
        let a = la.create({ ...t.textureSourceOptions, width: n.width, height: n.height, resolution: e, antialias: r }), c = I.shared.translate(-n.x, -n.y);
        return this._renderer.render({ container: s, transform: c, target: a, clearColor: o }), a.source.updateMipmaps(), a;
      }
      destroy() {
        this._renderer = null;
      }
    };
    qs.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem], name: "textureGenerator" };
  });
  var Zs;
  var yy = p(() => {
    E();
    Q2();
    oe2();
    ai();
    Ke2();
    Ae2();
    zt2();
    Zs = class {
      constructor(t) {
        this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = t;
      }
      reset() {
        this._stackIndex = 0;
        for (let t = 0; t < this._activeUniforms.length; t++) this._uniformsPool.push(this._activeUniforms[t]);
        for (let t = 0; t < this._activeBindGroups.length; t++) this._bindGroupPool.push(this._activeBindGroups[t]);
        this._activeUniforms.length = 0, this._activeBindGroups.length = 0;
      }
      start(t) {
        this.reset(), this.push(t);
      }
      bind({ size: t, projectionMatrix: e, worldTransformMatrix: r, worldColor: s, offset: o }) {
        let n = this._renderer.renderTarget.renderTarget, a = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : { projectionData: n, worldTransformMatrix: new I(), worldColor: 4294967295, offset: new Z2() }, c = { projectionMatrix: e || this._renderer.renderTarget.projectionMatrix, resolution: t || n.size, worldTransformMatrix: r || a.worldTransformMatrix, worldColor: s || a.worldColor, offset: o || a.offset, bindGroup: null }, l = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(l);
        let h = l.uniforms;
        h.uProjectionMatrix = c.projectionMatrix, h.uResolution = c.resolution, h.uWorldTransformMatrix.copyFrom(c.worldTransformMatrix), h.uWorldTransformMatrix.tx -= c.offset.x, h.uWorldTransformMatrix.ty -= c.offset.y, Ce2(c.worldColor, h.uWorldColorAlpha, 0), l.update();
        let u;
        this._renderer.renderPipes.uniformBatch ? u = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(l, false) : (u = this._bindGroupPool.pop() || new Mt2(), this._activeBindGroups.push(u), u.setResource(l, 0)), c.bindGroup = u, this._currentGlobalUniformData = c;
      }
      push(t) {
        this.bind(t), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
      }
      pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === Tt2.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
      }
      get bindGroup() {
        return this._currentGlobalUniformData.bindGroup;
      }
      get globalUniformData() {
        return this._currentGlobalUniformData;
      }
      get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0];
      }
      _createUniforms() {
        return new nt2({ uProjectionMatrix: { value: new I(), type: "mat3x3<f32>" }, uWorldTransformMatrix: { value: new I(), type: "mat3x3<f32>" }, uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }, { isStatic: true });
      }
      destroy() {
        this._renderer = null;
      }
    };
    Zs.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "globalUniforms" };
  });
  var jS;
  var Qs;
  var by = p(() => {
    E();
    $i();
    jS = 1, Qs = class {
      constructor() {
        this._tasks = [], this._offset = 0;
      }
      init() {
        Kt2.system.add(this._update, this);
      }
      repeat(t, e, r = true) {
        let s = jS++, o = 0;
        return r && (this._offset += 1e3, o = this._offset), this._tasks.push({ func: t, duration: e, start: performance.now(), offset: o, last: performance.now(), repeat: true, id: s }), s;
      }
      cancel(t) {
        for (let e = 0; e < this._tasks.length; e++) if (this._tasks[e].id === t) {
          this._tasks.splice(e, 1);
          return;
        }
      }
      _update() {
        let t = performance.now();
        for (let e = 0; e < this._tasks.length; e++) {
          let r = this._tasks[e];
          if (t - r.offset - r.last >= r.duration) {
            let s = t - r.start;
            r.func(s), r.last = t;
          }
        }
      }
      destroy() {
        Kt2.system.remove(this._update, this), this._tasks.length = 0;
      }
    };
    Qs.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "scheduler", priority: 0 };
  });
  function Ty(i3) {
    if (!vy) {
      if (N.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
        let t = [`%c  %c  %c  %c  %c PixiJS %c v${Si} (${i3}) http://www.pixijs.com/

`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"];
        globalThis.console.log(...t);
      } else globalThis.console && globalThis.console.log(`PixiJS ${Si} - ${i3} - http://www.pixijs.com/`);
      vy = true;
    }
  }
  var vy;
  var Sy = p(() => {
    lt2();
    Fh();
    vy = false;
  });
  var wi;
  var wy = p(() => {
    E();
    Sy();
    Ae2();
    wi = class {
      constructor(t) {
        this._renderer = t;
      }
      init(t) {
        if (t.hello) {
          let e = this._renderer.name;
          this._renderer.type === Tt2.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`), Ty(e);
        }
      }
    };
    wi.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "hello", priority: -2 };
    wi.defaultOptions = { hello: false };
  });
  function Py(i3) {
    let t = false;
    for (let r in i3) if (i3[r] == null) {
      t = true;
      break;
    }
    if (!t) return i3;
    let e = /* @__PURE__ */ Object.create(null);
    for (let r in i3) {
      let s = i3[r];
      s && (e[r] = s);
    }
    return e;
  }
  function Ay(i3) {
    let t = 0;
    for (let e = 0; e < i3.length; e++) i3[e] == null ? t++ : i3[e - t] = i3[e];
    return i3.length -= t, i3;
  }
  var Cy = p(() => {
    "use strict";
  });
  var KS;
  var Vh;
  var My;
  var By = p(() => {
    E();
    Cy();
    KS = 0, Vh = class Ey {
      constructor(t) {
        this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = t;
      }
      init(t) {
        t = { ...Ey.defaultOptions, ...t }, this.maxUnusedTime = t.renderableGCMaxUnusedTime, this._frequency = t.renderableGCFrequency, this.enabled = t.renderableGCActive;
      }
      get enabled() {
        return !!this._handler;
      }
      set enabled(t) {
        this.enabled !== t && (t ? (this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, false), this._hashHandler = this._renderer.scheduler.repeat(() => {
          for (let e of this._managedHashes) e.context[e.hash] = Py(e.context[e.hash]);
        }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(() => {
          for (let e of this._managedArrays) Ay(e.context[e.hash]);
        }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)));
      }
      addManagedHash(t, e) {
        this._managedHashes.push({ context: t, hash: e });
      }
      addManagedArray(t, e) {
        this._managedArrays.push({ context: t, hash: e });
      }
      prerender({ container: t }) {
        this._now = performance.now(), t.renderGroup.gcTick = KS++, this._updateInstructionGCTick(t.renderGroup, t.renderGroup.gcTick);
      }
      addRenderable(t) {
        this.enabled && (t._lastUsed === -1 && (this._managedRenderables.push(t), t.once("destroyed", this._removeRenderable, this)), t._lastUsed = this._now);
      }
      run() {
        let t = this._now, e = this._managedRenderables, r = this._renderer.renderPipes, s = 0;
        for (let o = 0; o < e.length; o++) {
          let n = e[o];
          if (n === null) {
            s++;
            continue;
          }
          let a = n.renderGroup ?? n.parentRenderGroup, c = a?.instructionSet?.gcTick ?? -1;
          if ((a?.gcTick ?? 0) === c && (n._lastUsed = t), t - n._lastUsed > this.maxUnusedTime) {
            if (!n.destroyed) {
              let l = r;
              a && (a.structureDidChange = true), l[n.renderPipeId].destroyRenderable(n);
            }
            n._lastUsed = -1, s++, n.off("destroyed", this._removeRenderable, this);
          } else e[o - s] = n;
        }
        e.length -= s;
      }
      destroy() {
        this.enabled = false, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0;
      }
      _removeRenderable(t) {
        let e = this._managedRenderables.indexOf(t);
        e >= 0 && (t.off("destroyed", this._removeRenderable, this), this._managedRenderables[e] = null);
      }
      _updateInstructionGCTick(t, e) {
        t.instructionSet.gcTick = e;
        for (let r of t.renderGroupChildren) this._updateInstructionGCTick(r, e);
      }
    };
    Vh.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem], name: "renderableGC", priority: 0 };
    Vh.defaultOptions = { renderableGCActive: true, renderableGCMaxUnusedTime: 6e4, renderableGCFrequency: 3e4 };
    My = Vh;
  });
  var Xh;
  var Gy;
  var ky = p(() => {
    E();
    Xh = class Ry {
      constructor(t) {
        this._renderer = t, this.count = 0, this.checkCount = 0;
      }
      init(t) {
        t = { ...Ry.defaultOptions, ...t }, this.checkCountMax = t.textureGCCheckCountMax, this.maxIdle = t.textureGCAMaxIdle ?? t.textureGCMaxIdle, this.active = t.textureGCActive;
      }
      postrender() {
        this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
      }
      run() {
        let t = this._renderer.texture.managedTextures;
        for (let e = 0; e < t.length; e++) {
          let r = t[e];
          r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1, r.unload());
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    Xh.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem], name: "textureGC" };
    Xh.defaultOptions = { textureGCActive: true, textureGCAMaxIdle: null, textureGCMaxIdle: 60 * 60, textureGCCheckCountMax: 600 };
    Gy = Xh;
  });
  var Iy;
  var Js;
  var Yh = p(() => {
    It2();
    jt2();
    rt2();
    Iy = class Fy {
      constructor(t = {}) {
        if (this.uid = q2("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = false, this._size = new Float32Array(2), this._managedColorTextures = false, t = { ...Fy.defaultOptions, ...t }, this.stencil = t.stencil, this.depth = t.depth, this.isRoot = t.isRoot, typeof t.colorTextures == "number") {
          this._managedColorTextures = true;
          for (let e = 0; e < t.colorTextures; e++) this.colorTextures.push(new et3({ width: t.width, height: t.height, resolution: t.resolution, antialias: t.antialias }));
        } else {
          this.colorTextures = [...t.colorTextures.map((r) => r.source)];
          let e = this.colorTexture.source;
          this.resize(e.width, e.height, e._resolution);
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this), (t.depthStencilTexture || this.stencil) && (t.depthStencilTexture instanceof B || t.depthStencilTexture instanceof et3 ? this.depthStencilTexture = t.depthStencilTexture.source : this.ensureDepthStencilTexture());
      }
      get size() {
        let t = this._size;
        return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t;
      }
      get width() {
        return this.colorTexture.source.width;
      }
      get height() {
        return this.colorTexture.source.height;
      }
      get pixelWidth() {
        return this.colorTexture.source.pixelWidth;
      }
      get pixelHeight() {
        return this.colorTexture.source.pixelHeight;
      }
      get resolution() {
        return this.colorTexture.source._resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      onSourceResize(t) {
        this.resize(t.width, t.height, t._resolution, true);
      }
      ensureDepthStencilTexture() {
        this.depthStencilTexture || (this.depthStencilTexture = new et3({ width: this.width, height: this.height, resolution: this.resolution, format: "depth24plus-stencil8", autoGenerateMipmaps: false, antialias: false, mipLevelCount: 1 }));
      }
      resize(t, e, r = this.resolution, s = false) {
        this.dirtyId++, this.colorTextures.forEach((o, n) => {
          s && n === 0 || o.source.resize(t, e, r);
        }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, r);
      }
      destroy() {
        this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach((t) => {
          t.destroy();
        }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
      }
    };
    Iy.defaultOptions = { width: 0, height: 0, resolution: 1, colorTextures: 1, stencil: false, depth: false, antialias: false, isRoot: false };
    Js = Iy;
  });
  function ha(i3, t) {
    if (!to.has(i3)) {
      let e = new B({ source: new Ot2({ resource: i3, ...t }) }), r = () => {
        to.get(i3) === e && to.delete(i3);
      };
      e.once("destroy", r), e.source.once("destroy", r), to.set(i3, e);
    }
    return to.get(i3);
  }
  var to;
  var $h = p(() => {
    Vr2();
    rt2();
    to = /* @__PURE__ */ new Map();
  });
  var jh;
  var Dy;
  var Oy = p(() => {
    lt2();
    E();
    St2();
    ft2();
    Yh();
    $h();
    jh = class Uy {
      get autoDensity() {
        return this.texture.source.autoDensity;
      }
      set autoDensity(t) {
        this.texture.source.autoDensity = t;
      }
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(t) {
        this.texture.source.resize(this.texture.source.width, this.texture.source.height, t);
      }
      init(t) {
        t = { ...Uy.defaultOptions, ...t }, t.view && (L2(z, "ViewSystem.view has been renamed to ViewSystem.canvas"), t.canvas = t.view), this.screen = new Y2(0, 0, t.width, t.height), this.canvas = t.canvas || N.get().createCanvas(), this.antialias = !!t.antialias, this.texture = ha(this.canvas, t), this.renderTarget = new Js({ colorTextures: [this.texture], depth: !!t.depth, isRoot: true }), this.texture.source.transparent = t.backgroundAlpha < 1, this.resolution = t.resolution;
      }
      resize(t, e, r) {
        this.texture.source.resize(t, e, r), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height;
      }
      destroy(t = false) {
        (typeof t == "boolean" ? t : !!t?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
      }
    };
    jh.extension = { type: [_2.WebGLSystem, _2.WebGPUSystem, _2.CanvasSystem], name: "view", priority: 0 };
    jh.defaultOptions = { width: 800, height: 600, autoDensity: false, antialias: false };
    Dy = jh;
  });
  var ua;
  var da;
  var Kh = p(() => {
    z_();
    V_();
    Z_();
    Q_();
    Uh();
    ty();
    ay();
    cy();
    ly();
    dy();
    fy();
    gy();
    _y();
    yy();
    by();
    wy();
    By();
    ky();
    Oy();
    ua = [uy, Zs, wi, Dy, Hs, Gy, qs, my, Vs, My, Qs], da = [Ks, Oh, Ws, Ls, Xs, $s, Ys, Ds];
  });
  var eo;
  var Ly = p(() => {
    E();
    eo = class {
      constructor(t) {
        this._hash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_hash");
      }
      contextChange(t) {
        this._gpu = t;
      }
      getBindGroup(t, e, r) {
        return t._updateKey(), this._hash[t._key] || this._createBindGroup(t, e, r);
      }
      _createBindGroup(t, e, r) {
        let s = this._gpu.device, o = e.layout[r], n = [], a = this._renderer;
        for (let h in o) {
          let u = t.resources[h] ?? t.resources[o[h]], f;
          if (u._resourceType === "uniformGroup") {
            let d2 = u;
            a.ubo.updateUniformGroup(d2);
            let m = d2.buffer;
            f = { buffer: a.buffer.getGPUBuffer(m), offset: 0, size: m.descriptor.size };
          } else if (u._resourceType === "buffer") {
            let d2 = u;
            f = { buffer: a.buffer.getGPUBuffer(d2), offset: 0, size: d2.descriptor.size };
          } else if (u._resourceType === "bufferResource") {
            let d2 = u;
            f = { buffer: a.buffer.getGPUBuffer(d2.buffer), offset: d2.offset, size: d2.size };
          } else if (u._resourceType === "textureSampler") {
            let d2 = u;
            f = a.texture.getGpuSampler(d2);
          } else if (u._resourceType === "textureSource") {
            let d2 = u;
            f = a.texture.getGpuSource(d2).createView({});
          }
          n.push({ binding: o[h], resource: f });
        }
        let c = a.shader.getProgramData(e).bindGroups[r], l = s.createBindGroup({ layout: c, entries: n });
        return this._hash[t._key] = l, l;
      }
      destroy() {
        for (let t of Object.keys(this._hash)) this._hash[t] = null;
        this._hash = null, this._renderer = null;
      }
    };
    eo.extension = { type: [_2.WebGPUSystem], name: "bindGroup" };
  });
  var ro;
  var Ny = p(() => {
    E();
    qc();
    ro = class {
      constructor(t) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._managedBuffers = [], t.renderableGC.addManagedHash(this, "_gpuBuffers");
      }
      contextChange(t) {
        this._gpu = t;
      }
      getGPUBuffer(t) {
        return this._gpuBuffers[t.uid] || this.createGPUBuffer(t);
      }
      updateBuffer(t) {
        let e = this._gpuBuffers[t.uid] || this.createGPUBuffer(t), r = t.data;
        return t._updateID && r && (t._updateID = 0, this._gpu.device.queue.writeBuffer(e, 0, r.buffer, 0, (t._updateSize || r.byteLength) + 3 & -4)), e;
      }
      destroyAll() {
        for (let t in this._gpuBuffers) this._gpuBuffers[t].destroy();
        this._gpuBuffers = {};
      }
      createGPUBuffer(t) {
        this._gpuBuffers[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(t));
        let e = this._gpu.device.createBuffer(t.descriptor);
        return t._updateID = 0, t.data && (ss(t.data.buffer, e.getMappedRange()), e.unmap()), this._gpuBuffers[t.uid] = e, e;
      }
      onBufferChange(t) {
        this._gpuBuffers[t.uid].destroy(), t._updateID = 0, this._gpuBuffers[t.uid] = this.createGPUBuffer(t);
      }
      onBufferDestroy(t) {
        this._managedBuffers.splice(this._managedBuffers.indexOf(t), 1), this._destroyBuffer(t);
      }
      destroy() {
        this._managedBuffers.forEach((t) => this._destroyBuffer(t)), this._managedBuffers = null, this._gpuBuffers = null;
      }
      _destroyBuffer(t) {
        this._gpuBuffers[t.uid].destroy(), t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[t.uid] = null;
      }
    };
    ro.extension = { type: [_2.WebGPUSystem], name: "buffer" };
  });
  var io;
  var Hy = p(() => {
    E();
    io = class {
      constructor(t) {
        this._colorMaskCache = 15, this._renderer = t;
      }
      setMask(t) {
        this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.pipeline.setColorMask(t));
      }
      destroy() {
        this._renderer = null, this._colorMaskCache = null;
      }
    };
    io.extension = { type: [_2.WebGPUSystem], name: "colorMask" };
  });
  var Pi;
  var Wy = p(() => {
    lt2();
    E();
    Pi = class {
      constructor(t) {
        this._renderer = t;
      }
      async init(t) {
        return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(t).then((e) => {
          this.gpu = e, this._renderer.runners.contextChange.emit(this.gpu);
        }), this._initPromise);
      }
      contextChange(t) {
        this._renderer.gpu = t;
      }
      async _createDeviceAndAdaptor(t) {
        let e = await N.get().getNavigator().gpu.requestAdapter({ powerPreference: t.powerPreference, forceFallbackAdapter: t.forceFallbackAdapter }), r = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter((o) => e.features.has(o)), s = await e.requestDevice({ requiredFeatures: r });
        return { adapter: e, device: s };
      }
      destroy() {
        this.gpu = null, this._renderer = null;
      }
    };
    Pi.extension = { type: [_2.WebGPUSystem], name: "device" };
    Pi.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: false };
  });
  var so;
  var zy = p(() => {
    E();
    so = class {
      constructor(t) {
        this._boundBindGroup = /* @__PURE__ */ Object.create(null), this._boundVertexBuffer = /* @__PURE__ */ Object.create(null), this._renderer = t;
      }
      renderStart() {
        this.commandFinished = new Promise((t) => {
          this._resolveCommandFinished = t;
        }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      }
      beginRenderPass(t) {
        this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor);
      }
      endRenderPass() {
        this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null;
      }
      setViewport(t) {
        this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1);
      }
      setPipelineFromGeometryProgramAndState(t, e, r, s) {
        let o = this._renderer.pipeline.getPipeline(t, e, r, s);
        this.setPipeline(o);
      }
      setPipeline(t) {
        this._boundPipeline !== t && (this._boundPipeline = t, this.renderPassEncoder.setPipeline(t));
      }
      _setVertexBuffer(t, e) {
        this._boundVertexBuffer[t] !== e && (this._boundVertexBuffer[t] = e, this.renderPassEncoder.setVertexBuffer(t, this._renderer.buffer.updateBuffer(e)));
      }
      _setIndexBuffer(t) {
        if (this._boundIndexBuffer === t) return;
        this._boundIndexBuffer = t;
        let e = t.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(t), e);
      }
      resetBindGroup(t) {
        this._boundBindGroup[t] = null;
      }
      setBindGroup(t, e, r) {
        if (this._boundBindGroup[t] === e) return;
        this._boundBindGroup[t] = e, e._touch(this._renderer.textureGC.count);
        let s = this._renderer.bindGroup.getBindGroup(e, r, t);
        this.renderPassEncoder.setBindGroup(t, s);
      }
      setGeometry(t, e) {
        let r = this._renderer.pipeline.getBufferNamesToBind(t, e);
        for (let s in r) this._setVertexBuffer(s, t.attributes[r[s]].buffer);
        t.indexBuffer && this._setIndexBuffer(t.indexBuffer);
      }
      _setShaderBindGroups(t, e) {
        for (let r in t.groups) {
          let s = t.groups[r];
          e || this._syncBindGroup(s), this.setBindGroup(r, s, t.gpuProgram);
        }
      }
      _syncBindGroup(t) {
        for (let e in t.resources) {
          let r = t.resources[e];
          r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r);
        }
      }
      draw(t) {
        let { geometry: e, shader: r, state: s, topology: o, size: n, start: a, instanceCount: c, skipSync: l } = t;
        this.setPipelineFromGeometryProgramAndState(e, r.gpuProgram, s, o), this.setGeometry(e, r.gpuProgram), this._setShaderBindGroups(r, l), e.indexBuffer ? this.renderPassEncoder.drawIndexed(n || e.indexBuffer.data.length, c ?? e.instanceCount, a || 0) : this.renderPassEncoder.draw(n || e.getSize(), c ?? e.instanceCount, a || 0);
      }
      finishRenderPass() {
        this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null);
      }
      postrender() {
        this.finishRenderPass(), this._gpu.device.queue.submit([this.commandEncoder.finish()]), this._resolveCommandFinished(), this.commandEncoder = null;
      }
      restoreRenderPass() {
        let t = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, false, [0, 0, 0, 1]);
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(t);
        let e = this._boundPipeline, r = { ...this._boundVertexBuffer }, s = this._boundIndexBuffer, o = { ...this._boundBindGroup };
        this._clearCache();
        let n = this._renderer.renderTarget.viewport;
        this.renderPassEncoder.setViewport(n.x, n.y, n.width, n.height, 0, 1), this.setPipeline(e);
        for (let a in r) this._setVertexBuffer(a, r[a]);
        for (let a in o) this.setBindGroup(a, o[a], null);
        this._setIndexBuffer(s);
      }
      _clearCache() {
        for (let t = 0; t < 16; t++) this._boundBindGroup[t] = null, this._boundVertexBuffer[t] = null;
        this._boundIndexBuffer = null, this._boundPipeline = null;
      }
      destroy() {
        this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null;
      }
      contextChange(t) {
        this._gpu = t;
      }
    };
    so.extension = { type: [_2.WebGPUSystem], name: "encoder", priority: 1 };
  });
  var oo;
  var Vy = p(() => {
    E();
    Sr2();
    oo = class {
      constructor(t) {
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), this._renderer = t, t.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(t) {
        let e = this._renderTargetStencilState[t.uid];
        e || (e = this._renderTargetStencilState[t.uid] = { stencilMode: ht2.DISABLED, stencilReference: 0 }), this._activeRenderTarget = t, this.setStencilMode(e.stencilMode, e.stencilReference);
      }
      setStencilMode(t, e) {
        let r = this._renderTargetStencilState[this._activeRenderTarget.uid];
        r.stencilMode = t, r.stencilReference = e;
        let s = this._renderer;
        s.pipeline.setStencilMode(t), s.encoder.renderPassEncoder.setStencilReference(e);
      }
      destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null;
      }
    };
    oo.extension = { type: [_2.WebGPUSystem], name: "stencil" };
  });
  var Ai;
  var qh = p(() => {
    Mh();
    qe2();
    Oe2();
    Ai = class {
      constructor(t) {
        this._syncFunctionHash = /* @__PURE__ */ Object.create(null), this._adaptor = t, this._systemCheck();
      }
      _systemCheck() {
        if (!sa()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
      }
      ensureUniformGroup(t) {
        let e = this.getUniformGroupData(t);
        t.buffer || (t.buffer = new _t2({ data: new Float32Array(e.layout.size / 4), usage: K2.UNIFORM | K2.COPY_DST }));
      }
      getUniformGroupData(t) {
        return this._syncFunctionHash[t._signature] || this._initUniformGroup(t);
      }
      _initUniformGroup(t) {
        let e = t._signature, r = this._syncFunctionHash[e];
        if (!r) {
          let s = Object.keys(t.uniformStructures).map((a) => t.uniformStructures[a]), o = this._adaptor.createUboElements(s), n = this._generateUboSync(o.uboElements);
          r = this._syncFunctionHash[e] = { layout: o, syncFunction: n };
        }
        return this._syncFunctionHash[e];
      }
      _generateUboSync(t) {
        return this._adaptor.generateUboSync(t);
      }
      syncUniformGroup(t, e, r) {
        let s = this.getUniformGroupData(t);
        t.buffer || (t.buffer = new _t2({ data: new Float32Array(s.layout.size / 4), usage: K2.UNIFORM | K2.COPY_DST }));
        let o = null;
        return e || (e = t.buffer.data, o = t.buffer.dataInt32), r || (r = 0), s.syncFunction(t.uniforms, e, o, r), true;
      }
      updateUniformGroup(t) {
        if (t.isStatic && !t._dirtyId) return false;
        t._dirtyId = 0;
        let e = this.syncUniformGroup(t);
        return t.buffer.update(), e;
      }
      destroy() {
        this._syncFunctionHash = null;
      }
    };
  });
  function Xy(i3) {
    let t = i3.map((r) => ({ data: r, offset: 0, size: 0 })), e = 0;
    for (let r = 0; r < t.length; r++) {
      let s = t[r], o = no[s.data.type].size, n = no[s.data.type].align;
      if (!no[s.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${s.data.type}`);
      s.data.size > 1 && (o = Math.max(o, n) * s.data.size), e = Math.ceil(e / n) * n, s.size = o, s.offset = e, e += o;
    }
    return e = Math.ceil(e / 16) * 16, { uboElements: t, size: e };
  }
  var no;
  var Zh = p(() => {
    "use strict";
    no = { i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, f16: { align: 2, size: 2 }, "vec2<i32>": { align: 8, size: 8 }, "vec2<u32>": { align: 8, size: 8 }, "vec2<f32>": { align: 8, size: 8 }, "vec2<f16>": { align: 4, size: 4 }, "vec3<i32>": { align: 16, size: 12 }, "vec3<u32>": { align: 16, size: 12 }, "vec3<f32>": { align: 16, size: 12 }, "vec3<f16>": { align: 8, size: 6 }, "vec4<i32>": { align: 16, size: 16 }, "vec4<u32>": { align: 16, size: 16 }, "vec4<f32>": { align: 16, size: 16 }, "vec4<f16>": { align: 8, size: 8 }, "mat2x2<f32>": { align: 8, size: 16 }, "mat2x2<f16>": { align: 4, size: 8 }, "mat3x2<f32>": { align: 8, size: 24 }, "mat3x2<f16>": { align: 4, size: 12 }, "mat4x2<f32>": { align: 8, size: 32 }, "mat4x2<f16>": { align: 4, size: 16 }, "mat2x3<f32>": { align: 16, size: 32 }, "mat2x3<f16>": { align: 8, size: 16 }, "mat3x3<f32>": { align: 16, size: 48 }, "mat3x3<f16>": { align: 8, size: 24 }, "mat4x3<f32>": { align: 16, size: 64 }, "mat4x3<f16>": { align: 8, size: 32 }, "mat2x4<f32>": { align: 16, size: 32 }, "mat2x4<f16>": { align: 8, size: 16 }, "mat3x4<f32>": { align: 16, size: 48 }, "mat3x4<f16>": { align: 8, size: 24 }, "mat4x4<f32>": { align: 16, size: 64 }, "mat4x4<f16>": { align: 8, size: 32 } };
  });
  var We2;
  var Qh = p(() => {
    "use strict";
    We2 = [{ type: "mat3x3<f32>", test: (i3) => i3.value.a !== void 0, ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `, uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        ` }, { type: "vec4<f32>", test: (i3) => i3.type === "vec4<f32>" && i3.size === 1 && i3.value.width !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        ` }, { type: "vec2<f32>", test: (i3) => i3.type === "vec2<f32>" && i3.size === 1 && i3.value.x !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        ` }, { type: "vec4<f32>", test: (i3) => i3.type === "vec4<f32>" && i3.size === 1 && i3.value.red !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        ` }, { type: "vec3<f32>", test: (i3) => i3.type === "vec3<f32>" && i3.size === 1 && i3.value.red !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        ` }];
  });
  function fa(i3, t, e, r) {
    let s = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `], o = 0;
    for (let a = 0; a < i3.length; a++) {
      let c = i3[a], l = c.data.name, h = false, u = 0;
      for (let f = 0; f < We2.length; f++) if (We2[f].test(c.data)) {
        u = c.offset / 4, s.push(`name = "${l}";`, `offset += ${u - o};`, We2[f][t] || We2[f].ubo), h = true;
        break;
      }
      if (!h) if (c.data.size > 1) u = c.offset / 4, s.push(e(c, u - o));
      else {
        let f = r[c.data.type];
        u = c.offset / 4, s.push(`
                    v = uv.${l};
                    offset += ${u - o};
                    ${f};
                `);
      }
      o = u;
    }
    let n = s.join(`
`);
    return new Function("uv", "data", "dataInt32", "offset", n);
  }
  var Jh = p(() => {
    Qh();
  });
  function Ci(i3, t) {
    return `
        for (let i = 0; i < ${i3 * t}; i++) {
            data[offset + (((i / ${i3})|0) * 4) + (i % ${i3})] = v[i];
        }
    `;
  }
  var tu;
  var Yy;
  var eu = p(() => {
    "use strict";
    tu = { f32: `
        data[offset] = v;`, i32: `
        dataInt32[offset] = v;`, "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`, "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`, "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`, "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`, "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`, "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`, "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`, "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`, "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`, "mat3x2<f32>": Ci(3, 2), "mat4x2<f32>": Ci(4, 2), "mat2x3<f32>": Ci(2, 3), "mat4x3<f32>": Ci(4, 3), "mat2x4<f32>": Ci(2, 4), "mat3x4<f32>": Ci(3, 4) }, Yy = { ...tu, "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    ` };
  });
  function $y(i3, t) {
    let { size: e, align: r } = no[i3.data.type], s = (r - e) / 4, o = i3.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
         v = uv.${i3.data.name};
         ${t !== 0 ? `offset += ${t};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i3.data.size * (e / 4)}; i++)
         {
             for(var j = 0; j < ${e / 4}; j++)
             {
                 ${o}[arrayOffset++] = v[t++];
             }
             ${s !== 0 ? `arrayOffset += ${s};` : ""}
         }
     `;
  }
  var jy = p(() => {
    Zh();
  });
  function Ky(i3) {
    return fa(i3, "uboWgsl", $y, Yy);
  }
  var qy = p(() => {
    Jh();
    eu();
    jy();
  });
  var ao;
  var Zy = p(() => {
    E();
    qh();
    Zh();
    qy();
    ao = class extends Ai {
      constructor() {
        super({ createUboElements: Xy, generateUboSync: Ky });
      }
    };
    ao.extension = { type: [_2.WebGPUSystem], name: "ubo" };
  });
  var ir2;
  var pa = p(() => {
    Dt2();
    It2();
    ir2 = class extends at2 {
      constructor({ buffer: t, offset: e, size: r }) {
        super(), this.uid = q2("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = q2("resource"), this._bufferResource = true, this.destroyed = false, this.buffer = t, this.offset = e | 0, this.size = r, this.buffer.on("change", this.onBufferChange, this);
      }
      onBufferChange() {
        this._resourceId = q2("resource"), this.emit("change", this);
      }
      destroy(t = false) {
        this.destroyed = true, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null;
      }
    };
  });
  var ma;
  var Qy = p(() => {
    "use strict";
    ma = class {
      constructor({ minUniformOffsetAlignment: t }) {
        this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = t, this.data = new Float32Array(65535);
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(t) {
        if (t > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${t * 4}`);
        let e = this.byteIndex, r = e + t * 4;
        if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, r > this.data.length * 4) throw new Error("UniformBufferBatch: ubo batch got too big");
        return this.byteIndex = r, e;
      }
      addGroup(t) {
        let e = this.addEmptyGroup(t.length);
        for (let r = 0; r < t.length; r++) this.data[e / 4 + r] = t[r];
        return e;
      }
      destroy() {
        this.data = null;
      }
    };
  });
  var sr2;
  var co;
  var Jy = p(() => {
    E();
    qe2();
    pa();
    Oe2();
    Qy();
    Ke2();
    sr2 = 128, co = class {
      constructor(t) {
        this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"), this._batchBuffer = new ma({ minUniformOffsetAlignment: sr2 });
        let e = 256 / sr2;
        for (let r = 0; r < e; r++) {
          let s = K2.UNIFORM | K2.COPY_DST;
          r === 0 && (s |= K2.COPY_SRC), this._buffers.push(new _t2({ data: this._batchBuffer.data, usage: s }));
        }
      }
      renderEnd() {
        this._uploadBindGroups(), this._resetBindGroups();
      }
      _resetBindGroups() {
        for (let t in this._bindGroupHash) this._bindGroupHash[t] = null;
        this._batchBuffer.clear();
      }
      getUniformBindGroup(t, e) {
        if (!e && this._bindGroupHash[t.uid]) return this._bindGroupHash[t.uid];
        this._renderer.ubo.ensureUniformGroup(t);
        let r = t.buffer.data, s = this._batchBuffer.addEmptyGroup(r.length);
        return this._renderer.ubo.syncUniformGroup(t, this._batchBuffer.data, s / 4), this._bindGroupHash[t.uid] = this._getBindGroup(s / sr2), this._bindGroupHash[t.uid];
      }
      getUboResource(t) {
        this._renderer.ubo.updateUniformGroup(t);
        let e = t.buffer.data, r = this._batchBuffer.addGroup(e);
        return this._getBufferResource(r / sr2);
      }
      getArrayBindGroup(t) {
        let e = this._batchBuffer.addGroup(t);
        return this._getBindGroup(e / sr2);
      }
      getArrayBufferResource(t) {
        let r = this._batchBuffer.addGroup(t) / sr2;
        return this._getBufferResource(r);
      }
      _getBufferResource(t) {
        if (!this._bufferResources[t]) {
          let e = this._buffers[t % 2];
          this._bufferResources[t] = new ir2({ buffer: e, offset: (t / 2 | 0) * 256, size: sr2 });
        }
        return this._bufferResources[t];
      }
      _getBindGroup(t) {
        if (!this._bindGroups[t]) {
          let e = new Mt2({ 0: this._getBufferResource(t) });
          this._bindGroups[t] = e;
        }
        return this._bindGroups[t];
      }
      _uploadBindGroups() {
        let t = this._renderer.buffer, e = this._buffers[0];
        e.update(this._batchBuffer.byteIndex), t.updateBuffer(e);
        let r = this._renderer.gpu.device.createCommandEncoder();
        for (let s = 1; s < this._buffers.length; s++) {
          let o = this._buffers[s];
          r.copyBufferToBuffer(t.getGPUBuffer(e), sr2, t.getGPUBuffer(o), 0, this._batchBuffer.byteIndex);
        }
        this._renderer.gpu.device.queue.submit([r.finish()]);
      }
      destroy() {
        for (let t = 0; t < this._bindGroups.length; t++) this._bindGroups[t].destroy();
        this._bindGroups = null, this._bindGroupHash = null;
        for (let t = 0; t < this._buffers.length; t++) this._buffers[t].destroy();
        this._buffers = null;
        for (let t = 0; t < this._bufferResources.length; t++) this._bufferResources[t].destroy();
        this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null;
      }
    };
    co.extension = { type: [_2.WebGPUPipes], name: "uniformBatch" };
  });
  function ga(i3, t) {
    for (let e in i3.attributes) {
      let r = i3.attributes[e], s = t[e];
      s ? (r.format ?? (r.format = s.format), r.offset ?? (r.offset = s.offset), r.instance ?? (r.instance = s.instance)) : O2(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
    qS(i3);
  }
  function qS(i3) {
    let { buffers: t, attributes: e } = i3, r = {}, s = {};
    for (let o in t) {
      let n = t[o];
      r[n.uid] = 0, s[n.uid] = 0;
    }
    for (let o in e) {
      let n = e[o];
      r[n.buffer.uid] += Zt2(n.format).stride;
    }
    for (let o in e) {
      let n = e[o];
      n.stride ?? (n.stride = r[n.buffer.uid]), n.start ?? (n.start = s[n.buffer.uid]), s[n.buffer.uid] += Zt2(n.format).stride;
    }
  }
  var ru = p(() => {
    ot2();
    Pr2();
  });
  var Be2;
  var iu = p(() => {
    Sr2();
    Be2 = [];
    Be2[ht2.NONE] = void 0;
    Be2[ht2.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 };
    Be2[ht2.RENDERING_MASK_ADD] = { stencilFront: { compare: "equal", passOp: "increment-clamp" }, stencilBack: { compare: "equal", passOp: "increment-clamp" } };
    Be2[ht2.RENDERING_MASK_REMOVE] = { stencilFront: { compare: "equal", passOp: "decrement-clamp" }, stencilBack: { compare: "equal", passOp: "decrement-clamp" } };
    Be2[ht2.MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "equal", passOp: "keep" }, stencilBack: { compare: "equal", passOp: "keep" } };
    Be2[ht2.INVERSE_MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "not-equal", passOp: "replace" }, stencilBack: { compare: "not-equal", passOp: "replace" } };
  });
  function QS(i3, t, e, r, s) {
    return i3 << 24 | t << 16 | e << 10 | r << 5 | s;
  }
  function JS(i3, t, e, r) {
    return e << 6 | i3 << 3 | r << 1 | t;
  }
  var ZS;
  var lo;
  var tb = p(() => {
    E();
    ot2();
    ru();
    Sr2();
    as();
    iu();
    ZS = { "point-list": 0, "line-list": 1, "line-strip": 2, "triangle-list": 3, "triangle-strip": 4 };
    lo = class {
      constructor(t) {
        this._moduleCache = /* @__PURE__ */ Object.create(null), this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null), this._bindingNamesCache = /* @__PURE__ */ Object.create(null), this._pipeCache = /* @__PURE__ */ Object.create(null), this._pipeStateCaches = /* @__PURE__ */ Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = t;
      }
      contextChange(t) {
        this._gpu = t, this.setStencilMode(ht2.DISABLED), this._updatePipeHash();
      }
      setMultisampleCount(t) {
        this._multisampleCount !== t && (this._multisampleCount = t, this._updatePipeHash());
      }
      setRenderTarget(t) {
        this._multisampleCount = t.msaaSamples, this._depthStencilAttachment = t.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash();
      }
      setColorMask(t) {
        this._colorMask !== t && (this._colorMask = t, this._updatePipeHash());
      }
      setStencilMode(t) {
        this._stencilMode !== t && (this._stencilMode = t, this._stencilState = Be2[t], this._updatePipeHash());
      }
      setPipeline(t, e, r, s) {
        let o = this.getPipeline(t, e, r);
        s.setPipeline(o);
      }
      getPipeline(t, e, r, s) {
        t._layoutKey || (ga(t, e.attributeData), this._generateBufferKey(t)), s || (s = t.topology);
        let o = QS(t._layoutKey, e._layoutKey, r.data, r._blendModeId, ZS[s]);
        return this._pipeCache[o] ? this._pipeCache[o] : (this._pipeCache[o] = this._createPipeline(t, e, r, s), this._pipeCache[o]);
      }
      _createPipeline(t, e, r, s) {
        let o = this._gpu.device, n = this._createVertexBufferLayouts(t, e), a = this._renderer.state.getColorTargets(r);
        a[0].writeMask = this._stencilMode === ht2.RENDERING_MASK_ADD ? 0 : this._colorMask;
        let c = this._renderer.shader.getProgramData(e).pipeline, l = { vertex: { module: this._getModule(e.vertex.source), entryPoint: e.vertex.entryPoint, buffers: n }, fragment: { module: this._getModule(e.fragment.source), entryPoint: e.fragment.entryPoint, targets: a }, primitive: { topology: s, cullMode: r.cullMode }, layout: c, multisample: { count: this._multisampleCount }, label: "PIXI Pipeline" };
        return this._depthStencilAttachment && (l.depthStencil = { ...this._stencilState, format: "depth24plus-stencil8", depthWriteEnabled: r.depthTest, depthCompare: r.depthTest ? "less" : "always" }), o.createRenderPipeline(l);
      }
      _getModule(t) {
        return this._moduleCache[t] || this._createModule(t);
      }
      _createModule(t) {
        let e = this._gpu.device;
        return this._moduleCache[t] = e.createShaderModule({ code: t }), this._moduleCache[t];
      }
      _generateBufferKey(t) {
        let e = [], r = 0, s = Object.keys(t.attributes).sort();
        for (let n = 0; n < s.length; n++) {
          let a = t.attributes[s[n]];
          e[r++] = a.offset, e[r++] = a.format, e[r++] = a.stride, e[r++] = a.instance;
        }
        let o = e.join("|");
        return t._layoutKey = Le2(o, "geometry"), t._layoutKey;
      }
      _generateAttributeLocationsKey(t) {
        let e = [], r = 0, s = Object.keys(t.attributeData).sort();
        for (let n = 0; n < s.length; n++) {
          let a = t.attributeData[s[n]];
          e[r++] = a.location;
        }
        let o = e.join("|");
        return t._attributeLocationsKey = Le2(o, "programAttributes"), t._attributeLocationsKey;
      }
      getBufferNamesToBind(t, e) {
        let r = t._layoutKey << 16 | e._attributeLocationsKey;
        if (this._bindingNamesCache[r]) return this._bindingNamesCache[r];
        let s = this._createVertexBufferLayouts(t, e), o = /* @__PURE__ */ Object.create(null), n = e.attributeData;
        for (let a = 0; a < s.length; a++) {
          let l = Object.values(s[a].attributes)[0].shaderLocation;
          for (let h in n) if (n[h].location === l) {
            o[a] = h;
            break;
          }
        }
        return this._bindingNamesCache[r] = o, o;
      }
      _createVertexBufferLayouts(t, e) {
        e._attributeLocationsKey || this._generateAttributeLocationsKey(e);
        let r = t._layoutKey << 16 | e._attributeLocationsKey;
        if (this._bufferLayoutsCache[r]) return this._bufferLayoutsCache[r];
        let s = [];
        return t.buffers.forEach((o) => {
          let n = { arrayStride: 0, stepMode: "vertex", attributes: [] }, a = n.attributes;
          for (let c in e.attributeData) {
            let l = t.attributes[c];
            (l.divisor ?? 1) !== 1 && O2(`Attribute ${c} has an invalid divisor value of '${l.divisor}'. WebGPU only supports a divisor value of 1`), l.buffer === o && (n.arrayStride = l.stride, n.stepMode = l.instance ? "instance" : "vertex", a.push({ shaderLocation: e.attributeData[c].location, offset: l.offset, format: l.format }));
          }
          a.length && s.push(n);
        }), this._bufferLayoutsCache[r] = s, s;
      }
      _updatePipeHash() {
        let t = JS(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
        this._pipeStateCaches[t] || (this._pipeStateCaches[t] = /* @__PURE__ */ Object.create(null)), this._pipeCache = this._pipeStateCaches[t];
      }
      destroy() {
        this._renderer = null, this._bufferLayoutsCache = null;
      }
    };
    lo.extension = { type: [_2.WebGPUSystem], name: "pipeline" };
  });
  function eb(i3, t, e, r, s, o) {
    let n = o ? 1 : -1;
    return i3.identity(), i3.a = 1 / r * 2, i3.d = n * (1 / s * 2), i3.tx = -1 - t * i3.a, i3.ty = -n - e * i3.d, i3;
  }
  var rb = p(() => {
    "use strict";
  });
  function ib(i3) {
    let t = i3.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t);
  }
  var sb = p(() => {
    "use strict";
  });
  var Ei;
  var su = p(() => {
    Q2();
    St2();
    vi();
    rb();
    Bh();
    Vr2();
    jt2();
    rt2();
    $h();
    sb();
    Yh();
    Ei = class {
      constructor(t) {
        this.rootViewPort = new Y2(), this.viewport = new Y2(), this.onRenderTargetChange = new Ti("onRenderTargetChange"), this.projectionMatrix = new I(), this.defaultClearColor = [0, 0, 0, 0], this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null), this._renderTargetStack = [], this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
      }
      finishRenderPass() {
        this.adaptor.finishRenderPass(this.renderTarget);
      }
      renderStart({ target: t, clear: e, clearColor: r, frame: s }) {
        this._renderTargetStack.length = 0, this.push(t, e, r, s), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = ib(this.rootRenderTarget), this.adaptor.prerender?.(this.rootRenderTarget);
      }
      postrender() {
        this.adaptor.postrender?.(this.rootRenderTarget);
      }
      bind(t, e = true, r, s) {
        let o = this.getRenderTarget(t), n = this.renderTarget !== o;
        this.renderTarget = o, this.renderSurface = t;
        let a = this.getGpuRenderTarget(o);
        (o.pixelWidth !== a.width || o.pixelHeight !== a.height) && (this.adaptor.resizeGpuRenderTarget(o), a.width = o.pixelWidth, a.height = o.pixelHeight);
        let c = o.colorTexture, l = this.viewport, h = c.pixelWidth, u = c.pixelHeight;
        if (!s && t instanceof B && (s = t.frame), s) {
          let f = c._resolution;
          l.x = s.x * f + 0.5 | 0, l.y = s.y * f + 0.5 | 0, l.width = s.width * f + 0.5 | 0, l.height = s.height * f + 0.5 | 0;
        } else l.x = 0, l.y = 0, l.width = h, l.height = u;
        return eb(this.projectionMatrix, 0, 0, l.width / c.resolution, l.height / c.resolution, !o.isRoot), this.adaptor.startRenderPass(o, e, r, l), n && this.onRenderTargetChange.emit(o), o;
      }
      clear(t, e = Bt2.ALL, r) {
        e && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(t || this.renderTarget, e, r, this.viewport));
      }
      contextChange() {
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      push(t, e = Bt2.ALL, r, s) {
        let o = this.bind(t, e, r, s);
        return this._renderTargetStack.push({ renderTarget: o, frame: s }), o;
      }
      pop() {
        this._renderTargetStack.pop();
        let t = this._renderTargetStack[this._renderTargetStack.length - 1];
        this.bind(t.renderTarget, false, null, t.frame);
      }
      getRenderTarget(t) {
        return t.isTexture && (t = t.source), this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t);
      }
      copyToTexture(t, e, r, s, o) {
        r.x < 0 && (s.width += r.x, o.x -= r.x, r.x = 0), r.y < 0 && (s.height += r.y, o.y -= r.y, r.y = 0);
        let { pixelWidth: n, pixelHeight: a } = t;
        return s.width = Math.min(s.width, n - r.x), s.height = Math.min(s.height, a - r.y), this.adaptor.copyToTexture(t, e, r, s, o);
      }
      ensureDepthStencil() {
        this.renderTarget.stencil || (this.renderTarget.stencil = true, this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport));
      }
      destroy() {
        this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((t, e) => {
          t !== e && t.destroy();
        }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      _initRenderTarget(t) {
        let e = null;
        return Ot2.test(t) && (t = ha(t).source), t instanceof Js ? e = t : t instanceof et3 && (e = new Js({ colorTextures: [t] }), Ot2.test(t.source.resource) && (e.isRoot = true), t.once("destroy", () => {
          e.destroy(), this._renderSurfaceToRenderTargetHash.delete(t);
          let r = this._gpuRenderTargetHash[e.uid];
          r && (this._gpuRenderTargetHash[e.uid] = null, this.adaptor.destroyGpuRenderTarget(r));
        })), this._renderSurfaceToRenderTargetHash.set(t, e), e;
      }
      getGpuRenderTarget(t) {
        return this._gpuRenderTargetHash[t.uid] || (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t));
      }
      resetState() {
        this.renderTarget = null, this.renderSurface = null;
      }
    };
  });
  var xa;
  var ob = p(() => {
    "use strict";
    xa = class {
      constructor() {
        this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1;
      }
    };
  });
  var _a2;
  var nb = p(() => {
    vi();
    Vr2();
    jt2();
    ob();
    _a2 = class {
      init(t, e) {
        this._renderer = t, this._renderTargetSystem = e;
      }
      copyToTexture(t, e, r, s, o) {
        let n = this._renderer, a = this._getGpuColorTexture(t), c = n.texture.getGpuSource(e.source);
        return n.encoder.commandEncoder.copyTextureToTexture({ texture: a, origin: r }, { texture: c, origin: o }, s), e;
      }
      startRenderPass(t, e = true, r, s) {
        let n = this._renderTargetSystem.getGpuRenderTarget(t), a = this.getDescriptor(t, e, r);
        n.descriptor = a, this._renderer.pipeline.setRenderTarget(n), this._renderer.encoder.beginRenderPass(n), this._renderer.encoder.setViewport(s);
      }
      finishRenderPass() {
        this._renderer.encoder.endRenderPass();
      }
      _getGpuColorTexture(t) {
        let e = this._renderTargetSystem.getGpuRenderTarget(t);
        return e.contexts[0] ? e.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(t.colorTextures[0].source);
      }
      getDescriptor(t, e, r) {
        typeof e == "boolean" && (e = e ? Bt2.ALL : Bt2.NONE);
        let s = this._renderTargetSystem, o = s.getGpuRenderTarget(t), n = t.colorTextures.map((l, h) => {
          let u = o.contexts[h], f, d2;
          u ? f = u.getCurrentTexture().createView() : f = this._renderer.texture.getGpuSource(l).createView({ mipLevelCount: 1 }), o.msaaTextures[h] && (d2 = f, f = this._renderer.texture.getTextureView(o.msaaTextures[h]));
          let m = e & Bt2.COLOR ? "clear" : "load";
          return r ?? (r = s.defaultClearColor), { view: f, resolveTarget: d2, clearValue: r, storeOp: "store", loadOp: m };
        }), a;
        if ((t.stencil || t.depth) && !t.depthStencilTexture && (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = o.msaa ? 4 : 1), t.depthStencilTexture) {
          let l = e & Bt2.STENCIL ? "clear" : "load", h = e & Bt2.DEPTH ? "clear" : "load";
          a = { view: this._renderer.texture.getGpuSource(t.depthStencilTexture.source).createView(), stencilStoreOp: "store", stencilLoadOp: l, depthClearValue: 1, depthLoadOp: h, depthStoreOp: "store" };
        }
        return { colorAttachments: n, depthStencilAttachment: a };
      }
      clear(t, e = true, r, s) {
        if (!e) return;
        let { gpu: o, encoder: n } = this._renderer, a = o.device;
        if (n.commandEncoder === null) {
          let l = a.createCommandEncoder(), h = this.getDescriptor(t, e, r), u = l.beginRenderPass(h);
          u.setViewport(s.x, s.y, s.width, s.height, 0, 1), u.end();
          let f = l.finish();
          a.queue.submit([f]);
        } else this.startRenderPass(t, e, r, s);
      }
      initGpuRenderTarget(t) {
        t.isRoot = true;
        let e = new xa();
        return t.colorTextures.forEach((r, s) => {
          if (Ot2.test(r.resource)) {
            let o = r.resource.getContext("webgpu"), n = r.transparent ? "premultiplied" : "opaque";
            try {
              o.configure({ device: this._renderer.gpu.device, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC, format: "bgra8unorm", alphaMode: n });
            } catch (a) {
              console.error(a);
            }
            e.contexts[s] = o;
          }
          if (e.msaa = r.source.antialias, r.source.antialias) {
            let o = new et3({ width: 0, height: 0, sampleCount: 4 });
            e.msaaTextures[s] = o;
          }
        }), e.msaa && (e.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), e;
      }
      destroyGpuRenderTarget(t) {
        t.contexts.forEach((e) => {
          e.unconfigure();
        }), t.msaaTextures.forEach((e) => {
          e.destroy();
        }), t.msaaTextures.length = 0, t.contexts.length = 0;
      }
      ensureDepthStencilTexture(t) {
        let e = this._renderTargetSystem.getGpuRenderTarget(t);
        t.depthStencilTexture && e.msaa && (t.depthStencilTexture.source.sampleCount = 4);
      }
      resizeGpuRenderTarget(t) {
        let e = this._renderTargetSystem.getGpuRenderTarget(t);
        e.width = t.width, e.height = t.height, e.msaa && t.colorTextures.forEach((r, s) => {
          e.msaaTextures[s]?.resize(r.source.width, r.source.height, r.source._resolution);
        });
      }
    };
  });
  var ho;
  var ab = p(() => {
    E();
    su();
    nb();
    ho = class extends Ei {
      constructor(t) {
        super(t), this.adaptor = new _a2(), this.adaptor.init(t, this);
      }
    };
    ho.extension = { type: [_2.WebGPUSystem], name: "renderTarget" };
  });
  var uo;
  var cb = p(() => {
    E();
    uo = class {
      constructor() {
        this._gpuProgramData = /* @__PURE__ */ Object.create(null);
      }
      contextChange(t) {
        this._gpu = t, this.maxTextures = t.device.limits.maxSampledTexturesPerShaderStage;
      }
      getProgramData(t) {
        return this._gpuProgramData[t._layoutKey] || this._createGPUProgramData(t);
      }
      _createGPUProgramData(t) {
        let e = this._gpu.device, r = t.gpuLayout.map((o) => e.createBindGroupLayout({ entries: o })), s = { bindGroupLayouts: r };
        return this._gpuProgramData[t._layoutKey] = { bindGroups: r, pipeline: e.createPipelineLayout(s) }, this._gpuProgramData[t._layoutKey];
      }
      destroy() {
        this._gpu = null, this._gpuProgramData = null;
      }
    };
    uo.extension = { type: [_2.WebGPUSystem], name: "shader" };
  });
  var Yt2;
  var lb = p(() => {
    "use strict";
    Yt2 = {};
    Yt2.normal = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" } };
    Yt2.add = { alpha: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one", operation: "add" } };
    Yt2.multiply = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "dst", dstFactor: "one-minus-src-alpha", operation: "add" } };
    Yt2.screen = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } };
    Yt2.overlay = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } };
    Yt2.none = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "zero", operation: "add" } };
    Yt2["normal-npm"] = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" } };
    Yt2["add-npm"] = { alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" } };
    Yt2["screen-npm"] = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src", operation: "add" } };
    Yt2.erase = { alpha: { srcFactor: "zero", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "one-minus-src", operation: "add" } };
    Yt2.min = { alpha: { srcFactor: "one", dstFactor: "one", operation: "min" }, color: { srcFactor: "one", dstFactor: "one", operation: "min" } };
    Yt2.max = { alpha: { srcFactor: "one", dstFactor: "one", operation: "max" }, color: { srcFactor: "one", dstFactor: "one", operation: "max" } };
  });
  var fo;
  var hb = p(() => {
    E();
    ge2();
    lb();
    fo = class {
      constructor() {
        this.defaultState = new bt2(), this.defaultState.blend = true;
      }
      contextChange(t) {
        this.gpu = t;
      }
      getColorTargets(t) {
        return [{ format: "bgra8unorm", writeMask: 0, blend: Yt2[t.blendMode] || Yt2.normal }];
      }
      destroy() {
        this.gpu = null;
      }
    };
    fo.extension = { type: [_2.WebGPUSystem], name: "state" };
  });
  var ub;
  var db = p(() => {
    "use strict";
    ub = { type: "image", upload(i3, t, e) {
      let r = i3.resource, s = (i3.pixelWidth | 0) * (i3.pixelHeight | 0), o = r.byteLength / s;
      e.device.queue.writeTexture({ texture: t }, r, { offset: 0, rowsPerImage: i3.pixelHeight, bytesPerRow: i3.pixelHeight * o }, { width: i3.pixelWidth, height: i3.pixelHeight, depthOrArrayLayers: 1 });
    } };
  });
  var ou;
  var tw;
  var fb;
  var pb = p(() => {
    "use strict";
    ou = { "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 } }, tw = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, fb = { type: "compressed", upload(i3, t, e) {
      let r = i3.pixelWidth, s = i3.pixelHeight, o = ou[i3.format] || tw;
      for (let n = 0; n < i3.resource.length; n++) {
        let a = i3.resource[n], c = Math.ceil(r / o.blockWidth) * o.blockBytes;
        e.device.queue.writeTexture({ texture: t, mipLevel: n }, a, { offset: 0, bytesPerRow: c }, { width: Math.ceil(r / o.blockWidth) * o.blockWidth, height: Math.ceil(s / o.blockHeight) * o.blockHeight, depthOrArrayLayers: 1 }), r = Math.max(r >> 1, 1), s = Math.max(s >> 1, 1);
      }
    } };
  });
  var ya;
  var nu = p(() => {
    "use strict";
    ya = { type: "image", upload(i3, t, e) {
      let r = i3.resource;
      if (!r) return;
      let s = Math.min(t.width, i3.resourceWidth || i3.pixelWidth), o = Math.min(t.height, i3.resourceHeight || i3.pixelHeight), n = i3.alphaMode === "premultiply-alpha-on-upload";
      e.device.queue.copyExternalImageToTexture({ source: r }, { texture: t, premultipliedAlpha: n }, { width: s, height: o });
    } };
  });
  var mb;
  var gb = p(() => {
    nu();
    mb = { type: "video", upload(i3, t, e) {
      ya.upload(i3, t, e);
    } };
  });
  var ba;
  var xb = p(() => {
    "use strict";
    ba = class {
      constructor(t) {
        this.device = t, this.sampler = t.createSampler({ minFilter: "linear" }), this.pipelines = {};
      }
      _getMipmapPipeline(t) {
        let e = this.pipelines[t];
        return e || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({ code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    ` })), e = this.device.createRenderPipeline({ layout: "auto", vertex: { module: this.mipmapShaderModule, entryPoint: "vertexMain" }, fragment: { module: this.mipmapShaderModule, entryPoint: "fragmentMain", targets: [{ format: t }] } }), this.pipelines[t] = e), e;
      }
      generateMipmap(t) {
        let e = this._getMipmapPipeline(t.format);
        if (t.dimension === "3d" || t.dimension === "1d") throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        let r = t, s = t.depthOrArrayLayers || 1, o = t.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!o) {
          let c = { size: { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: s }, format: t.format, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT, mipLevelCount: t.mipLevelCount - 1 };
          r = this.device.createTexture(c);
        }
        let n = this.device.createCommandEncoder({}), a = e.getBindGroupLayout(0);
        for (let c = 0; c < s; ++c) {
          let l = t.createView({ baseMipLevel: 0, mipLevelCount: 1, dimension: "2d", baseArrayLayer: c, arrayLayerCount: 1 }), h = o ? 1 : 0;
          for (let u = 1; u < t.mipLevelCount; ++u) {
            let f = r.createView({ baseMipLevel: h++, mipLevelCount: 1, dimension: "2d", baseArrayLayer: c, arrayLayerCount: 1 }), d2 = n.beginRenderPass({ colorAttachments: [{ view: f, storeOp: "store", loadOp: "clear", clearValue: { r: 0, g: 0, b: 0, a: 0 } }] }), m = this.device.createBindGroup({ layout: a, entries: [{ binding: 0, resource: this.sampler }, { binding: 1, resource: l }] });
            d2.setPipeline(e), d2.setBindGroup(0, m), d2.draw(3, 1, 0, 0), d2.end(), l = f;
          }
        }
        if (!o) {
          let c = { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: s };
          for (let l = 1; l < t.mipLevelCount; ++l) n.copyTextureToTexture({ texture: r, mipLevel: l - 1 }, { texture: t, mipLevel: l }, c), c.width = Math.ceil(c.width / 2), c.height = Math.ceil(c.height / 2);
        }
        return this.device.queue.submit([n.finish()]), o || r.destroy(), t;
      }
    };
  });
  var po;
  var _b2 = p(() => {
    lt2();
    E();
    zt2();
    li();
    Ke2();
    db();
    pb();
    nu();
    gb();
    xb();
    po = class {
      constructor(t) {
        this.managedTextures = [], this._gpuSources = /* @__PURE__ */ Object.create(null), this._gpuSamplers = /* @__PURE__ */ Object.create(null), this._bindGroupHash = /* @__PURE__ */ Object.create(null), this._textureViewHash = /* @__PURE__ */ Object.create(null), this._uploads = { image: ya, buffer: ub, video: mb, compressed: fb }, this._renderer = t, t.renderableGC.addManagedHash(this, "_gpuSources"), t.renderableGC.addManagedHash(this, "_gpuSamplers"), t.renderableGC.addManagedHash(this, "_bindGroupHash"), t.renderableGC.addManagedHash(this, "_textureViewHash");
      }
      contextChange(t) {
        this._gpu = t;
      }
      initSource(t) {
        if (t.autoGenerateMipmaps) {
          let c = Math.max(t.pixelWidth, t.pixelHeight);
          t.mipLevelCount = Math.floor(Math.log2(c)) + 1;
        }
        let e = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
        t.uploadMethodId !== "compressed" && (e |= GPUTextureUsage.RENDER_ATTACHMENT, e |= GPUTextureUsage.COPY_SRC);
        let r = ou[t.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, s = Math.ceil(t.pixelWidth / r.blockWidth) * r.blockWidth, o = Math.ceil(t.pixelHeight / r.blockHeight) * r.blockHeight, n = { label: t.label, size: { width: s, height: o }, format: t.format, sampleCount: t.sampleCount, mipLevelCount: t.mipLevelCount, dimension: t.dimension, usage: e }, a = this._gpu.device.createTexture(n);
        return this._gpuSources[t.uid] = a, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), a;
      }
      onSourceUpdate(t) {
        let e = this.getGpuSource(t);
        e && (this._uploads[t.uploadMethodId] && this._uploads[t.uploadMethodId].upload(t, e, this._gpu), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t));
      }
      onSourceUnload(t) {
        let e = this._gpuSources[t.uid];
        e && (this._gpuSources[t.uid] = null, e.destroy());
      }
      onUpdateMipmaps(t) {
        this._mipmapGenerator || (this._mipmapGenerator = new ba(this._gpu.device));
        let e = this.getGpuSource(t);
        this._mipmapGenerator.generateMipmap(e);
      }
      onSourceDestroy(t) {
        t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
      }
      onSourceResize(t) {
        let e = this._gpuSources[t.uid];
        e ? (e.width !== t.pixelWidth || e.height !== t.pixelHeight) && (this._textureViewHash[t.uid] = null, this._bindGroupHash[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t);
      }
      _initSampler(t) {
        return this._gpuSamplers[t._resourceId] = this._gpu.device.createSampler(t), this._gpuSamplers[t._resourceId];
      }
      getGpuSampler(t) {
        return this._gpuSamplers[t._resourceId] || this._initSampler(t);
      }
      getGpuSource(t) {
        return this._gpuSources[t.uid] || this.initSource(t);
      }
      getTextureBindGroup(t) {
        return this._bindGroupHash[t.uid] ?? this._createTextureBindGroup(t);
      }
      _createTextureBindGroup(t) {
        let e = t.source;
        return this._bindGroupHash[t.uid] = new Mt2({ 0: e, 1: e.style, 2: new nt2({ uTextureMatrix: { type: "mat3x3<f32>", value: t.textureMatrix.mapCoord } }) }), this._bindGroupHash[t.uid];
      }
      getTextureView(t) {
        let e = t.source;
        return this._textureViewHash[e.uid] ?? this._createTextureView(e);
      }
      _createTextureView(t) {
        return this._textureViewHash[t.uid] = this.getGpuSource(t).createView(), this._textureViewHash[t.uid];
      }
      generateCanvas(t) {
        let e = this._renderer, r = e.gpu.device.createCommandEncoder(), s = N.get().createCanvas();
        s.width = t.source.pixelWidth, s.height = t.source.pixelHeight;
        let o = s.getContext("webgpu");
        return o.configure({ device: e.gpu.device, usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC, format: N.get().getNavigator().gpu.getPreferredCanvasFormat(), alphaMode: "premultiplied" }), r.copyTextureToTexture({ texture: e.texture.getGpuSource(t.source), origin: { x: 0, y: 0 } }, { texture: o.getCurrentTexture() }, { width: s.width, height: s.height }), e.gpu.device.queue.submit([r.finish()]), s;
      }
      getPixels(t) {
        let e = this.generateCanvas(t), r = Jt2.getOptimalCanvasAndContext(e.width, e.height), s = r.context;
        s.drawImage(e, 0, 0);
        let { width: o, height: n } = e, a = s.getImageData(0, 0, o, n), c = new Uint8ClampedArray(a.data.buffer);
        return Jt2.returnCanvasAndContext(r), { pixels: c, width: o, height: n };
      }
      destroy() {
        this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null;
        for (let t of Object.keys(this._bindGroupHash)) {
          let e = Number(t);
          this._bindGroupHash[e]?.destroy(), this._bindGroupHash[e] = null;
        }
        this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null;
      }
    };
    po.extension = { type: [_2.WebGPUSystem], name: "texture" };
  });
  var Tb = {};
  Yu(Tb, { WebGPURenderer: () => au });
  var ew;
  var rw;
  var iw;
  var yb;
  var bb;
  var vb;
  var au;
  var Sb = p(() => {
    E();
    O_();
    H_();
    W_();
    ks();
    Kh();
    Ae2();
    Ly();
    Ny();
    Hy();
    Wy();
    zy();
    Vy();
    Zy();
    Jy();
    tb();
    ab();
    cb();
    hb();
    _b2();
    ew = [...ua, ao, so, Pi, ro, po, ho, uo, fo, lo, io, oo, eo], rw = [...da, co], iw = [Us, Fs, Is], yb = [], bb = [], vb = [];
    U2.handleByNamedList(_2.WebGPUSystem, yb);
    U2.handleByNamedList(_2.WebGPUPipes, bb);
    U2.handleByNamedList(_2.WebGPUPipesAdaptor, vb);
    U2.add(...ew, ...rw, ...iw);
    au = class extends rr2 {
      constructor() {
        let t = { name: "webgpu", type: Tt2.WEBGPU, systems: yb, renderPipes: bb, renderPipeAdaptors: vb };
        super(t);
      }
    };
  });
  var mo;
  var wb = p(() => {
    E();
    Q2();
    Tr2();
    Qe2();
    cs();
    ls();
    bi();
    Je2();
    vn2();
    me2();
    zt2();
    mo = class {
      init() {
        let t = new nt2({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new I(), type: "mat3x3<f32>" }, uRound: { value: 0, type: "f32" } }), e = ne2(), r = Se2({ name: "graphics", bits: [Jr2, ei2(e), yi, Pe2] });
        this.shader = new yt2({ glProgram: r, resources: { localUniforms: t, batchSamplers: ri(e) } });
      }
      execute(t, e) {
        let r = e.context, s = r.customShader || this.shader, o = t.renderer, n = o.graphicsContext, { batcher: a, instructions: c } = n.getContextRenderData(r);
        s.groups[0] = o.globalUniforms.bindGroup, o.state.set(t.state), o.shader.bind(s), o.geometry.bind(a.geometry, s.glProgram);
        let l = c.instructions;
        for (let h = 0; h < c.instructionSize; h++) {
          let u = l[h];
          if (u.size) {
            for (let f = 0; f < u.textures.count; f++) o.texture.bind(u.textures.textures[f], f);
            o.geometry.draw(u.topology, u.size, u.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(true), this.shader = null;
      }
    };
    mo.extension = { type: [_2.WebGLPipesAdaptor], name: "graphics" };
  });
  var go;
  var Pb = p(() => {
    E();
    Q2();
    Qe2();
    bi();
    Je2();
    Rh();
    me2();
    rt2();
    ot2();
    go = class {
      init() {
        let t = Se2({ name: "mesh", bits: [yi, N_, Pe2] });
        this._shader = new yt2({ glProgram: t, resources: { uTexture: B.EMPTY.source, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new I() } } } });
      }
      execute(t, e) {
        let r = t.renderer, s = e._shader;
        if (s) {
          if (!s.glProgram) {
            O2("Mesh shader has no glProgram", e.shader);
            return;
          }
        } else {
          s = this._shader;
          let o = e.texture, n = o.source;
          s.resources.uTexture = n, s.resources.uSampler = n.style, s.resources.textureUniforms.uniforms.uTextureMatrix = o.textureMatrix.mapCoord;
        }
        s.groups[100] = r.globalUniforms.bindGroup, s.groups[101] = t.localUniformsBindGroup, r.encoder.draw({ geometry: e._geometry, shader: s, state: e.state });
      }
      destroy() {
        this._shader.destroy(true), this._shader = null;
      }
    };
    go.extension = { type: [_2.WebGLPipesAdaptor], name: "mesh" };
  });
  var xo;
  var Ab = p(() => {
    E();
    ge2();
    xo = class {
      constructor() {
        this._tempState = bt2.for2d(), this._didUploadHash = {};
      }
      init(t) {
        t.renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._didUploadHash = {};
      }
      start(t, e, r) {
        let s = t.renderer, o = this._didUploadHash[r.uid];
        s.shader.bind(r, o), o || (this._didUploadHash[r.uid] = true), s.shader.updateUniformGroup(s.globalUniforms.uniformGroup), s.geometry.bind(e, r.glProgram);
      }
      execute(t, e) {
        let r = t.renderer;
        this._tempState.blendMode = e.blendMode, r.state.set(this._tempState);
        let s = e.textures.textures;
        for (let o = 0; o < e.textures.count; o++) r.texture.bind(s[o], o);
        r.geometry.draw(e.topology, e.size, e.start);
      }
    };
    xo.extension = { type: [_2.WebGLPipesAdaptor], name: "batch" };
  });
  var _o;
  var Cb = p(() => {
    "use strict";
    _o = ((i3) => (i3[i3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i3[i3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i3[i3.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", i3))(_o || {});
  });
  var va;
  var Eb = p(() => {
    "use strict";
    va = class {
      constructor(t, e) {
        this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = e;
      }
    };
  });
  var yo;
  var Mb = p(() => {
    E();
    Oe2();
    Cb();
    Eb();
    yo = class {
      constructor(t) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._boundBufferBases = /* @__PURE__ */ Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
      }
      destroy() {
        this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null;
      }
      contextChange() {
        let t = this._gl = this._renderer.gl;
        this._gpuBuffers = /* @__PURE__ */ Object.create(null), this._maxBindings = t.MAX_UNIFORM_BUFFER_BINDINGS ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
      }
      getGlBuffer(t) {
        return this._gpuBuffers[t.uid] || this.createGLBuffer(t);
      }
      bind(t) {
        let { _gl: e } = this, r = this.getGlBuffer(t);
        e.bindBuffer(r.type, r.buffer);
      }
      bindBufferBase(t, e) {
        let { _gl: r } = this;
        this._boundBufferBases[e] !== t && (this._boundBufferBases[e] = t, t._lastBindBaseLocation = e, r.bindBufferBase(r.UNIFORM_BUFFER, e, t.buffer));
      }
      nextBindBase(t) {
        this._bindCallId++, this._minBaseLocation = 0, t && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1));
      }
      freeLocationForBufferBase(t) {
        let e = this.getLastBindBaseLocation(t);
        if (e >= this._minBaseLocation) return t._lastBindCallId = this._bindCallId, e;
        let r = 0, s = this._nextBindBaseIndex;
        for (; r < 2; ) {
          s >= this._maxBindings && (s = this._minBaseLocation, r++);
          let o = this._boundBufferBases[s];
          if (o && o._lastBindCallId === this._bindCallId) {
            s++;
            continue;
          }
          break;
        }
        return e = s, this._nextBindBaseIndex = s + 1, r >= 2 ? -1 : (t._lastBindCallId = this._bindCallId, this._boundBufferBases[e] = null, e);
      }
      getLastBindBaseLocation(t) {
        let e = t._lastBindBaseLocation;
        return this._boundBufferBases[e] === t ? e : -1;
      }
      bindBufferRange(t, e, r, s) {
        let { _gl: o } = this;
        r || (r = 0), e || (e = 0), this._boundBufferBases[e] = null, o.bindBufferRange(o.UNIFORM_BUFFER, e || 0, t.buffer, r * 256, s || 256);
      }
      updateBuffer(t) {
        let { _gl: e } = this, r = this.getGlBuffer(t);
        if (t._updateID === r.updateID) return r;
        r.updateID = t._updateID, e.bindBuffer(r.type, r.buffer);
        let s = t.data, o = t.descriptor.usage & K2.STATIC ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
        return s ? r.byteLength >= s.byteLength ? e.bufferSubData(r.type, 0, s, 0, t._updateSize / s.BYTES_PER_ELEMENT) : (r.byteLength = s.byteLength, e.bufferData(r.type, s, o)) : (r.byteLength = t.descriptor.size, e.bufferData(r.type, r.byteLength, o)), r;
      }
      destroyAll() {
        let t = this._gl;
        for (let e in this._gpuBuffers) t.deleteBuffer(this._gpuBuffers[e].buffer);
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      }
      onBufferDestroy(t, e) {
        let r = this._gpuBuffers[t.uid], s = this._gl;
        e || s.deleteBuffer(r.buffer), this._gpuBuffers[t.uid] = null;
      }
      createGLBuffer(t) {
        let { _gl: e } = this, r = _o.ARRAY_BUFFER;
        t.descriptor.usage & K2.INDEX ? r = _o.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & K2.UNIFORM && (r = _o.UNIFORM_BUFFER);
        let s = new va(e.createBuffer(), r);
        return this._gpuBuffers[t.uid] = s, t.on("destroy", this.onBufferDestroy, this), s;
      }
      resetState() {
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
      }
    };
    yo.extension = { type: [_2.WebGLSystem], name: "buffer" };
  });
  var cu;
  var Rb;
  var Gb = p(() => {
    lt2();
    E();
    ot2();
    cu = class Bb {
      constructor(t) {
        this.supports = { uint32Indices: true, uniformBufferObject: true, vertexArrayObject: true, srgbTextures: true, nonPowOf2wrapping: true, msaa: true, nonPowOf2mipmaps: true }, this._renderer = t, this.extensions = /* @__PURE__ */ Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
      }
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      contextChange(t) {
        this.gl = t, this._renderer.gl = t;
      }
      init(t) {
        t = { ...Bb.defaultOptions, ...t };
        let e = this.multiView = t.multiView;
        if (t.context && e && (O2("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), e = false), e ? this.canvas = N.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, t.context) this.initFromContext(t.context);
        else {
          let r = this._renderer.background.alpha < 1, s = t.premultipliedAlpha ?? true, o = t.antialias && !this._renderer.backBuffer.useBackBuffer;
          this.createContext(t.preferWebGLVersion, { alpha: r, premultipliedAlpha: s, antialias: o, stencil: true, preserveDrawingBuffer: t.preserveDrawingBuffer, powerPreference: t.powerPreference ?? "default" });
        }
      }
      ensureCanvasSize(t) {
        if (!this.multiView) {
          t !== this.canvas && O2("multiView is disabled, but targetCanvas is not the main canvas");
          return;
        }
        let { canvas: e } = this;
        (e.width < t.width || e.height < t.height) && (e.width = Math.max(t.width, t.width), e.height = Math.max(t.height, t.height));
      }
      initFromContext(t) {
        this.gl = t, this.webGLVersion = t instanceof N.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this._renderer.runners.contextChange.emit(t);
        let e = this._renderer.view.canvas;
        e.addEventListener("webglcontextlost", this.handleContextLost, false), e.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      createContext(t, e) {
        let r, s = this.canvas;
        if (t === 2 && (r = s.getContext("webgl2", e)), !r && (r = s.getContext("webgl", e), !r)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        this.gl = r, this.initFromContext(this.gl);
      }
      getExtensions() {
        let { gl: t } = this, e = { anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t.getExtension("WEBGL_compressed_texture_etc"), etc1: t.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t.getExtension("WEBGL_compressed_texture_atc"), astc: t.getExtension("WEBGL_compressed_texture_astc"), bptc: t.getExtension("EXT_texture_compression_bptc"), rgtc: t.getExtension("EXT_texture_compression_rgtc"), loseContext: t.getExtension("WEBGL_lose_context") };
        if (this.webGLVersion === 1) this.extensions = { ...e, drawBuffers: t.getExtension("WEBGL_draw_buffers"), depthTexture: t.getExtension("WEBGL_depth_texture"), vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t.getExtension("OES_element_index_uint"), floatTexture: t.getExtension("OES_texture_float"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), textureHalfFloat: t.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"), vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"), srgb: t.getExtension("EXT_sRGB") };
        else {
          this.extensions = { ...e, colorBufferFloat: t.getExtension("EXT_color_buffer_float") };
          let r = t.getExtension("WEBGL_provoking_vertex");
          r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL);
        }
      }
      handleContextLost(t) {
        t.preventDefault(), this._contextLossForced && (this._contextLossForced = false, setTimeout(() => {
          this.gl.isContextLost() && this.extensions.loseContext?.restoreContext();
        }, 0));
      }
      handleContextRestored() {
        this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        let t = this._renderer.view.canvas;
        this._renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext();
      }
      forceContextLoss() {
        this.extensions.loseContext?.loseContext(), this._contextLossForced = true;
      }
      validateContext(t) {
        let e = t.getContextAttributes();
        e && !e.stencil && O2("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        let r = this.supports, s = this.webGLVersion === 2, o = this.extensions;
        r.uint32Indices = s || !!o.uint32ElementIndex, r.uniformBufferObject = s, r.vertexArrayObject = s || !!o.vertexArrayObject, r.srgbTextures = s || !!o.srgb, r.nonPowOf2wrapping = s, r.nonPowOf2mipmaps = s, r.msaa = s, r.uint32Indices || O2("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
      }
    };
    cu.extension = { type: [_2.WebGLSystem], name: "context" };
    cu.defaultOptions = { context: null, premultipliedAlpha: true, preserveDrawingBuffer: false, powerPreference: void 0, preferWebGLVersion: 2, multiView: false };
    Rb = cu;
  });
  var Ta;
  var lu;
  var J2;
  var hu = p(() => {
    "use strict";
    Ta = ((i3) => (i3[i3.RGBA = 6408] = "RGBA", i3[i3.RGB = 6407] = "RGB", i3[i3.RG = 33319] = "RG", i3[i3.RED = 6403] = "RED", i3[i3.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i3[i3.RGB_INTEGER = 36248] = "RGB_INTEGER", i3[i3.RG_INTEGER = 33320] = "RG_INTEGER", i3[i3.RED_INTEGER = 36244] = "RED_INTEGER", i3[i3.ALPHA = 6406] = "ALPHA", i3[i3.LUMINANCE = 6409] = "LUMINANCE", i3[i3.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i3[i3.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i3[i3.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", i3))(Ta || {}), lu = ((i3) => (i3[i3.TEXTURE_2D = 3553] = "TEXTURE_2D", i3[i3.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i3[i3.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i3[i3.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i3[i3.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i3[i3.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i3[i3.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i3[i3.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i3[i3.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", i3))(lu || {}), J2 = ((i3) => (i3[i3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i3[i3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i3[i3.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i3[i3.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i3[i3.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i3[i3.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i3[i3.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i3[i3.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i3[i3.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i3[i3.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i3[i3.BYTE = 5120] = "BYTE", i3[i3.SHORT = 5122] = "SHORT", i3[i3.INT = 5124] = "INT", i3[i3.FLOAT = 5126] = "FLOAT", i3[i3.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i3[i3.HALF_FLOAT = 36193] = "HALF_FLOAT", i3))(J2 || {});
  });
  function Ib(i3) {
    return kb[i3] ?? kb.float32;
  }
  var kb;
  var Fb = p(() => {
    hu();
    kb = { uint8x2: J2.UNSIGNED_BYTE, uint8x4: J2.UNSIGNED_BYTE, sint8x2: J2.BYTE, sint8x4: J2.BYTE, unorm8x2: J2.UNSIGNED_BYTE, unorm8x4: J2.UNSIGNED_BYTE, snorm8x2: J2.BYTE, snorm8x4: J2.BYTE, uint16x2: J2.UNSIGNED_SHORT, uint16x4: J2.UNSIGNED_SHORT, sint16x2: J2.SHORT, sint16x4: J2.SHORT, unorm16x2: J2.UNSIGNED_SHORT, unorm16x4: J2.UNSIGNED_SHORT, snorm16x2: J2.SHORT, snorm16x4: J2.SHORT, float16x2: J2.HALF_FLOAT, float16x4: J2.HALF_FLOAT, float32: J2.FLOAT, float32x2: J2.FLOAT, float32x3: J2.FLOAT, float32x4: J2.FLOAT, uint32: J2.UNSIGNED_INT, uint32x2: J2.UNSIGNED_INT, uint32x3: J2.UNSIGNED_INT, uint32x4: J2.UNSIGNED_INT, sint32: J2.INT, sint32x2: J2.INT, sint32x3: J2.INT, sint32x4: J2.INT };
  });
  var sw;
  var bo;
  var Ub = p(() => {
    E();
    Pr2();
    ru();
    Fb();
    sw = { "point-list": 0, "line-list": 1, "line-strip": 3, "triangle-list": 4, "triangle-strip": 5 }, bo = class {
      constructor(t) {
        this._geometryVaoHash = /* @__PURE__ */ Object.create(null), this._renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
      }
      contextChange() {
        let t = this.gl = this._renderer.gl;
        if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
        let e = this._renderer.context.extensions.vertexArrayObject;
        e && (t.createVertexArray = () => e.createVertexArrayOES(), t.bindVertexArray = (s) => e.bindVertexArrayOES(s), t.deleteVertexArray = (s) => e.deleteVertexArrayOES(s));
        let r = this._renderer.context.extensions.vertexAttribDivisorANGLE;
        r && (t.drawArraysInstanced = (s, o, n, a) => {
          r.drawArraysInstancedANGLE(s, o, n, a);
        }, t.drawElementsInstanced = (s, o, n, a, c) => {
          r.drawElementsInstancedANGLE(s, o, n, a, c);
        }, t.vertexAttribDivisor = (s, o) => r.vertexAttribDivisorANGLE(s, o)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
      }
      bind(t, e) {
        let r = this.gl;
        this._activeGeometry = t;
        let s = this.getVao(t, e);
        this._activeVao !== s && (this._activeVao = s, r.bindVertexArray(s)), this.updateBuffers();
      }
      resetState() {
        this.unbind();
      }
      updateBuffers() {
        let t = this._activeGeometry, e = this._renderer.buffer;
        for (let r = 0; r < t.buffers.length; r++) {
          let s = t.buffers[r];
          e.updateBuffer(s);
        }
      }
      checkCompatibility(t, e) {
        let r = t.attributes, s = e._attributeData;
        for (let o in s) if (!r[o]) throw new Error(`shader and geometry incompatible, geometry missing the "${o}" attribute`);
      }
      getSignature(t, e) {
        let r = t.attributes, s = e._attributeData, o = ["g", t.uid];
        for (let n in r) s[n] && o.push(n, s[n].location);
        return o.join("-");
      }
      getVao(t, e) {
        return this._geometryVaoHash[t.uid]?.[e._key] || this.initGeometryVao(t, e);
      }
      initGeometryVao(t, e, r = true) {
        let s = this._renderer.gl, o = this._renderer.buffer;
        this._renderer.shader._getProgramData(e), this.checkCompatibility(t, e);
        let n = this.getSignature(t, e);
        this._geometryVaoHash[t.uid] || (this._geometryVaoHash[t.uid] = /* @__PURE__ */ Object.create(null), t.on("destroy", this.onGeometryDestroy, this));
        let a = this._geometryVaoHash[t.uid], c = a[n];
        if (c) return a[e._key] = c, c;
        ga(t, e._attributeData);
        let l = t.buffers;
        c = s.createVertexArray(), s.bindVertexArray(c);
        for (let h = 0; h < l.length; h++) {
          let u = l[h];
          o.bind(u);
        }
        return this.activateVao(t, e), a[e._key] = c, a[n] = c, s.bindVertexArray(null), c;
      }
      onGeometryDestroy(t, e) {
        let r = this._geometryVaoHash[t.uid], s = this.gl;
        if (r) {
          if (e) for (let o in r) this._activeVao !== r[o] && this.unbind(), s.deleteVertexArray(r[o]);
          this._geometryVaoHash[t.uid] = null;
        }
      }
      destroyAll(t = false) {
        let e = this.gl;
        for (let r in this._geometryVaoHash) {
          if (t) for (let s in this._geometryVaoHash[r]) {
            let o = this._geometryVaoHash[r];
            this._activeVao !== o && this.unbind(), e.deleteVertexArray(o[s]);
          }
          this._geometryVaoHash[r] = null;
        }
      }
      activateVao(t, e) {
        let r = this._renderer.gl, s = this._renderer.buffer, o = t.attributes;
        t.indexBuffer && s.bind(t.indexBuffer);
        let n = null;
        for (let a in o) {
          let c = o[a], l = c.buffer, h = s.getGlBuffer(l), u = e._attributeData[a];
          if (u) {
            n !== h && (s.bind(l), n = h);
            let f = u.location;
            r.enableVertexAttribArray(f);
            let d2 = Zt2(c.format), m = Ib(c.format);
            if (u.format?.substring(1, 4) === "int" ? r.vertexAttribIPointer(f, d2.size, m, c.stride, c.offset) : r.vertexAttribPointer(f, d2.size, m, d2.normalised, c.stride, c.offset), c.instance) if (this.hasInstance) {
              let g = c.divisor ?? 1;
              r.vertexAttribDivisor(f, g);
            } else throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
      draw(t, e, r, s) {
        let { gl: o } = this._renderer, n = this._activeGeometry, a = sw[t || n.topology];
        if (s ?? (s = n.instanceCount), n.indexBuffer) {
          let c = n.indexBuffer.data.BYTES_PER_ELEMENT, l = c === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT;
          s > 1 ? o.drawElementsInstanced(a, e || n.indexBuffer.data.length, l, (r || 0) * c, s) : o.drawElements(a, e || n.indexBuffer.data.length, l, (r || 0) * c);
        } else s > 1 ? o.drawArraysInstanced(a, r || 0, e || n.getSize(), s) : o.drawArrays(a, r || 0, e || n.getSize());
        return this;
      }
      unbind() {
        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
      }
      destroy() {
        this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null;
      }
    };
    bo.extension = { type: [_2.WebGLSystem], name: "geometry" };
  });
  var ow;
  var uu;
  var Ob;
  var Lb = p(() => {
    E();
    ot2();
    Kr2();
    me2();
    ge2();
    jt2();
    rt2();
    wr2();
    ow = new ae2({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } }), uu = class Db {
      constructor(t) {
        this.useBackBuffer = false, this._useBackBufferThisRender = false, this._renderer = t;
      }
      init(t = {}) {
        let { useBackBuffer: e, antialias: r } = { ...Db.defaultOptions, ...t };
        this.useBackBuffer = e, this._antialias = r, this._renderer.context.supports.msaa || (O2("antialiasing, is not supported on when using the back buffer"), this._antialias = false), this._state = bt2.for2d();
        let s = new ce2({ vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`, fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`, name: "big-triangle" });
        this._bigTriangleShader = new yt2({ glProgram: s, resources: { uTexture: B.WHITE.source } });
      }
      renderStart(t) {
        let e = this._renderer.renderTarget.getRenderTarget(t.target);
        if (this._useBackBufferThisRender = this.useBackBuffer && !!e.isRoot, this._useBackBufferThisRender) {
          let r = this._renderer.renderTarget.getRenderTarget(t.target);
          this._targetTexture = r.colorTexture, t.target = this._getBackBufferTexture(r.colorTexture);
        }
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        let t = this._renderer;
        t.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (t.renderTarget.bind(this._targetTexture, false), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, t.encoder.draw({ geometry: ow, shader: this._bigTriangleShader, state: this._state }));
      }
      _getBackBufferTexture(t) {
        return this._backBufferTexture = this._backBufferTexture || new B({ source: new et3({ width: t.width, height: t.height, resolution: t._resolution, antialias: this._antialias }) }), this._backBufferTexture.source.resize(t.width, t.height, t._resolution), this._backBufferTexture;
      }
      destroy() {
        this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
      }
    };
    uu.extension = { type: [_2.WebGLSystem], name: "backBuffer", priority: 1 };
    uu.defaultOptions = { useBackBuffer: false };
    Ob = uu;
  });
  var vo;
  var Nb = p(() => {
    E();
    vo = class {
      constructor(t) {
        this._colorMaskCache = 15, this._renderer = t;
      }
      setMask(t) {
        this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.gl.colorMask(!!(t & 8), !!(t & 4), !!(t & 2), !!(t & 1)));
      }
    };
    vo.extension = { type: [_2.WebGLSystem], name: "colorMask" };
  });
  var To;
  var Hb = p(() => {
    E();
    To = class {
      constructor(t) {
        this.commandFinished = Promise.resolve(), this._renderer = t;
      }
      setGeometry(t, e) {
        this._renderer.geometry.bind(t, e.glProgram);
      }
      finishRenderPass() {
      }
      draw(t) {
        let e = this._renderer, { geometry: r, shader: s, state: o, skipSync: n, topology: a, size: c, start: l, instanceCount: h } = t;
        e.shader.bind(s, n), e.geometry.bind(r, e.shader._activeProgram), o && e.state.set(o), e.geometry.draw(a, c, l, h ?? r.instanceCount);
      }
      destroy() {
        this._renderer = null;
      }
    };
    To.extension = { type: [_2.WebGLSystem], name: "encoder" };
  });
  var So;
  var Wb = p(() => {
    E();
    iu();
    Sr2();
    So = class {
      constructor(t) {
        this._stencilCache = { enabled: false, stencilReference: 0, stencilMode: ht2.NONE }, this._renderTargetStencilState = /* @__PURE__ */ Object.create(null), t.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(t) {
        this._gl = t, this._comparisonFuncMapping = { always: t.ALWAYS, never: t.NEVER, equal: t.EQUAL, "not-equal": t.NOTEQUAL, less: t.LESS, "less-equal": t.LEQUAL, greater: t.GREATER, "greater-equal": t.GEQUAL }, this._stencilOpsMapping = { keep: t.KEEP, zero: t.ZERO, replace: t.REPLACE, invert: t.INVERT, "increment-clamp": t.INCR, "decrement-clamp": t.DECR, "increment-wrap": t.INCR_WRAP, "decrement-wrap": t.DECR_WRAP }, this.resetState();
      }
      onRenderTargetChange(t) {
        if (this._activeRenderTarget === t) return;
        this._activeRenderTarget = t;
        let e = this._renderTargetStencilState[t.uid];
        e || (e = this._renderTargetStencilState[t.uid] = { stencilMode: ht2.DISABLED, stencilReference: 0 }), this.setStencilMode(e.stencilMode, e.stencilReference);
      }
      resetState() {
        this._stencilCache.enabled = false, this._stencilCache.stencilMode = ht2.NONE, this._stencilCache.stencilReference = 0;
      }
      setStencilMode(t, e) {
        let r = this._renderTargetStencilState[this._activeRenderTarget.uid], s = this._gl, o = Be2[t], n = this._stencilCache;
        if (r.stencilMode = t, r.stencilReference = e, t === ht2.DISABLED) {
          this._stencilCache.enabled && (this._stencilCache.enabled = false, s.disable(s.STENCIL_TEST));
          return;
        }
        this._stencilCache.enabled || (this._stencilCache.enabled = true, s.enable(s.STENCIL_TEST)), (t !== n.stencilMode || n.stencilReference !== e) && (n.stencilMode = t, n.stencilReference = e, s.stencilFunc(this._comparisonFuncMapping[o.stencilBack.compare], e, 255), s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[o.stencilBack.passOp]));
      }
    };
    So.extension = { type: [_2.WebGLSystem], name: "stencil" };
  });
  function zb(i3) {
    let t = i3.map((o) => ({ data: o, offset: 0, size: 0 })), e = 16, r = 0, s = 0;
    for (let o = 0; o < t.length; o++) {
      let n = t[o];
      if (r = du[n.data.type], !r) throw new Error(`Unknown type ${n.data.type}`);
      n.data.size > 1 && (r = Math.max(r, e) * n.data.size);
      let a = r === 12 ? 16 : r;
      n.size = r;
      let c = s % e;
      c > 0 && e - c < a ? s += (e - c) % 16 : s += (r - c % r) % r, n.offset = s, s += r;
    }
    return s = Math.ceil(s / 16) * 16, { uboElements: t, size: s };
  }
  var du;
  var fu = p(() => {
    "use strict";
    du = { f32: 4, i32: 4, "vec2<f32>": 8, "vec3<f32>": 12, "vec4<f32>": 16, "vec2<i32>": 8, "vec3<i32>": 12, "vec4<i32>": 16, "mat2x2<f32>": 32, "mat3x3<f32>": 48, "mat4x4<f32>": 64 };
  });
  function Vb(i3, t) {
    let e = Math.max(du[i3.data.type] / 16, 1), r = i3.data.value.length / i3.data.size, s = (4 - r % 4) % 4, o = i3.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
        v = uv.${i3.data.name};
        offset += ${t};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i3.data.size * e}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                ${o}[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `;
  }
  var Xb = p(() => {
    fu();
  });
  function Yb(i3) {
    return fa(i3, "uboStd40", Vb, tu);
  }
  var $b = p(() => {
    Jh();
    eu();
    Xb();
  });
  var wo;
  var jb = p(() => {
    E();
    qh();
    fu();
    $b();
    wo = class extends Ai {
      constructor() {
        super({ createUboElements: zb, generateUboSync: Yb });
      }
    };
    wo.extension = { type: [_2.WebGLSystem], name: "ubo" };
  });
  var Sa;
  var Kb = p(() => {
    "use strict";
    Sa = class {
      constructor() {
        this.width = -1, this.height = -1, this.msaa = false, this.msaaRenderBuffer = [];
      }
    };
  });
  var wa;
  var qb = p(() => {
    St2();
    ot2();
    Vr2();
    vi();
    Kb();
    wa = class {
      constructor() {
        this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new Y2();
      }
      init(t, e) {
        this._renderer = t, this._renderTargetSystem = e, t.runners.contextChange.add(this);
      }
      contextChange() {
        this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new Y2();
      }
      copyToTexture(t, e, r, s, o) {
        let n = this._renderTargetSystem, a = this._renderer, c = n.getGpuRenderTarget(t), l = a.gl;
        return this.finishRenderPass(t), l.bindFramebuffer(l.FRAMEBUFFER, c.resolveTargetFramebuffer), a.texture.bind(e, 0), l.copyTexSubImage2D(l.TEXTURE_2D, 0, o.x, o.y, r.x, r.y, s.width, s.height), e;
      }
      startRenderPass(t, e = true, r, s) {
        let o = this._renderTargetSystem, n = t.colorTexture, a = o.getGpuRenderTarget(t), c = s.y;
        t.isRoot && (c = n.pixelHeight - s.height), t.colorTextures.forEach((u) => {
          this._renderer.texture.unbind(u);
        });
        let l = this._renderer.gl;
        l.bindFramebuffer(l.FRAMEBUFFER, a.framebuffer);
        let h = this._viewPortCache;
        (h.x !== s.x || h.y !== c || h.width !== s.width || h.height !== s.height) && (h.x = s.x, h.y = c, h.width = s.width, h.height = s.height, l.viewport(s.x, c, s.width, s.height)), !a.depthStencilRenderBuffer && (t.stencil || t.depth) && this._initStencil(a), this.clear(t, e, r);
      }
      finishRenderPass(t) {
        let r = this._renderTargetSystem.getGpuRenderTarget(t);
        if (!r.msaa) return;
        let s = this._renderer.gl;
        s.bindFramebuffer(s.FRAMEBUFFER, r.resolveTargetFramebuffer), s.bindFramebuffer(s.READ_FRAMEBUFFER, r.framebuffer), s.blitFramebuffer(0, 0, r.width, r.height, 0, 0, r.width, r.height, s.COLOR_BUFFER_BIT, s.NEAREST), s.bindFramebuffer(s.FRAMEBUFFER, r.framebuffer);
      }
      initGpuRenderTarget(t) {
        let r = this._renderer.gl, s = new Sa(), o = t.colorTexture;
        return Ot2.test(o.resource) ? (this._renderer.context.ensureCanvasSize(t.colorTexture.resource), s.framebuffer = null, s) : (this._initColor(t, s), r.bindFramebuffer(r.FRAMEBUFFER, null), s);
      }
      destroyGpuRenderTarget(t) {
        let e = this._renderer.gl;
        t.framebuffer && (e.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (e.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (e.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach((r) => {
          e.deleteRenderbuffer(r);
        }), t.msaaRenderBuffer = null;
      }
      clear(t, e, r) {
        if (!e) return;
        let s = this._renderTargetSystem;
        typeof e == "boolean" && (e = e ? Bt2.ALL : Bt2.NONE);
        let o = this._renderer.gl;
        if (e & Bt2.COLOR) {
          r ?? (r = s.defaultClearColor);
          let n = this._clearColorCache, a = r;
          (n[0] !== a[0] || n[1] !== a[1] || n[2] !== a[2] || n[3] !== a[3]) && (n[0] = a[0], n[1] = a[1], n[2] = a[2], n[3] = a[3], o.clearColor(a[0], a[1], a[2], a[3]));
        }
        o.clear(e);
      }
      resizeGpuRenderTarget(t) {
        if (t.isRoot) return;
        let r = this._renderTargetSystem.getGpuRenderTarget(t);
        this._resizeColor(t, r), (t.stencil || t.depth) && this._resizeStencil(r);
      }
      _initColor(t, e) {
        let r = this._renderer, s = r.gl, o = s.createFramebuffer();
        if (e.resolveTargetFramebuffer = o, s.bindFramebuffer(s.FRAMEBUFFER, o), e.width = t.colorTexture.source.pixelWidth, e.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((n, a) => {
          let c = n.source;
          c.antialias && (r.context.supports.msaa ? e.msaa = true : O2("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), r.texture.bindSource(c, 0);
          let h = r.texture.getGlSource(c).texture;
          s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + a, 3553, h, 0);
        }), e.msaa) {
          let n = s.createFramebuffer();
          e.framebuffer = n, s.bindFramebuffer(s.FRAMEBUFFER, n), t.colorTextures.forEach((a, c) => {
            let l = s.createRenderbuffer();
            e.msaaRenderBuffer[c] = l;
          });
        } else e.framebuffer = o;
        this._resizeColor(t, e);
      }
      _resizeColor(t, e) {
        let r = t.colorTexture.source;
        if (e.width = r.pixelWidth, e.height = r.pixelHeight, t.colorTextures.forEach((s, o) => {
          o !== 0 && s.source.resize(r.width, r.height, r._resolution);
        }), e.msaa) {
          let s = this._renderer, o = s.gl, n = e.framebuffer;
          o.bindFramebuffer(o.FRAMEBUFFER, n), t.colorTextures.forEach((a, c) => {
            let l = a.source;
            s.texture.bindSource(l, 0);
            let u = s.texture.getGlSource(l).internalFormat, f = e.msaaRenderBuffer[c];
            o.bindRenderbuffer(o.RENDERBUFFER, f), o.renderbufferStorageMultisample(o.RENDERBUFFER, 4, u, l.pixelWidth, l.pixelHeight), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + c, o.RENDERBUFFER, f);
          });
        }
      }
      _initStencil(t) {
        if (t.framebuffer === null) return;
        let e = this._renderer.gl, r = e.createRenderbuffer();
        t.depthStencilRenderBuffer = r, e.bindRenderbuffer(e.RENDERBUFFER, r), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, r), this._resizeStencil(t);
      }
      _resizeStencil(t) {
        let e = this._renderer.gl;
        e.bindRenderbuffer(e.RENDERBUFFER, t.depthStencilRenderBuffer), t.msaa ? e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL, t.width, t.height);
      }
      prerender(t) {
        let e = t.colorTexture.resource;
        this._renderer.context.multiView && Ot2.test(e) && this._renderer.context.ensureCanvasSize(e);
      }
      postrender(t) {
        if (this._renderer.context.multiView && Ot2.test(t.colorTexture.resource)) {
          let e = this._renderer.context.canvas, r = t.colorTexture;
          r.context2D.drawImage(e, 0, r.pixelHeight - e.height);
        }
      }
    };
  });
  var Po;
  var Zb = p(() => {
    E();
    su();
    qb();
    Po = class extends Ei {
      constructor(t) {
        super(t), this.adaptor = new wa(), this.adaptor.init(t, this);
      }
    };
    Po.extension = { type: [_2.WebGLSystem], name: "renderTarget" };
  });
  function Qb(i3, t) {
    let e = [], r = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `], s = false, o = 0, n = t._getProgramData(i3.glProgram);
    for (let c in i3.groups) {
      let l = i3.groups[c];
      e.push(`
            resources = g[${c}].resources;
        `);
      for (let h in l.resources) {
        let u = l.resources[h];
        if (u instanceof nt2) if (u.ubo) {
          let f = i3._uniformBindMap[c][Number(h)];
          e.push(`
                        sS.bindUniformBlock(
                            resources[${h}],
                            '${f}',
                            ${i3.glProgram._uniformBlockData[f].index}
                        );
                    `);
        } else e.push(`
                        ugS.updateUniformGroup(resources[${h}], p, sD);
                    `);
        else if (u instanceof ir2) {
          let f = i3._uniformBindMap[c][Number(h)];
          e.push(`
                    sS.bindUniformBlock(
                        resources[${h}],
                        '${f}',
                        ${i3.glProgram._uniformBlockData[f].index}
                    );
                `);
        } else if (u instanceof et3) {
          let f = i3._uniformBindMap[c][h], d2 = n.uniformData[f];
          d2 && (s || (s = true, r.push(`
                        var tS = r.texture;
                        `)), t._gl.uniform1i(d2.location, o), e.push(`
                        tS.bind(resources[${h}], ${o});
                    `), o++);
        }
      }
    }
    let a = [...r, ...e].join(`
`);
    return new Function("r", "s", "sD", a);
  }
  var Jb = p(() => {
    pa();
    zt2();
    jt2();
  });
  var Pa;
  var tv = p(() => {
    "use strict";
    Pa = class {
      constructor(t, e) {
        this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {};
      }
      destroy() {
        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null;
      }
    };
  });
  function pu(i3, t, e) {
    let r = i3.createShader(t);
    return i3.shaderSource(r, e), i3.compileShader(r), r;
  }
  var ev = p(() => {
    "use strict";
  });
  function mu(i3) {
    let t = new Array(i3);
    for (let e = 0; e < t.length; e++) t[e] = false;
    return t;
  }
  function Aa(i3, t) {
    switch (i3) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * t);
      case "vec3":
        return new Float32Array(3 * t);
      case "vec4":
        return new Float32Array(4 * t);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * t);
      case "ivec3":
        return new Int32Array(3 * t);
      case "ivec4":
        return new Int32Array(4 * t);
      case "uvec2":
        return new Uint32Array(2 * t);
      case "uvec3":
        return new Uint32Array(3 * t);
      case "uvec4":
        return new Uint32Array(4 * t);
      case "bool":
        return false;
      case "bvec2":
        return mu(2 * t);
      case "bvec3":
        return mu(3 * t);
      case "bvec4":
        return mu(4 * t);
      case "mat2":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    return null;
  }
  var gu = p(() => {
    "use strict";
  });
  function xu(i3, t) {
    if (!Ca) {
      let e = Object.keys(rv);
      Ca = {};
      for (let r = 0; r < e.length; ++r) {
        let s = e[r];
        Ca[i3[s]] = rv[s];
      }
    }
    return Ca[t];
  }
  function iv(i3, t) {
    let e = xu(i3, t);
    return nw[e] || "float32";
  }
  var Ca;
  var rv;
  var nw;
  var _u = p(() => {
    "use strict";
    Ca = null, rv = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" }, nw = { float: "float32", vec2: "float32x2", vec3: "float32x3", vec4: "float32x4", int: "sint32", ivec2: "sint32x2", ivec3: "sint32x3", ivec4: "sint32x4", uint: "uint32", uvec2: "uint32x2", uvec3: "uint32x3", uvec4: "uint32x4", bool: "uint32", bvec2: "uint32x2", bvec3: "uint32x3", bvec4: "uint32x4" };
  });
  function sv(i3, t, e = false) {
    let r = {}, s = t.getProgramParameter(i3, t.ACTIVE_ATTRIBUTES);
    for (let n = 0; n < s; n++) {
      let a = t.getActiveAttrib(i3, n);
      if (a.name.startsWith("gl_")) continue;
      let c = iv(t, a.type);
      r[a.name] = { location: 0, format: c, stride: Zt2(c).stride, offset: 0, instance: false, start: 0 };
    }
    let o = Object.keys(r);
    if (e) {
      o.sort((n, a) => n > a ? 1 : -1);
      for (let n = 0; n < o.length; n++) r[o[n]].location = n, t.bindAttribLocation(i3, n, o[n]);
      t.linkProgram(i3);
    } else for (let n = 0; n < o.length; n++) r[o[n]].location = t.getAttribLocation(i3, o[n]);
    return r;
  }
  var ov = p(() => {
    Pr2();
    _u();
  });
  function nv(i3, t) {
    if (!t.ACTIVE_UNIFORM_BLOCKS) return {};
    let e = {}, r = t.getProgramParameter(i3, t.ACTIVE_UNIFORM_BLOCKS);
    for (let s = 0; s < r; s++) {
      let o = t.getActiveUniformBlockName(i3, s), n = t.getUniformBlockIndex(i3, o), a = t.getActiveUniformBlockParameter(i3, s, t.UNIFORM_BLOCK_DATA_SIZE);
      e[o] = { name: o, index: n, size: a };
    }
    return e;
  }
  var av = p(() => {
    "use strict";
  });
  function cv(i3, t) {
    let e = {}, r = t.getProgramParameter(i3, t.ACTIVE_UNIFORMS);
    for (let s = 0; s < r; s++) {
      let o = t.getActiveUniform(i3, s), n = o.name.replace(/\[.*?\]$/, ""), a = !!o.name.match(/\[.*?\]$/), c = xu(t, o.type);
      e[n] = { name: n, index: s, type: c, size: o.size, isArray: a, value: Aa(c, o.size) };
    }
    return e;
  }
  var lv = p(() => {
    gu();
    _u();
  });
  function hv(i3, t) {
    let e = i3.getShaderSource(t).split(`
`).map((l, h) => `${h}: ${l}`), r = i3.getShaderInfoLog(t), s = r.split(`
`), o = {}, n = s.map((l) => parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((l) => l && !o[l] ? (o[l] = true, true) : false), a = [""];
    n.forEach((l) => {
      e[l - 1] = `%c${e[l - 1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    let c = e.join(`
`);
    a[0] = c, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd();
  }
  function uv(i3, t, e, r) {
    i3.getProgramParameter(t, i3.LINK_STATUS) || (i3.getShaderParameter(e, i3.COMPILE_STATUS) || hv(i3, e), i3.getShaderParameter(r, i3.COMPILE_STATUS) || hv(i3, r), console.error("PixiJS Error: Could not initialize shader."), i3.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i3.getProgramInfoLog(t)));
  }
  var dv2 = p(() => {
    "use strict";
  });
  function fv(i3, t) {
    let e = pu(i3, i3.VERTEX_SHADER, t.vertex), r = pu(i3, i3.FRAGMENT_SHADER, t.fragment), s = i3.createProgram();
    i3.attachShader(s, e), i3.attachShader(s, r);
    let o = t.transformFeedbackVaryings;
    o && (typeof i3.transformFeedbackVaryings != "function" ? O2("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : i3.transformFeedbackVaryings(s, o.names, o.bufferMode === "separate" ? i3.SEPARATE_ATTRIBS : i3.INTERLEAVED_ATTRIBS)), i3.linkProgram(s), i3.getProgramParameter(s, i3.LINK_STATUS) || uv(i3, s, e, r), t._attributeData = sv(s, i3, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertex)), t._uniformData = cv(s, i3), t._uniformBlockData = nv(s, i3), i3.deleteShader(e), i3.deleteShader(r);
    let n = {};
    for (let c in t._uniformData) {
      let l = t._uniformData[c];
      n[c] = { location: i3.getUniformLocation(s, c), value: Aa(l.type, l.size) };
    }
    return new Pa(s, n);
  }
  var pv = p(() => {
    ot2();
    tv();
    ev();
    gu();
    ov();
    av();
    lv();
    dv2();
  });
  var Ea;
  var Ao;
  var mv = p(() => {
    E();
    Tr2();
    Jb();
    pv();
    Ea = { textureCount: 0, blockIndex: 0 }, Ao = class {
      constructor(t) {
        this._activeProgram = null, this._programDataHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
      }
      contextChange(t) {
        this._gl = t, this._programDataHash = /* @__PURE__ */ Object.create(null), this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null), this._activeProgram = null, this.maxTextures = ne2();
      }
      bind(t, e) {
        if (this._setProgram(t.glProgram), e) return;
        Ea.textureCount = 0, Ea.blockIndex = 0;
        let r = this._shaderSyncFunctions[t.glProgram._key];
        r || (r = this._shaderSyncFunctions[t.glProgram._key] = this._generateShaderSync(t, this)), this._renderer.buffer.nextBindBase(!!t.glProgram.transformFeedbackVaryings), r(this._renderer, t, Ea);
      }
      updateUniformGroup(t) {
        this._renderer.uniformGroup.updateUniformGroup(t, this._activeProgram, Ea);
      }
      bindUniformBlock(t, e, r = 0) {
        let s = this._renderer.buffer, o = this._getProgramData(this._activeProgram), n = t._bufferResource;
        n || this._renderer.ubo.updateUniformGroup(t);
        let a = t.buffer, c = s.updateBuffer(a), l = s.freeLocationForBufferBase(c);
        if (n) {
          let { offset: u, size: f } = t;
          u === 0 && f === a.data.byteLength ? s.bindBufferBase(c, l) : s.bindBufferRange(c, l, u);
        } else s.getLastBindBaseLocation(c) !== l && s.bindBufferBase(c, l);
        let h = this._activeProgram._uniformBlockData[e].index;
        o.uniformBlockBindings[r] !== l && (o.uniformBlockBindings[r] = l, this._renderer.gl.uniformBlockBinding(o.program, h, l));
      }
      _setProgram(t) {
        if (this._activeProgram === t) return;
        this._activeProgram = t;
        let e = this._getProgramData(t);
        this._gl.useProgram(e.program);
      }
      _getProgramData(t) {
        return this._programDataHash[t._key] || this._createProgramData(t);
      }
      _createProgramData(t) {
        let e = t._key;
        return this._programDataHash[e] = fv(this._gl, t), this._programDataHash[e];
      }
      destroy() {
        for (let t of Object.keys(this._programDataHash)) this._programDataHash[t].destroy(), this._programDataHash[t] = null;
        this._programDataHash = null;
      }
      _generateShaderSync(t, e) {
        return Qb(t, e);
      }
      resetState() {
        this._activeProgram = null;
      }
    };
    Ao.extension = { type: [_2.WebGLSystem], name: "shader" };
  });
  var gv;
  var xv;
  var _v = p(() => {
    "use strict";
    gv = { f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`, "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`, "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`, "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`, i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`, "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`, "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`, "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`, u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`, "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`, "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`, "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`, bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`, "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`, "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`, "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`, "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);" }, xv = { f32: "gl.uniform1fv(location, v);", "vec2<f32>": "gl.uniform2fv(location, v);", "vec3<f32>": "gl.uniform3fv(location, v);", "vec4<f32>": "gl.uniform4fv(location, v);", "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);", i32: "gl.uniform1iv(location, v);", "vec2<i32>": "gl.uniform2iv(location, v);", "vec3<i32>": "gl.uniform3iv(location, v);", "vec4<i32>": "gl.uniform4iv(location, v);", u32: "gl.uniform1iv(location, v);", "vec2<u32>": "gl.uniform2iv(location, v);", "vec3<u32>": "gl.uniform3iv(location, v);", "vec4<u32>": "gl.uniform4iv(location, v);", bool: "gl.uniform1iv(location, v);", "vec2<bool>": "gl.uniform2iv(location, v);", "vec3<bool>": "gl.uniform3iv(location, v);", "vec4<bool>": "gl.uniform4iv(location, v);" };
  });
  function yv(i3, t) {
    let e = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (let r in i3.uniforms) {
      if (!t[r]) {
        i3.uniforms[r] instanceof nt2 ? i3.uniforms[r].ubo ? e.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : e.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : i3.uniforms[r] instanceof ir2 && e.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `);
        continue;
      }
      let s = i3.uniformStructures[r], o = false;
      for (let n = 0; n < We2.length; n++) {
        let a = We2[n];
        if (s.type === a.type && a.test(s)) {
          e.push(`name = "${r}";`, We2[n].uniform), o = true;
          break;
        }
      }
      if (!o) {
        let a = (s.size === 1 ? gv : xv)[s.type].replace("location", `ud["${r}"].location`);
        e.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", e.join(`
`));
  }
  var bv = p(() => {
    pa();
    zt2();
    Qh();
    _v();
  });
  var Co;
  var vv = p(() => {
    E();
    bv();
    Co = class {
      constructor(t) {
        this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = t, this.gl = null, this._cache = {};
      }
      contextChange(t) {
        this.gl = t;
      }
      updateUniformGroup(t, e, r) {
        let s = this._renderer.shader._getProgramData(e);
        (!t.isStatic || t._dirtyId !== s.uniformDirtyGroups[t.uid]) && (s.uniformDirtyGroups[t.uid] = t._dirtyId, this._getUniformSyncFunction(t, e)(s.uniformData, t.uniforms, this._renderer, r));
      }
      _getUniformSyncFunction(t, e) {
        return this._uniformGroupSyncHash[t._signature]?.[e._key] || this._createUniformSyncFunction(t, e);
      }
      _createUniformSyncFunction(t, e) {
        let r = this._uniformGroupSyncHash[t._signature] || (this._uniformGroupSyncHash[t._signature] = {}), s = this._getSignature(t, e._uniformData, "u");
        return this._cache[s] || (this._cache[s] = this._generateUniformsSync(t, e._uniformData)), r[e._key] = this._cache[s], r[e._key];
      }
      _generateUniformsSync(t, e) {
        return yv(t, e);
      }
      _getSignature(t, e, r) {
        let s = t.uniforms, o = [`${r}-`];
        for (let n in s) o.push(n), e[n] && o.push(e[n].type);
        return o.join("-");
      }
      destroy() {
        this._renderer = null, this._cache = null;
      }
    };
    Co.extension = { type: [_2.WebGLSystem], name: "uniformGroup" };
  });
  function Tv(i3) {
    let t = {};
    if (t.normal = [i3.ONE, i3.ONE_MINUS_SRC_ALPHA], t.add = [i3.ONE, i3.ONE], t.multiply = [i3.DST_COLOR, i3.ONE_MINUS_SRC_ALPHA, i3.ONE, i3.ONE_MINUS_SRC_ALPHA], t.screen = [i3.ONE, i3.ONE_MINUS_SRC_COLOR, i3.ONE, i3.ONE_MINUS_SRC_ALPHA], t.none = [0, 0], t["normal-npm"] = [i3.SRC_ALPHA, i3.ONE_MINUS_SRC_ALPHA, i3.ONE, i3.ONE_MINUS_SRC_ALPHA], t["add-npm"] = [i3.SRC_ALPHA, i3.ONE, i3.ONE, i3.ONE], t["screen-npm"] = [i3.SRC_ALPHA, i3.ONE_MINUS_SRC_COLOR, i3.ONE, i3.ONE_MINUS_SRC_ALPHA], t.erase = [i3.ZERO, i3.ONE_MINUS_SRC_ALPHA], !(i3 instanceof N.get().getWebGLRenderingContext())) t.min = [i3.ONE, i3.ONE, i3.ONE, i3.ONE, i3.MIN, i3.MIN], t.max = [i3.ONE, i3.ONE, i3.ONE, i3.ONE, i3.MAX, i3.MAX];
    else {
      let r = i3.getExtension("EXT_blend_minmax");
      r && (t.min = [i3.ONE, i3.ONE, i3.ONE, i3.ONE, r.MIN_EXT, r.MIN_EXT], t.max = [i3.ONE, i3.ONE, i3.ONE, i3.ONE, r.MAX_EXT, r.MAX_EXT]);
    }
    return t;
  }
  var Sv = p(() => {
    lt2();
  });
  var aw;
  var cw;
  var lw;
  var hw;
  var uw;
  var dw;
  var wv;
  var Pv;
  var Av = p(() => {
    E();
    ge2();
    Sv();
    aw = 0, cw = 1, lw = 2, hw = 3, uw = 4, dw = 5, wv = class yu {
      constructor(t) {
        this._invertFrontFace = false, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = false, this.map = [], this.map[aw] = this.setBlend, this.map[cw] = this.setOffset, this.map[lw] = this.setCullFace, this.map[hw] = this.setDepthTest, this.map[uw] = this.setFrontFace, this.map[dw] = this.setDepthMask, this.checks = [], this.defaultState = bt2.for2d(), t.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(t) {
        this._invertFrontFace = !t.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = true;
      }
      contextChange(t) {
        this.gl = t, this.blendModesMap = Tv(t), this.resetState();
      }
      set(t) {
        if (t || (t = this.defaultState), this.stateId !== t.data) {
          let e = this.stateId ^ t.data, r = 0;
          for (; e; ) e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e >>= 1, r++;
          this.stateId = t.data;
        }
        for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t);
      }
      forceState(t) {
        t || (t = this.defaultState);
        for (let e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
        for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t);
        this.stateId = t.data;
      }
      setBlend(t) {
        this._updateCheck(yu._checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
      }
      setOffset(t) {
        this._updateCheck(yu._checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      setDepthTest(t) {
        this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      setDepthMask(t) {
        this.gl.depthMask(t);
      }
      setCullFace(t) {
        this._cullFace = t, this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace);
      }
      setFrontFace(t) {
        this._frontFace = t, this._frontFaceDirty = false;
        let e = this._invertFrontFace ? !t : t;
        this._glFrontFace !== e && (this._glFrontFace = e, this.gl.frontFace(this.gl[e ? "CW" : "CCW"]));
      }
      setBlendMode(t) {
        if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode) return;
        this.blendMode = t;
        let e = this.blendModesMap[t], r = this.gl;
        e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = true, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = false, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));
      }
      setPolygonOffset(t, e) {
        this.gl.polygonOffset(t, e);
      }
      resetState() {
        this._glFrontFace = false, this._frontFace = false, this._cullFace = false, this._frontFaceDirty = false, this._invertFrontFace = false, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = "", this.setBlendMode("normal");
      }
      _updateCheck(t, e) {
        let r = this.checks.indexOf(t);
        e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);
      }
      static _checkBlendMode(t, e) {
        t.setBlendMode(e.blendMode);
      }
      static _checkPolygonOffset(t, e) {
        t.setPolygonOffset(1, e.polygonOffset);
      }
      destroy() {
        this.gl = null, this.checks.length = 0;
      }
    };
    wv.extension = { type: [_2.WebGLSystem], name: "state" };
    Pv = wv;
  });
  var Ma;
  var Cv = p(() => {
    hu();
    Ma = class {
      constructor(t) {
        this.target = lu.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = J2.UNSIGNED_BYTE, this.internalFormat = Ta.RGBA, this.format = Ta.RGBA, this.samplerType = 0;
      }
    };
  });
  var Ev;
  var Mv = p(() => {
    "use strict";
    Ev = { id: "buffer", upload(i3, t, e) {
      t.width === i3.width || t.height === i3.height ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, i3.width, i3.height, t.format, t.type, i3.resource) : e.texImage2D(t.target, 0, t.internalFormat, i3.width, i3.height, 0, t.format, t.type, i3.resource), t.width = i3.width, t.height = i3.height;
    } };
  });
  var fw;
  var Bv;
  var Rv = p(() => {
    "use strict";
    fw = { "bc1-rgba-unorm": true, "bc1-rgba-unorm-srgb": true, "bc2-rgba-unorm": true, "bc2-rgba-unorm-srgb": true, "bc3-rgba-unorm": true, "bc3-rgba-unorm-srgb": true, "bc4-r-unorm": true, "bc4-r-snorm": true, "bc5-rg-unorm": true, "bc5-rg-snorm": true, "bc6h-rgb-ufloat": true, "bc6h-rgb-float": true, "bc7-rgba-unorm": true, "bc7-rgba-unorm-srgb": true, "etc2-rgb8unorm": true, "etc2-rgb8unorm-srgb": true, "etc2-rgb8a1unorm": true, "etc2-rgb8a1unorm-srgb": true, "etc2-rgba8unorm": true, "etc2-rgba8unorm-srgb": true, "eac-r11unorm": true, "eac-r11snorm": true, "eac-rg11unorm": true, "eac-rg11snorm": true, "astc-4x4-unorm": true, "astc-4x4-unorm-srgb": true, "astc-5x4-unorm": true, "astc-5x4-unorm-srgb": true, "astc-5x5-unorm": true, "astc-5x5-unorm-srgb": true, "astc-6x5-unorm": true, "astc-6x5-unorm-srgb": true, "astc-6x6-unorm": true, "astc-6x6-unorm-srgb": true, "astc-8x5-unorm": true, "astc-8x5-unorm-srgb": true, "astc-8x6-unorm": true, "astc-8x6-unorm-srgb": true, "astc-8x8-unorm": true, "astc-8x8-unorm-srgb": true, "astc-10x5-unorm": true, "astc-10x5-unorm-srgb": true, "astc-10x6-unorm": true, "astc-10x6-unorm-srgb": true, "astc-10x8-unorm": true, "astc-10x8-unorm-srgb": true, "astc-10x10-unorm": true, "astc-10x10-unorm-srgb": true, "astc-12x10-unorm": true, "astc-12x10-unorm-srgb": true, "astc-12x12-unorm": true, "astc-12x12-unorm-srgb": true }, Bv = { id: "compressed", upload(i3, t, e) {
      e.pixelStorei(e.UNPACK_ALIGNMENT, 4);
      let r = i3.pixelWidth, s = i3.pixelHeight, o = !!fw[i3.format];
      for (let n = 0; n < i3.resource.length; n++) {
        let a = i3.resource[n];
        o ? e.compressedTexImage2D(e.TEXTURE_2D, n, t.internalFormat, r, s, 0, a) : e.texImage2D(e.TEXTURE_2D, n, t.internalFormat, r, s, 0, t.format, t.type, a), r = Math.max(r >> 1, 1), s = Math.max(s >> 1, 1);
      }
    } };
  });
  var Ba;
  var bu = p(() => {
    "use strict";
    Ba = { id: "image", upload(i3, t, e, r) {
      let s = t.width, o = t.height, n = i3.pixelWidth, a = i3.pixelHeight, c = i3.resourceWidth, l = i3.resourceHeight;
      c < n || l < a ? ((s !== n || o !== a) && e.texImage2D(t.target, 0, t.internalFormat, n, a, 0, t.format, t.type, null), r === 2 ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, c, l, t.format, t.type, i3.resource) : e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i3.resource)) : s === n && o === a ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, i3.resource) : r === 2 ? e.texImage2D(t.target, 0, t.internalFormat, n, a, 0, t.format, t.type, i3.resource) : e.texImage2D(t.target, 0, t.internalFormat, t.format, t.type, i3.resource), t.width = n, t.height = a;
    } };
  });
  var Gv;
  var kv = p(() => {
    bu();
    Gv = { id: "video", upload(i3, t, e, r) {
      if (!i3.isValid) {
        e.texImage2D(t.target, 0, t.internalFormat, 1, 1, 0, t.format, t.type, null);
        return;
      }
      Ba.upload(i3, t, e, r);
    } };
  });
  var vu;
  var Iv;
  var Ra;
  var Fv;
  var Uv = p(() => {
    "use strict";
    vu = { linear: 9729, nearest: 9728 }, Iv = { linear: { linear: 9987, nearest: 9985 }, nearest: { linear: 9986, nearest: 9984 } }, Ra = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 }, Fv = { never: 512, less: 513, equal: 514, "less-equal": 515, greater: 516, "not-equal": 517, "greater-equal": 518, always: 519 };
  });
  function Tu(i3, t, e, r, s, o, n, a) {
    let c = o;
    if (!a || i3.addressModeU !== "repeat" || i3.addressModeV !== "repeat" || i3.addressModeW !== "repeat") {
      let l = Ra[n ? "clamp-to-edge" : i3.addressModeU], h = Ra[n ? "clamp-to-edge" : i3.addressModeV], u = Ra[n ? "clamp-to-edge" : i3.addressModeW];
      t[s](c, t.TEXTURE_WRAP_S, l), t[s](c, t.TEXTURE_WRAP_T, h), t.TEXTURE_WRAP_R && t[s](c, t.TEXTURE_WRAP_R, u);
    }
    if ((!a || i3.magFilter !== "linear") && t[s](c, t.TEXTURE_MAG_FILTER, vu[i3.magFilter]), e) {
      if (!a || i3.mipmapFilter !== "linear") {
        let l = Iv[i3.minFilter][i3.mipmapFilter];
        t[s](c, t.TEXTURE_MIN_FILTER, l);
      }
    } else t[s](c, t.TEXTURE_MIN_FILTER, vu[i3.minFilter]);
    if (r && i3.maxAnisotropy > 1) {
      let l = Math.min(i3.maxAnisotropy, t.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      t[s](c, r.TEXTURE_MAX_ANISOTROPY_EXT, l);
    }
    i3.compare && t[s](c, t.TEXTURE_COMPARE_FUNC, Fv[i3.compare]);
  }
  var Dv = p(() => {
    Uv();
  });
  function Ov(i3) {
    return { r8unorm: i3.RED, r8snorm: i3.RED, r8uint: i3.RED, r8sint: i3.RED, r16uint: i3.RED, r16sint: i3.RED, r16float: i3.RED, rg8unorm: i3.RG, rg8snorm: i3.RG, rg8uint: i3.RG, rg8sint: i3.RG, r32uint: i3.RED, r32sint: i3.RED, r32float: i3.RED, rg16uint: i3.RG, rg16sint: i3.RG, rg16float: i3.RG, rgba8unorm: i3.RGBA, "rgba8unorm-srgb": i3.RGBA, rgba8snorm: i3.RGBA, rgba8uint: i3.RGBA, rgba8sint: i3.RGBA, bgra8unorm: i3.RGBA, "bgra8unorm-srgb": i3.RGBA, rgb9e5ufloat: i3.RGB, rgb10a2unorm: i3.RGBA, rg11b10ufloat: i3.RGB, rg32uint: i3.RG, rg32sint: i3.RG, rg32float: i3.RG, rgba16uint: i3.RGBA, rgba16sint: i3.RGBA, rgba16float: i3.RGBA, rgba32uint: i3.RGBA, rgba32sint: i3.RGBA, rgba32float: i3.RGBA, stencil8: i3.STENCIL_INDEX8, depth16unorm: i3.DEPTH_COMPONENT, depth24plus: i3.DEPTH_COMPONENT, "depth24plus-stencil8": i3.DEPTH_STENCIL, depth32float: i3.DEPTH_COMPONENT, "depth32float-stencil8": i3.DEPTH_STENCIL };
  }
  var Lv = p(() => {
    "use strict";
  });
  function Nv(i3, t) {
    let e = {}, r = i3.RGBA;
    return i3 instanceof N.get().getWebGLRenderingContext() ? t.srgb && (e = { "rgba8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT, "bgra8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT }) : (e = { "rgba8unorm-srgb": i3.SRGB8_ALPHA8, "bgra8unorm-srgb": i3.SRGB8_ALPHA8 }, r = i3.RGBA8), { r8unorm: i3.R8, r8snorm: i3.R8_SNORM, r8uint: i3.R8UI, r8sint: i3.R8I, r16uint: i3.R16UI, r16sint: i3.R16I, r16float: i3.R16F, rg8unorm: i3.RG8, rg8snorm: i3.RG8_SNORM, rg8uint: i3.RG8UI, rg8sint: i3.RG8I, r32uint: i3.R32UI, r32sint: i3.R32I, r32float: i3.R32F, rg16uint: i3.RG16UI, rg16sint: i3.RG16I, rg16float: i3.RG16F, rgba8unorm: i3.RGBA, ...e, rgba8snorm: i3.RGBA8_SNORM, rgba8uint: i3.RGBA8UI, rgba8sint: i3.RGBA8I, bgra8unorm: r, rgb9e5ufloat: i3.RGB9_E5, rgb10a2unorm: i3.RGB10_A2, rg11b10ufloat: i3.R11F_G11F_B10F, rg32uint: i3.RG32UI, rg32sint: i3.RG32I, rg32float: i3.RG32F, rgba16uint: i3.RGBA16UI, rgba16sint: i3.RGBA16I, rgba16float: i3.RGBA16F, rgba32uint: i3.RGBA32UI, rgba32sint: i3.RGBA32I, rgba32float: i3.RGBA32F, stencil8: i3.STENCIL_INDEX8, depth16unorm: i3.DEPTH_COMPONENT16, depth24plus: i3.DEPTH_COMPONENT24, "depth24plus-stencil8": i3.DEPTH24_STENCIL8, depth32float: i3.DEPTH_COMPONENT32F, "depth32float-stencil8": i3.DEPTH32F_STENCIL8, ...t.s3tc ? { "bc1-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT, "bc2-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT, "bc3-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT } : {}, ...t.s3tc_sRGB ? { "bc1-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, "bc2-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, "bc3-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } : {}, ...t.rgtc ? { "bc4-r-unorm": t.rgtc.COMPRESSED_RED_RGTC1_EXT, "bc4-r-snorm": t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT, "bc5-rg-unorm": t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT, "bc5-rg-snorm": t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } : {}, ...t.bptc ? { "bc6h-rgb-float": t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, "bc6h-rgb-ufloat": t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, "bc7-rgba-unorm": t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT, "bc7-rgba-unorm-srgb": t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT } : {}, ...t.etc ? { "etc2-rgb8unorm": t.etc.COMPRESSED_RGB8_ETC2, "etc2-rgb8unorm-srgb": t.etc.COMPRESSED_SRGB8_ETC2, "etc2-rgb8a1unorm": t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgb8a1unorm-srgb": t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgba8unorm": t.etc.COMPRESSED_RGBA8_ETC2_EAC, "etc2-rgba8unorm-srgb": t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, "eac-r11unorm": t.etc.COMPRESSED_R11_EAC, "eac-rg11unorm": t.etc.COMPRESSED_SIGNED_RG11_EAC } : {}, ...t.astc ? { "astc-4x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR, "astc-4x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, "astc-5x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR, "astc-5x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, "astc-5x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR, "astc-5x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, "astc-6x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR, "astc-6x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, "astc-6x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR, "astc-6x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, "astc-8x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR, "astc-8x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, "astc-8x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR, "astc-8x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, "astc-8x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR, "astc-8x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, "astc-10x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR, "astc-10x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, "astc-10x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR, "astc-10x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, "astc-10x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR, "astc-10x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, "astc-10x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR, "astc-10x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, "astc-12x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR, "astc-12x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, "astc-12x12-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR, "astc-12x12-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR } : {} };
  }
  var Hv = p(() => {
    lt2();
  });
  function Wv(i3) {
    return { r8unorm: i3.UNSIGNED_BYTE, r8snorm: i3.BYTE, r8uint: i3.UNSIGNED_BYTE, r8sint: i3.BYTE, r16uint: i3.UNSIGNED_SHORT, r16sint: i3.SHORT, r16float: i3.HALF_FLOAT, rg8unorm: i3.UNSIGNED_BYTE, rg8snorm: i3.BYTE, rg8uint: i3.UNSIGNED_BYTE, rg8sint: i3.BYTE, r32uint: i3.UNSIGNED_INT, r32sint: i3.INT, r32float: i3.FLOAT, rg16uint: i3.UNSIGNED_SHORT, rg16sint: i3.SHORT, rg16float: i3.HALF_FLOAT, rgba8unorm: i3.UNSIGNED_BYTE, "rgba8unorm-srgb": i3.UNSIGNED_BYTE, rgba8snorm: i3.BYTE, rgba8uint: i3.UNSIGNED_BYTE, rgba8sint: i3.BYTE, bgra8unorm: i3.UNSIGNED_BYTE, "bgra8unorm-srgb": i3.UNSIGNED_BYTE, rgb9e5ufloat: i3.UNSIGNED_INT_5_9_9_9_REV, rgb10a2unorm: i3.UNSIGNED_INT_2_10_10_10_REV, rg11b10ufloat: i3.UNSIGNED_INT_10F_11F_11F_REV, rg32uint: i3.UNSIGNED_INT, rg32sint: i3.INT, rg32float: i3.FLOAT, rgba16uint: i3.UNSIGNED_SHORT, rgba16sint: i3.SHORT, rgba16float: i3.HALF_FLOAT, rgba32uint: i3.UNSIGNED_INT, rgba32sint: i3.INT, rgba32float: i3.FLOAT, stencil8: i3.UNSIGNED_BYTE, depth16unorm: i3.UNSIGNED_SHORT, depth24plus: i3.UNSIGNED_INT, "depth24plus-stencil8": i3.UNSIGNED_INT_24_8, depth32float: i3.FLOAT, "depth32float-stencil8": i3.FLOAT_32_UNSIGNED_INT_24_8_REV };
  }
  var zv = p(() => {
    "use strict";
  });
  var pw;
  var Eo;
  var Vv = p(() => {
    lt2();
    E();
    rt2();
    Cv();
    Mv();
    Rv();
    bu();
    kv();
    Dv();
    Lv();
    Hv();
    zv();
    pw = 4, Eo = class {
      constructor(t) {
        this.managedTextures = [], this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = /* @__PURE__ */ Object.create(null), this._uploads = { image: Ba, buffer: Ev, video: Gv, compressed: Bv }, this._premultiplyAlpha = false, this._useSeparateSamplers = false, this._renderer = t, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
      }
      contextChange(t) {
        this._gl = t, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = Nv(t, this._renderer.context.extensions), this._mapFormatToType = Wv(t), this._mapFormatToFormat = Ov(t)), this._glTextures = /* @__PURE__ */ Object.create(null), this._glSamplers = /* @__PURE__ */ Object.create(null), this._boundSamplers = /* @__PURE__ */ Object.create(null), this._premultiplyAlpha = false;
        for (let e = 0; e < 16; e++) this.bind(B.EMPTY, e);
      }
      initSource(t) {
        this.bind(t);
      }
      bind(t, e = 0) {
        let r = t.source;
        t ? (this.bindSource(r, e), this._useSeparateSamplers && this._bindSampler(r.style, e)) : (this.bindSource(null, e), this._useSeparateSamplers && this._bindSampler(null, e));
      }
      bindSource(t, e = 0) {
        let r = this._gl;
        if (t._touched = this._renderer.textureGC.count, this._boundTextures[e] !== t) {
          this._boundTextures[e] = t, this._activateLocation(e), t || (t = B.EMPTY.source);
          let s = this.getGlSource(t);
          r.bindTexture(s.target, s.texture);
        }
      }
      _bindSampler(t, e = 0) {
        let r = this._gl;
        if (!t) {
          this._boundSamplers[e] = null, r.bindSampler(e, null);
          return;
        }
        let s = this._getGlSampler(t);
        this._boundSamplers[e] !== s && (this._boundSamplers[e] = s, r.bindSampler(e, s));
      }
      unbind(t) {
        let e = t.source, r = this._boundTextures, s = this._gl;
        for (let o = 0; o < r.length; o++) if (r[o] === e) {
          this._activateLocation(o);
          let n = this.getGlSource(e);
          s.bindTexture(n.target, null), r[o] = null;
        }
      }
      _activateLocation(t) {
        this._activeTextureLocation !== t && (this._activeTextureLocation = t, this._gl.activeTexture(this._gl.TEXTURE0 + t));
      }
      _initSource(t) {
        let e = this._gl, r = new Ma(e.createTexture());
        if (r.type = this._mapFormatToType[t.format], r.internalFormat = this._mapFormatToInternalFormat[t.format], r.format = this._mapFormatToFormat[t.format], t.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) {
          let s = Math.max(t.width, t.height);
          t.mipLevelCount = Math.floor(Math.log2(s)) + 1;
        }
        return this._glTextures[t.uid] = r, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, false), r;
      }
      onStyleChange(t) {
        this.updateStyle(t, false);
      }
      updateStyle(t, e) {
        let r = this._gl, s = this.getGlSource(t);
        r.bindTexture(r.TEXTURE_2D, s.texture), this._boundTextures[this._activeTextureLocation] = t, Tu(t.style, r, t.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo, e);
      }
      onSourceUnload(t) {
        let e = this._glTextures[t.uid];
        e && (this.unbind(t), this._glTextures[t.uid] = null, this._gl.deleteTexture(e.texture));
      }
      onSourceUpdate(t) {
        let e = this._gl, r = this.getGlSource(t);
        e.bindTexture(e.TEXTURE_2D, r.texture), this._boundTextures[this._activeTextureLocation] = t;
        let s = t.alphaMode === "premultiply-alpha-on-upload";
        this._premultiplyAlpha !== s && (this._premultiplyAlpha = s, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s)), this._uploads[t.uploadMethodId] ? this._uploads[t.uploadMethodId].upload(t, r, e, this._renderer.context.webGLVersion) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.pixelWidth, t.pixelHeight, 0, e.RGBA, e.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, false);
      }
      onUpdateMipmaps(t, e = true) {
        e && this.bindSource(t, 0);
        let r = this.getGlSource(t);
        this._gl.generateMipmap(r.target);
      }
      onSourceDestroy(t) {
        t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t);
      }
      _initSampler(t) {
        let e = this._gl, r = this._gl.createSampler();
        return this._glSamplers[t._resourceId] = r, Tu(t, e, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, false, true), this._glSamplers[t._resourceId];
      }
      _getGlSampler(t) {
        return this._glSamplers[t._resourceId] || this._initSampler(t);
      }
      getGlSource(t) {
        return this._glTextures[t.uid] || this._initSource(t);
      }
      generateCanvas(t) {
        let { pixels: e, width: r, height: s } = this.getPixels(t), o = N.get().createCanvas();
        o.width = r, o.height = s;
        let n = o.getContext("2d");
        if (n) {
          let a = n.createImageData(r, s);
          a.data.set(e), n.putImageData(a, 0, 0);
        }
        return o;
      }
      getPixels(t) {
        let e = t.source.resolution, r = t.frame, s = Math.max(Math.round(r.width * e), 1), o = Math.max(Math.round(r.height * e), 1), n = new Uint8Array(pw * s * o), a = this._renderer, c = a.renderTarget.getRenderTarget(t), l = a.renderTarget.getGpuRenderTarget(c), h = a.gl;
        return h.bindFramebuffer(h.FRAMEBUFFER, l.resolveTargetFramebuffer), h.readPixels(Math.round(r.x * e), Math.round(r.y * e), s, o, h.RGBA, h.UNSIGNED_BYTE, n), { pixels: new Uint8ClampedArray(n.buffer), width: s, height: o };
      }
      destroy() {
        this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)), this.managedTextures = null, this._renderer = null;
      }
      resetState() {
        this._activeTextureLocation = -1, this._boundTextures.fill(B.EMPTY.source), this._boundSamplers = /* @__PURE__ */ Object.create(null);
        let t = this._gl;
        this._premultiplyAlpha = false, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
      }
    };
    Eo.extension = { type: [_2.WebGLSystem], name: "texture" };
  });
  var jv = {};
  Yu(jv, { WebGLRenderer: () => Su });
  var mw;
  var gw;
  var xw;
  var Xv;
  var Yv;
  var $v;
  var Su;
  var Kv = p(() => {
    E();
    wb();
    Pb();
    Ab();
    ks();
    Kh();
    Ae2();
    Mb();
    Gb();
    Ub();
    Lb();
    Nb();
    Hb();
    Wb();
    jb();
    Zb();
    mv();
    vv();
    Av();
    Vv();
    mw = [...ua, wo, Ob, Rb, yo, Eo, Po, bo, Co, Ao, To, Pv, So, vo], gw = [...da], xw = [xo, go, mo], Xv = [], Yv = [], $v = [];
    U2.handleByNamedList(_2.WebGLSystem, Xv);
    U2.handleByNamedList(_2.WebGLPipes, Yv);
    U2.handleByNamedList(_2.WebGLPipesAdaptor, $v);
    U2.add(...mw, ...gw, ...xw);
    Su = class extends rr2 {
      constructor() {
        let t = { name: "webgl", type: Tt2.WEBGL, systems: Xv, renderPipes: Yv, renderPipeAdaptors: $v };
        super(t);
      }
    };
  });
  E();
  var A_ = { extension: { type: _2.Environment, name: "browser", priority: -1 }, test: () => true, load: async () => {
    await Promise.resolve().then(() => (P_(), DS));
  } };
  E();
  var E_ = { extension: { type: _2.Environment, name: "webworker", priority: 0 }, test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0, load: async () => {
    await Promise.resolve().then(() => (C_(), OS));
  } };
  E();
  E();
  dn2();
  on2();
  E();
  lt2();
  ks();
  var oa;
  function U_(i3) {
    return oa !== void 0 || (oa = (() => {
      let t = { stencil: true, failIfMajorPerformanceCaveat: i3 ?? rr2.defaultOptions.failIfMajorPerformanceCaveat };
      try {
        if (!N.get().getWebGLRenderingContext()) return false;
        let r = N.get().createCanvas().getContext("webgl", t), s = !!r?.getContextAttributes()?.stencil;
        if (r) {
          let o = r.getExtension("WEBGL_lose_context");
          o && o.loseContext();
        }
        return r = null, s;
      } catch {
        return false;
      }
    })()), oa;
  }
  lt2();
  var na;
  async function D_(i3 = {}) {
    return na !== void 0 || (na = await (async () => {
      let t = N.get().getNavigator().gpu;
      if (!t) return false;
      try {
        return await (await t.requestAdapter(i3)).requestDevice(), true;
      } catch {
        return false;
      }
    })()), na;
  }
  ks();
  var qv = ["webgl", "webgpu", "canvas"];
  async function Zv(i3) {
    let t = [];
    i3.preference ? (t.push(i3.preference), qv.forEach((o) => {
      o !== i3.preference && t.push(o);
    })) : t = qv.slice();
    let e, r = {};
    for (let o = 0; o < t.length; o++) {
      let n = t[o];
      if (n === "webgpu" && await D_()) {
        let { WebGPURenderer: a } = await Promise.resolve().then(() => (Sb(), Tb));
        e = a, r = { ...i3, ...i3.webgpu };
        break;
      } else if (n === "webgl" && U_(i3.failIfMajorPerformanceCaveat ?? rr2.defaultOptions.failIfMajorPerformanceCaveat)) {
        let { WebGLRenderer: a } = await Promise.resolve().then(() => (Kv(), jv));
        e = a, r = { ...i3, ...i3.webgl };
        break;
      } else if (n === "canvas") throw r = { ...i3 }, new Error("CanvasRenderer is not yet implemented");
    }
    if (delete r.webgpu, delete r.webgl, !e) throw new Error("No available renderer for the current environment");
    let s = new e();
    return await s.init(r), s;
  }
  fe2();
  Uh();
  ft2();
  var Qv = class wu {
    constructor(...t) {
      this.stage = new ct2(), t[0] !== void 0 && L2(z, "Application constructor options are deprecated, please use Application.init() instead.");
    }
    async init(t) {
      t = { ...t }, this.renderer = await Zv(t), wu._plugins.forEach((e) => {
        e.init.call(this, t);
      });
    }
    render() {
      this.renderer.render({ container: this.stage });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return L2(z, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(t = false, e = false) {
      let r = wu._plugins.slice(0);
      r.reverse(), r.forEach((s) => {
        s.destroy.call(this);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }
  };
  Qv._plugins = [];
  var Ga = Qv;
  U2.handleByList(_2.Application, Ga._plugins);
  U2.add(zs);
  E();
  Ue2();
  Uc();
  lt2();
  E();
  br2();
  St2();
  rt2();
  dh();
  xh();
  var Mo = class extends mi {
    constructor(t, e) {
      super();
      let { textures: r, data: s } = t;
      Object.keys(s.pages).forEach((o) => {
        let n = s.pages[parseInt(o, 10)], a = r[n.id];
        this.pages.push({ texture: a });
      }), Object.keys(s.chars).forEach((o) => {
        let n = s.chars[o], { frame: a, source: c } = r[n.page], l = new Y2(n.x + a.x, n.y + a.y, n.width, n.height), h = new B({ source: c, frame: l });
        this.chars[o] = { id: o.codePointAt(0), xOffset: n.xOffset, yOffset: n.yOffset, xAdvance: n.xAdvance, kerning: n.kerning ?? {}, texture: h };
      }), this.baseRenderedFontSize = s.fontSize, this.baseMeasurementFontSize = s.fontSize, this.fontMetrics = { ascent: 0, descent: 0, fontSize: s.fontSize }, this.baseLineOffset = s.baseLineOffset, this.lineHeight = s.lineHeight, this.fontFamily = s.fontFamily, this.distanceField = s.distanceField ?? { type: "none", range: 0 }, this.url = e;
    }
    destroy() {
      super.destroy();
      for (let t = 0; t < this.pages.length; t++) {
        let { texture: e } = this.pages[t];
        e.destroy(true);
      }
      this.pages = null;
    }
    static install(t) {
      Ps.install(t);
    }
    static uninstall(t) {
      Ps.uninstall(t);
    }
  };
  var ka = { test(i3) {
    return typeof i3 == "string" && i3.startsWith("info face=");
  }, parse(i3) {
    let t = i3.match(/^[a-z]+\s+.+$/gm), e = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] };
    for (let u in t) {
      let f = t[u].match(/^[a-z]+/gm)[0], d2 = t[u].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), m = {};
      for (let g in d2) {
        let x2 = d2[g].split("="), b = x2[0], y = x2[1].replace(/"/gm, ""), v = parseFloat(y), T2 = isNaN(v) ? y : v;
        m[b] = T2;
      }
      e[f].push(m);
    }
    let r = { chars: {}, pages: [], lineHeight: 0, fontSize: 0, fontFamily: "", distanceField: null, baseLineOffset: 0 }, [s] = e.info, [o] = e.common, [n] = e.distanceField ?? [];
    n && (r.distanceField = { range: parseInt(n.distanceRange, 10), type: n.fieldType }), r.fontSize = parseInt(s.size, 10), r.fontFamily = s.face, r.lineHeight = parseInt(o.lineHeight, 10);
    let a = e.page;
    for (let u = 0; u < a.length; u++) r.pages.push({ id: parseInt(a[u].id, 10) || 0, file: a[u].file });
    let c = {};
    r.baseLineOffset = r.lineHeight - parseInt(o.base, 10);
    let l = e.char;
    for (let u = 0; u < l.length; u++) {
      let f = l[u], d2 = parseInt(f.id, 10), m = f.letter ?? f.char ?? String.fromCharCode(d2);
      m === "space" && (m = " "), c[d2] = m, r.chars[m] = { id: d2, page: parseInt(f.page, 10) || 0, x: parseInt(f.x, 10), y: parseInt(f.y, 10), width: parseInt(f.width, 10), height: parseInt(f.height, 10), xOffset: parseInt(f.xoffset, 10), yOffset: parseInt(f.yoffset, 10), xAdvance: parseInt(f.xadvance, 10), kerning: {} };
    }
    let h = e.kerning || [];
    for (let u = 0; u < h.length; u++) {
      let f = parseInt(h[u].first, 10), d2 = parseInt(h[u].second, 10), m = parseInt(h[u].amount, 10);
      r.chars[c[d2]].kerning[c[f]] = m;
    }
    return r;
  } };
  lt2();
  var Pu = { test(i3) {
    let t = i3;
    return typeof t != "string" && "getElementsByTagName" in t && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }, parse(i3) {
    let t = { chars: {}, pages: [], lineHeight: 0, fontSize: 0, fontFamily: "", distanceField: null, baseLineOffset: 0 }, e = i3.getElementsByTagName("info")[0], r = i3.getElementsByTagName("common")[0], s = i3.getElementsByTagName("distanceField")[0];
    s && (t.distanceField = { type: s.getAttribute("fieldType"), range: parseInt(s.getAttribute("distanceRange"), 10) });
    let o = i3.getElementsByTagName("page"), n = i3.getElementsByTagName("char"), a = i3.getElementsByTagName("kerning");
    t.fontSize = parseInt(e.getAttribute("size"), 10), t.fontFamily = e.getAttribute("face"), t.lineHeight = parseInt(r.getAttribute("lineHeight"), 10);
    for (let l = 0; l < o.length; l++) t.pages.push({ id: parseInt(o[l].getAttribute("id"), 10) || 0, file: o[l].getAttribute("file") });
    let c = {};
    t.baseLineOffset = t.lineHeight - parseInt(r.getAttribute("base"), 10);
    for (let l = 0; l < n.length; l++) {
      let h = n[l], u = parseInt(h.getAttribute("id"), 10), f = h.getAttribute("letter") ?? h.getAttribute("char") ?? String.fromCharCode(u);
      f === "space" && (f = " "), c[u] = f, t.chars[f] = { id: u, page: parseInt(h.getAttribute("page"), 10) || 0, x: parseInt(h.getAttribute("x"), 10), y: parseInt(h.getAttribute("y"), 10), width: parseInt(h.getAttribute("width"), 10), height: parseInt(h.getAttribute("height"), 10), xOffset: parseInt(h.getAttribute("xoffset"), 10), yOffset: parseInt(h.getAttribute("yoffset"), 10), xAdvance: parseInt(h.getAttribute("xadvance"), 10), kerning: {} };
    }
    for (let l = 0; l < a.length; l++) {
      let h = parseInt(a[l].getAttribute("first"), 10), u = parseInt(a[l].getAttribute("second"), 10), f = parseInt(a[l].getAttribute("amount"), 10);
      t.chars[c[u]].kerning[c[h]] = f;
    }
    return t;
  } };
  var Au = { test(i3) {
    return typeof i3 == "string" && i3.includes("<font>") ? Pu.test(N.get().parseXML(i3)) : false;
  }, parse(i3) {
    return Pu.parse(N.get().parseXML(i3));
  } };
  var _w = [".xml", ".fnt"];
  var Jv = { extension: { type: _2.CacheParser, name: "cacheBitmapFont" }, test: (i3) => i3 instanceof Mo, getCacheableAssets(i3, t) {
    let e = {};
    return i3.forEach((r) => {
      e[r] = t, e[`${r}-bitmap`] = t;
    }), e[`${t.fontFamily}-bitmap`] = t, e;
  } };
  var t0 = { extension: { type: _2.LoadParser, priority: Et2.Normal }, name: "loadBitmapFont", test(i3) {
    return _w.includes(wt2.extname(i3).toLowerCase());
  }, async testParse(i3) {
    return ka.test(i3) || Au.test(i3);
  }, async parse(i3, t, e) {
    let r = ka.test(i3) ? ka.parse(i3) : Au.parse(i3), { src: s } = t, { pages: o } = r, n = [], a = r.distanceField ? { scaleMode: "linear", alphaMode: "premultiply-alpha-on-upload", autoGenerateMipmaps: false, resolution: 1 } : {};
    for (let u = 0; u < o.length; ++u) {
      let f = o[u].file, d2 = wt2.join(wt2.dirname(s), f);
      d2 = Ji(d2, s), n.push({ src: d2, data: a });
    }
    let c = await e.load(n), l = n.map((u) => c[u.src]);
    return new Mo({ data: r, textures: l }, s);
  }, async load(i3, t) {
    return await (await N.get().fetch(i3)).text();
  }, async unload(i3, t, e) {
    await Promise.all(i3.pages.map((r) => e.unload(r.texture.source._sourceOrigin))), i3.destroy();
  } };
  ot2();
  var Ia = class {
    constructor(t, e = false) {
      this._loader = t, this._assetList = [], this._isLoading = false, this._maxConcurrent = 1, this.verbose = e;
    }
    add(t) {
      t.forEach((e) => {
        this._assetList.push(e);
      }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = true;
        let t = [], e = Math.min(this._assetList.length, this._maxConcurrent);
        for (let r = 0; r < e; r++) t.push(this._assetList.pop());
        await this._loader.load(t), this._isLoading = false, this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(t) {
      this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next());
    }
  };
  je2();
  E();
  rt2();
  var e0 = { extension: { type: _2.CacheParser, name: "cacheTextureArray" }, test: (i3) => Array.isArray(i3) && i3.every((t) => t instanceof B), getCacheableAssets: (i3, t) => {
    let e = {};
    return i3.forEach((r) => {
      t.forEach((s, o) => {
        e[r + (o === 0 ? "" : o + 1)] = s;
      });
    }), e;
  } };
  E();
  async function Fa(i3) {
    if ("Image" in globalThis) return new Promise((t) => {
      let e = new Image();
      e.onload = () => {
        t(true);
      }, e.onerror = () => {
        t(false);
      }, e.src = i3;
    });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        let t = await (await fetch(i3)).blob();
        await createImageBitmap(t);
      } catch {
        return false;
      }
      return true;
    }
    return false;
  }
  var r0 = { extension: { type: _2.DetectionParser, priority: 1 }, test: async () => Fa("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="), add: async (i3) => [...i3, "avif"], remove: async (i3) => i3.filter((t) => t !== "avif") };
  E();
  var i0 = ["png", "jpg", "jpeg"];
  var s0 = { extension: { type: _2.DetectionParser, priority: -1 }, test: () => Promise.resolve(true), add: async (i3) => [...i3, ...i0], remove: async (i3) => i3.filter((t) => !i0.includes(t)) };
  E();
  var yw = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  function Mi(i3) {
    return yw ? false : document.createElement("video").canPlayType(i3) !== "";
  }
  var o0 = { extension: { type: _2.DetectionParser, priority: 0 }, test: async () => Mi("video/mp4"), add: async (i3) => [...i3, "mp4", "m4v"], remove: async (i3) => i3.filter((t) => t !== "mp4" && t !== "m4v") };
  E();
  var n0 = { extension: { type: _2.DetectionParser, priority: 0 }, test: async () => Mi("video/ogg"), add: async (i3) => [...i3, "ogv"], remove: async (i3) => i3.filter((t) => t !== "ogv") };
  E();
  var a0 = { extension: { type: _2.DetectionParser, priority: 0 }, test: async () => Mi("video/webm"), add: async (i3) => [...i3, "webm"], remove: async (i3) => i3.filter((t) => t !== "webm") };
  E();
  var c0 = { extension: { type: _2.DetectionParser, priority: 0 }, test: async () => Fa("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="), add: async (i3) => [...i3, "webp"], remove: async (i3) => i3.filter((t) => t !== "webp") };
  ot2();
  br2();
  Qi();
  sn2();
  var Ua = class {
    constructor() {
      this._parsers = [], this._parsersValidated = false, this.parsers = new Proxy(this._parsers, { set: (t, e, r) => (this._parsersValidated = false, t[e] = r, true) }), this.promiseCache = {};
    }
    reset() {
      this._parsersValidated = false, this.promiseCache = {};
    }
    _getLoadPromiseAndParser(t, e) {
      let r = { promise: null, parser: null };
      return r.promise = (async () => {
        let s = null, o = null;
        if (e.loadParser && (o = this._parserHash[e.loadParser], o || O2(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)), !o) {
          for (let n = 0; n < this.parsers.length; n++) {
            let a = this.parsers[n];
            if (a.load && a.test?.(t, e, this)) {
              o = a;
              break;
            }
          }
          if (!o) return O2(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
        }
        s = await o.load(t, e, this), r.parser = o;
        for (let n = 0; n < this.parsers.length; n++) {
          let a = this.parsers[n];
          a.parse && a.parse && await a.testParse?.(s, e, this) && (s = await a.parse(s, e, this) || s, r.parser = a);
        }
        return s;
      })(), r;
    }
    async load(t, e) {
      this._parsersValidated || this._validateParsers();
      let r = 0, s = {}, o = vr2(t), n = Wt2(t, (l) => ({ alias: [l], src: l, data: {} })), a = n.length, c = n.map(async (l) => {
        let h = wt2.toAbsolute(l.src);
        if (!s[l.src]) try {
          this.promiseCache[h] || (this.promiseCache[h] = this._getLoadPromiseAndParser(h, l)), s[l.src] = await this.promiseCache[h].promise, e && e(++r / a);
        } catch (u) {
          throw delete this.promiseCache[h], delete s[l.src], new Error(`[Loader.load] Failed to load ${h}.
${u}`);
        }
      });
      return await Promise.all(c), o ? s[n[0].src] : s;
    }
    async unload(t) {
      let r = Wt2(t, (s) => ({ alias: [s], src: s })).map(async (s) => {
        let o = wt2.toAbsolute(s.src), n = this.promiseCache[o];
        if (n) {
          let a = await n.promise;
          delete this.promiseCache[o], await n.parser?.unload?.(a, s, this);
        }
      });
      await Promise.all(r);
    }
    _validateParsers() {
      this._parsersValidated = true, this._parserHash = this._parsers.filter((t) => t.name).reduce((t, e) => (e.name ? t[e.name] && O2(`[Assets] loadParser name conflict "${e.name}"`) : O2("[Assets] loadParser should have a name"), { ...t, [e.name]: e }), {});
    }
  };
  lt2();
  E();
  function he2(i3, t) {
    if (Array.isArray(t)) {
      for (let e of t) if (i3.startsWith(`data:${e}`)) return true;
      return false;
    }
    return i3.startsWith(`data:${t}`);
  }
  br2();
  function ue2(i3, t) {
    let e = i3.split("?")[0], r = wt2.extname(e).toLowerCase();
    return Array.isArray(t) ? t.includes(r) : r === t;
  }
  Ue2();
  var bw = ".json";
  var vw = "application/json";
  var l0 = { extension: { type: _2.LoadParser, priority: Et2.Low }, name: "loadJson", test(i3) {
    return he2(i3, vw) || ue2(i3, bw);
  }, async load(i3) {
    return await (await N.get().fetch(i3)).json();
  } };
  lt2();
  E();
  Ue2();
  var Tw = ".txt";
  var Sw = "text/plain";
  var h0 = { name: "loadTxt", extension: { type: _2.LoadParser, priority: Et2.Low, name: "loadTxt" }, test(i3) {
    return he2(i3, Sw) || ue2(i3, Tw);
  }, async load(i3) {
    return await (await N.get().fetch(i3)).text();
  } };
  lt2();
  E();
  ot2();
  br2();
  je2();
  Ue2();
  var ww = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
  var Pw = [".ttf", ".otf", ".woff", ".woff2"];
  var Aw = ["font/ttf", "font/otf", "font/woff", "font/woff2"];
  var Cw = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function Ew(i3) {
    let t = wt2.extname(i3), s = wt2.basename(i3, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((a) => a.charAt(0).toUpperCase() + a.slice(1)), o = s.length > 0;
    for (let a of s) if (!a.match(Cw)) {
      o = false;
      break;
    }
    let n = s.join(" ");
    return o || (n = `"${n.replace(/[\\"]/g, "\\$&")}"`), n;
  }
  var Mw = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  function Bw(i3) {
    return Mw.test(i3) ? i3 : encodeURI(i3);
  }
  var u0 = { extension: { type: _2.LoadParser, priority: Et2.Low }, name: "loadWebFont", test(i3) {
    return he2(i3, Aw) || ue2(i3, Pw);
  }, async load(i3, t) {
    let e = N.get().getFontFaceSet();
    if (e) {
      let r = [], s = t.data?.family ?? Ew(i3), o = t.data?.weights?.filter((a) => ww.includes(a)) ?? ["normal"], n = t.data ?? {};
      for (let a = 0; a < o.length; a++) {
        let c = o[a], l = new FontFace(s, `url(${Bw(i3)})`, { ...n, weight: c });
        await l.load(), e.add(l), r.push(l);
      }
      return tt2.set(`${s}-and-url`, { url: i3, fontFaces: r }), r.length === 1 ? r[0] : r;
    }
    return O2("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  }, unload(i3) {
    (Array.isArray(i3) ? i3 : [i3]).forEach((t) => {
      tt2.remove(`${t.family}-and-url`), N.get().getFontFaceSet().delete(t);
    });
  } };
  lt2();
  E();
  Xr2();
  Vn2();
  zr2();
  function Bi(i3, t = 1) {
    let e = ie2.RETINA_PREFIX?.exec(i3);
    return e ? parseFloat(e[1]) : t;
  }
  Ue2();
  rt2();
  ot2();
  je2();
  function Ri(i3, t, e) {
    i3.label = e, i3._sourceOrigin = e;
    let r = new B({ source: i3, label: e }), s = () => {
      delete t.promiseCache[e], tt2.has(e) && tt2.remove(e);
    };
    return r.source.once("destroy", () => {
      t.promiseCache[e] && (O2("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), s());
    }), r.once("destroy", () => {
      i3.destroyed || (O2("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), s());
    }), r;
  }
  var Rw = ".svg";
  var Gw = "image/svg+xml";
  var d0 = { extension: { type: _2.LoadParser, priority: Et2.Low, name: "loadSVG" }, name: "loadSVG", config: { crossOrigin: "anonymous", parseAsGraphicsContext: false }, test(i3) {
    return he2(i3, Gw) || ue2(i3, Rw);
  }, async load(i3, t, e) {
    return t.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? Iw(i3) : kw(i3, t, e, this.config.crossOrigin);
  }, unload(i3) {
    i3.destroy(true);
  } };
  async function kw(i3, t, e, r) {
    let o = await (await N.get().fetch(i3)).blob(), n = URL.createObjectURL(o), a = new Image();
    a.src = n, a.crossOrigin = r, await a.decode(), URL.revokeObjectURL(n);
    let c = document.createElement("canvas"), l = c.getContext("2d"), h = t.data?.resolution || Bi(i3), u = t.data?.width ?? a.width, f = t.data?.height ?? a.height;
    c.width = u * h, c.height = f * h, l.drawImage(a, 0, 0, u * h, f * h);
    let { parseAsGraphicsContext: d2, ...m } = t.data ?? {}, g = new qt2({ resource: c, alphaMode: "premultiply-alpha-on-upload", resolution: h, ...m });
    return Ri(g, e, i3);
  }
  async function Iw(i3) {
    let e = await (await N.get().fetch(i3)).text(), r = new Vt2();
    return r.svg(e), r;
  }
  lt2();
  E();
  Xr2();
  var Fw = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
  var Gi = null;
  var ki = class {
    constructor() {
      Gi || (Gi = URL.createObjectURL(new Blob([Fw], { type: "application/javascript" }))), this.worker = new Worker(Gi);
    }
  };
  ki.revokeObjectURL = function() {
    Gi && (URL.revokeObjectURL(Gi), Gi = null);
  };
  var Uw = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
  var Ii = null;
  var Bo = class {
    constructor() {
      Ii || (Ii = URL.createObjectURL(new Blob([Uw], { type: "application/javascript" }))), this.worker = new Worker(Ii);
    }
  };
  Bo.revokeObjectURL = function() {
    Ii && (URL.revokeObjectURL(Ii), Ii = null);
  };
  var f0 = 0;
  var Cu;
  var Eu = class {
    constructor() {
      this._initialized = false, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
    }
    isImageBitmapSupported() {
      return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((t) => {
        let { worker: e } = new ki();
        e.addEventListener("message", (r) => {
          e.terminate(), ki.revokeObjectURL(), t(r.data);
        });
      }), this._isImageBitmapSupported);
    }
    loadImageBitmap(t, e) {
      return this._run("loadImageBitmap", [t, e?.data?.alphaMode]);
    }
    async _initWorkers() {
      this._initialized || (this._initialized = true);
    }
    _getWorker() {
      Cu === void 0 && (Cu = navigator.hardwareConcurrency || 4);
      let t = this._workerPool.pop();
      return !t && this._createdWorkers < Cu && (this._createdWorkers++, t = new Bo().worker, t.addEventListener("message", (e) => {
        this._complete(e.data), this._returnWorker(e.target), this._next();
      })), t;
    }
    _returnWorker(t) {
      this._workerPool.push(t);
    }
    _complete(t) {
      t.error !== void 0 ? this._resolveHash[t.uuid].reject(t.error) : this._resolveHash[t.uuid].resolve(t.data), this._resolveHash[t.uuid] = null;
    }
    async _run(t, e) {
      await this._initWorkers();
      let r = new Promise((s, o) => {
        this._queue.push({ id: t, arguments: e, resolve: s, reject: o });
      });
      return this._next(), r;
    }
    _next() {
      if (!this._queue.length) return;
      let t = this._getWorker();
      if (!t) return;
      let e = this._queue.pop(), r = e.id;
      this._resolveHash[f0] = { resolve: e.resolve, reject: e.reject }, t.postMessage({ data: e.arguments, uuid: f0++, id: r });
    }
  };
  var Mu = new Eu();
  Ue2();
  var Dw = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
  var Ow = ["image/jpeg", "image/png", "image/webp", "image/avif"];
  async function Lw(i3, t) {
    let e = await N.get().fetch(i3);
    if (!e.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${i3}: ${e.status} ${e.statusText}`);
    let r = await e.blob();
    return t?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(r, { premultiplyAlpha: "none" }) : createImageBitmap(r);
  }
  var Da = { name: "loadTextures", extension: { type: _2.LoadParser, priority: Et2.High, name: "loadTextures" }, config: { preferWorkers: true, preferCreateImageBitmap: true, crossOrigin: "anonymous" }, test(i3) {
    return he2(i3, Ow) || ue2(i3, Dw);
  }, async load(i3, t, e) {
    let r = null;
    globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await Mu.isImageBitmapSupported() ? r = await Mu.loadImageBitmap(i3, t) : r = await Lw(i3, t) : r = await new Promise((o, n) => {
      r = new Image(), r.crossOrigin = this.config.crossOrigin, r.src = i3, r.complete ? o(r) : (r.onload = () => {
        o(r);
      }, r.onerror = n);
    });
    let s = new qt2({ resource: r, alphaMode: "premultiply-alpha-on-upload", resolution: t.data?.resolution || Bi(i3), ...t.data });
    return Ri(s, e, i3);
  }, unload(i3) {
    i3.destroy(true);
  } };
  E();
  zc();
  Wc();
  var p0 = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
  var Nw = p0.map((i3) => `video/${i3.substring(1)}`);
  function Hw(i3, t, e) {
    e === void 0 && !t.startsWith("data:") ? i3.crossOrigin = zw(t) : e !== false && (i3.crossOrigin = typeof e == "string" ? e : "anonymous");
  }
  function Ww(i3) {
    return new Promise((t, e) => {
      i3.addEventListener("canplaythrough", r), i3.addEventListener("error", s), i3.load();
      function r() {
        o(), t();
      }
      function s(n) {
        o(), e(n);
      }
      function o() {
        i3.removeEventListener("canplaythrough", r), i3.removeEventListener("error", s);
      }
    });
  }
  function zw(i3, t = globalThis.location) {
    if (i3.startsWith("data:")) return "";
    t || (t = globalThis.location);
    let e = new URL(i3, document.baseURI);
    return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : "";
  }
  var m0 = { name: "loadVideo", extension: { type: _2.LoadParser, name: "loadVideo" }, test(i3) {
    let t = he2(i3, Nw), e = ue2(i3, p0);
    return t || e;
  }, async load(i3, t, e) {
    let r = { ...Yr2.defaultOptions, resolution: t.data?.resolution || Bi(i3), alphaMode: t.data?.alphaMode || await hn2(), ...t.data }, s = document.createElement("video"), o = { preload: r.autoLoad !== false ? "auto" : void 0, "webkit-playsinline": r.playsinline !== false ? "" : void 0, playsinline: r.playsinline !== false ? "" : void 0, muted: r.muted === true ? "" : void 0, loop: r.loop === true ? "" : void 0, autoplay: r.autoPlay !== false ? "" : void 0 };
    Object.keys(o).forEach((c) => {
      let l = o[c];
      l !== void 0 && s.setAttribute(c, l);
    }), r.muted === true && (s.muted = true), Hw(s, i3, r.crossorigin);
    let n = document.createElement("source"), a;
    if (i3.startsWith("data:")) a = i3.slice(5, i3.indexOf(";"));
    else if (!i3.startsWith("blob:")) {
      let c = i3.split("?")[0].slice(i3.lastIndexOf(".") + 1).toLowerCase();
      a = Yr2.MIME_TYPES[c] || `video/${c}`;
    }
    return n.src = i3, a && (n.type = a), new Promise((c) => {
      let l = async () => {
        let h = new Yr2({ ...r, resource: s });
        s.removeEventListener("canplay", l), t.data.preload && await Ww(s), c(Ri(h, e, i3));
      };
      s.addEventListener("canplay", l), s.appendChild(n);
    });
  }, unload(i3) {
    i3.destroy(true);
  } };
  E();
  zr2();
  E();
  zr2();
  var Oa = { extension: { type: _2.ResolveParser, name: "resolveTexture" }, test: Da.test, parse: (i3) => ({ resolution: parseFloat(ie2.RETINA_PREFIX.exec(i3)?.[1] ?? "1"), format: i3.split(".").pop(), src: i3 }) };
  var g0 = { extension: { type: _2.ResolveParser, priority: -2, name: "resolveJson" }, test: (i3) => ie2.RETINA_PREFIX.test(i3) && i3.endsWith(".json"), parse: Oa.parse };
  zr2();
  Qi();
  sn2();
  var La = class {
    constructor() {
      this._detections = [], this._initialized = false, this.resolver = new ie2(), this.loader = new Ua(), this.cache = tt2, this._backgroundLoader = new Ia(this.loader), this._backgroundLoader.active = true, this.reset();
    }
    async init(t = {}) {
      if (this._initialized) {
        O2("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
        return;
      }
      if (this._initialized = true, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
        let o = t.manifest;
        typeof o == "string" && (o = await this.load(o)), this.resolver.addManifest(o);
      }
      let e = t.texturePreference?.resolution ?? 1, r = typeof e == "number" ? [e] : e, s = await this._detectFormats({ preferredFormats: t.texturePreference?.format, skipDetections: t.skipDetections, detections: this._detections });
      this.resolver.prefer({ params: { format: s, resolution: r } }), t.preferences && this.setPreferences(t.preferences);
    }
    add(t) {
      this.resolver.add(t);
    }
    async load(t, e) {
      this._initialized || await this.init();
      let r = vr2(t), s = Wt2(t).map((a) => {
        if (typeof a != "string") {
          let c = this.resolver.getAlias(a);
          return c.some((l) => !this.resolver.hasKey(l)) && this.add(a), Array.isArray(c) ? c[0] : c;
        }
        return this.resolver.hasKey(a) || this.add({ alias: a, src: a }), a;
      }), o = this.resolver.resolve(s), n = await this._mapLoadToResolve(o, e);
      return r ? n[s[0]] : n;
    }
    addBundle(t, e) {
      this.resolver.addBundle(t, e);
    }
    async loadBundle(t, e) {
      this._initialized || await this.init();
      let r = false;
      typeof t == "string" && (r = true, t = [t]);
      let s = this.resolver.resolveBundle(t), o = {}, n = Object.keys(s), a = 0, c = 0, l = () => {
        e?.(++a / c);
      }, h = n.map((u) => {
        let f = s[u];
        return c += Object.keys(f).length, this._mapLoadToResolve(f, l).then((d2) => {
          o[u] = d2;
        });
      });
      return await Promise.all(h), r ? o[t[0]] : o;
    }
    async backgroundLoad(t) {
      this._initialized || await this.init(), typeof t == "string" && (t = [t]);
      let e = this.resolver.resolve(t);
      this._backgroundLoader.add(Object.values(e));
    }
    async backgroundLoadBundle(t) {
      this._initialized || await this.init(), typeof t == "string" && (t = [t]);
      let e = this.resolver.resolveBundle(t);
      Object.values(e).forEach((r) => {
        this._backgroundLoader.add(Object.values(r));
      });
    }
    reset() {
      this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = false;
    }
    get(t) {
      if (typeof t == "string") return tt2.get(t);
      let e = {};
      for (let r = 0; r < t.length; r++) e[r] = tt2.get(t[r]);
      return e;
    }
    async _mapLoadToResolve(t, e) {
      let r = [...new Set(Object.values(t))];
      this._backgroundLoader.active = false;
      let s = await this.loader.load(r, e);
      this._backgroundLoader.active = true;
      let o = {};
      return r.forEach((n) => {
        let a = s[n.src], c = [n.src];
        n.alias && c.push(...n.alias), c.forEach((l) => {
          o[l] = a;
        }), tt2.set(c, a);
      }), o;
    }
    async unload(t) {
      this._initialized || await this.init();
      let e = Wt2(t).map((s) => typeof s != "string" ? s.src : s), r = this.resolver.resolve(e);
      await this._unloadFromResolved(r);
    }
    async unloadBundle(t) {
      this._initialized || await this.init(), t = Wt2(t);
      let e = this.resolver.resolveBundle(t), r = Object.keys(e).map((s) => this._unloadFromResolved(e[s]));
      await Promise.all(r);
    }
    async _unloadFromResolved(t) {
      let e = Object.values(t);
      e.forEach((r) => {
        tt2.remove(r.src);
      }), await this.loader.unload(e);
    }
    async _detectFormats(t) {
      let e = [];
      t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [t.preferredFormats]);
      for (let r of t.detections) t.skipDetections || await r.test() ? e = await r.add(e) : t.skipDetections || (e = await r.remove(e));
      return e = e.filter((r, s) => e.indexOf(r) === s), e;
    }
    get detections() {
      return this._detections;
    }
    setPreferences(t) {
      this.loader.parsers.forEach((e) => {
        e.config && Object.keys(e.config).filter((r) => r in t).forEach((r) => {
          e.config[r] = t[r];
        });
      });
    }
  };
  var _e2 = new La();
  U2.handleByList(_2.LoadParser, _e2.loader.parsers).handleByList(_2.ResolveParser, _e2.resolver.parsers).handleByList(_2.CacheParser, _e2.cache.parsers).handleByList(_2.DetectionParser, _e2.detections);
  U2.add(e0, s0, r0, c0, o0, n0, a0, l0, h0, u0, d0, Da, m0, t0, Jv, Oa, g0);
  var x0 = { loader: _2.LoadParser, resolver: _2.ResolveParser, cache: _2.CacheParser, detection: _2.DetectionParser };
  U2.handle(_2.Asset, (i3) => {
    let t = i3.ref;
    Object.entries(x0).filter(([e]) => !!t[e]).forEach(([e, r]) => U2.add(Object.assign(t[e], { extension: t[e].extension ?? r })));
  }, (i3) => {
    let t = i3.ref;
    Object.keys(x0).filter((e) => !!t[e]).forEach((e) => U2.remove(t[e]));
  });
  Do();
  ft2();
  rn2();
  var Na = class extends $e2 {
    constructor(t, e) {
      let { text: r, resolution: s, style: o, anchor: n, width: a, height: c, roundPixels: l, ...h } = t;
      super({ ...h }), this.batched = true, this._resolution = null, this._autoResolution = true, this._didTextUpdate = true, this._styleClass = e, this.text = r ?? "", this.style = o, this.resolution = s ?? null, this.allowChildren = false, this._anchor = new kt2({ _onUpdate: () => {
        this.onViewUpdate();
      } }), n && (this.anchor = n), this.roundPixels = l ?? false, a !== void 0 && (this.width = a), c !== void 0 && (this.height = c);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    }
    set text(t) {
      t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(t) {
      this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(t) {
      t || (t = {}), this._style?.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(t) {
      this._setWidth(t, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(t) {
      this._setHeight(t, this.bounds.height);
    }
    getSize(t) {
      return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
    }
    setSize(t, e) {
      typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this.bounds.width), e !== void 0 && this._setHeight(e, this.bounds.height);
    }
    containsPoint(t) {
      let e = this.bounds.width, r = this.bounds.height, s = -e * this.anchor.x, o = 0;
      return t.x >= s && t.x <= s + e && (o = -r * this.anchor.y, t.y >= o && t.y <= o + r);
    }
    onViewUpdate() {
      this.didViewUpdate || (this._didTextUpdate = true), super.onViewUpdate();
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(t = false) {
      super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t?.style) && this._style.destroy(t), this._style = null, this._text = null;
    }
  };
  function _0(i3, t) {
    let e = i3[0] ?? {};
    return (typeof e == "string" || i3[1]) && (L2(z, `use new ${t}({ text: "hi!", style }) instead`), e = { text: e, style: i3[1] }), e;
  }
  Ss();
  Br2();
  var ze2 = class extends Na {
    constructor(...t) {
      let e = _0(t, "Text");
      super(e, Pt2), this.renderPipeId = "text";
    }
    updateBounds() {
      let t = this._bounds, e = this._anchor, r = it2.measureText(this._text, this._style), { width: s, height: o } = r;
      t.minX = -e._x * s, t.maxX = t.minX + s, t.minY = -e._y * o, t.maxY = t.minY + o;
    }
  };
  Ue2();
  St2();
  rt2();
  Yc();
  fe2();
  lh();
  an2();
  Ss();
  Br2();
  Dt2();
  var Vw = Io(bl(), 1);
  U2.add(A_, E_);
  var Rt2 = { Add: "add", Remove: "remove", Update: "update" };
  var Ha = class {
    init(t) {
      throw new Error("Method not implemented.");
    }
    render(t) {
      throw new Error("Method not implemented.");
    }
  };
  var or2 = class {
    rendererName;
    rendererType;
    add = async (t, e, r) => {
      throw new Error("Method not implemented.");
    };
    remove = async (t, e, r) => {
      throw new Error("Method not implemented.");
    };
    update = async (t, e, r) => {
      throw new Error("Method not implemented.");
    };
  };
  var Wa = (i3 = [], t = []) => {
    let e = [], r = [], s = [], o = i3.filter((a) => !a.hidden), n = t.filter((a) => !a.hidden);
    for (let a of o) {
      let c = n.find((l) => l.id === a.id && l.type === a.type);
      c ? r.push({ prev: a, next: c }) : e.push(a);
    }
    for (let a of n) o.find((l) => l.id === a.id && l.type === a.type) || s.push(a);
    for (let a of i3) {
      let c = t.find((l) => l.id === a.id && l.type === a.type);
      c && c.hidden && !a.hidden && e.push(a);
    }
    return { toDeleteElements: e, toUpdateElements: r, toAddElements: s };
  };
  var kr2 = new (window.AudioContext || window.webkitAudioContext)();
  var Fi2 = class i {
    static loadedAssets = {};
    static load = async (t, e) => {
      if (!i.loadedAssets[t] && e.byteLength !== 0) try {
        let r = await kr2.decodeAudioData(e);
        i.loadedAssets[t] = r;
      } catch (r) {
        console.error(`AudioAsset.load: Failed to decode ${t}:`, r);
      }
    };
    static getAsset = (t) => i.loadedAssets[t];
  };
  var Bu = class {
    _audioSource;
    _gainNode;
    volume = 1;
    id;
    url;
    loop = false;
    constructor(t, e) {
      this.id = t, this.url = e.url, this.loop = e.loop || false, this.volume = e.volume ?? 1, this._gainNode = kr2.createGain(), this._gainNode.gain.value = this.volume, this._gainNode.connect(kr2.destination);
    }
    play = () => {
      let t = Fi2.getAsset(this.url);
      if (!t) {
        console.warn("AudioPlayer.play: Asset not found", this.url);
        return;
      }
      this._audioSource = kr2.createBufferSource(), this._audioSource.buffer = t, this._audioSource.loop = this.loop, this._gainNode.gain.setValueAtTime(this.volume, kr2.currentTime), this._audioSource.connect(this._gainNode), this._audioSource.start(0);
    };
    stop = () => {
      this._audioSource && (this._audioSource.stop(), this._audioSource.disconnect(), this._gainNode.disconnect(), this._gainNode = kr2.createGain(), this._gainNode.gain.value = this.volume, this._gainNode.connect(kr2.destination));
    };
  };
  var za = class {
    audioPlayers = [];
    stageAudios = [];
    add = (t) => {
      this.stageAudios.push(t);
    };
    remove = (t) => {
      this.stageAudios = this.stageAudios.filter((e) => e.id !== t);
    };
    getById = (t) => this.stageAudios.find((e) => e.id === t);
    tick = () => {
      for (let e of this.stageAudios) {
        let r = this.audioPlayers.find((s) => s.id === e.id);
        if (!r) {
          let s = new Bu(e.id, { url: e.url, loop: e.loop, volume: e.volume ?? 1 });
          this.audioPlayers.push(s), s.play();
          return;
        }
        (r.url !== e.url || r.loop !== e.loop) && (r.stop(), r.url = e.url, r.loop = e.loop ?? false, r.play()), r.volume !== (e.volume ?? 1) && (r.volume = e.volume ?? 1, r._gainNode.gain.value = r.volume);
      }
      let t = [];
      for (let e of this.audioPlayers) this.stageAudios.find((r) => r.id === e.id) || (e.stop(), t.push(e.id));
      this.audioPlayers = this.audioPlayers.filter((e) => !t.includes(e.id));
    };
    destroy = () => {
      for (let t of this.audioPlayers) t.stop();
      this.audioPlayers = [], this.stageAudios = [];
    };
  };
  var Xw = (i3) => i3.split("/").pop();
  var Ru = class {
    name = "advancedBufferLoader";
    priority = 2;
    constructor(t) {
      this.bufferMap = t;
    }
    test(t) {
      return true;
    }
    async load(t) {
      let e = t.startsWith("file:") ? t : Xw(t), r = this.bufferMap[e];
      if (!r) throw new Error(`Buffer not found for key: ${e}`);
      return { data: r.buffer, type: r.type, metadata: null };
    }
    async testParse(t) {
      return true;
    }
    async parse(t) {
      if (t instanceof B) return t;
      let e = new Blob([t.data], { type: t.type }), r = await createImageBitmap(e);
      return new B.from(r);
    }
    async unload(t) {
      t.destroy(true);
    }
  };
  var Gu = class i2 extends Ha {
    static rendererName = "pixi";
    _app;
    _audioStage = new za();
    _state = { elements: [], transitions: [] };
    _eventHandler;
    _plugins;
    _currentAbortController;
    _advancedLoader;
    get canvas() {
      return this._app.canvas;
    }
    init = async (t) => {
      let { eventHandler: e, plugins: r, width: s, height: o, backgroundColor: n } = t;
      for (let c of r) if (c.rendererName !== i2.rendererName) throw new Error("Plugin does not match renderer name");
      this._plugins = r, this._eventHandler = e, this._app = new Ga(), this._app.audioStage = this._audioStage, await this._app.init({ width: s, height: o, backgroundColor: n });
      let a = new Xt2();
      return a.rect(0, 0, s, o), a.fill(n || 0), this._app.stage.addChild(a), this._app.stage.width = s, this._app.stage.height = o, this._app.ticker.add(this._app.audioStage.tick), this;
    };
    destroy = () => {
      this._app.audioStage.destroy(), this._app.destroy();
    };
    _classifyAsset = (t) => t ? t.startsWith("audio/") ? "audio" : t.startsWith("font/") || ["application/font-woff", "application/font-woff2", "application/x-font-ttf", "application/x-font-otf"].includes(t) ? "font" : "texture" : "texture";
    loadAssets = async (t) => {
      if (!t) throw new Error("assetBufferMap is required");
      let e = { audio: {}, font: {}, texture: {} };
      for (let [s, o] of Object.entries(t)) {
        let n = this._classifyAsset(o.type);
        e[n][s] = o;
      }
      await Promise.all(Object.entries(e.audio).map(([s, o]) => Fi2.load(s, o.buffer))), await Promise.all(Object.entries(e.font).map(async ([s, o]) => {
        let n = new Blob([o.buffer], { type: o.type }), a = URL.createObjectURL(n), c = new FontFace(s, `url(${a})`);
        try {
          await c.load(), document.fonts.add(c), console.log(`Font loaded successfully: ${s}`);
        } catch (l) {
          console.error(`Failed to load font ${s}:`, l);
        } finally {
          URL.revokeObjectURL(a);
        }
      })), this._advancedLoader ? Object.assign(this._advancedLoader.bufferMap, e.texture) : (this._advancedLoader = new Ru(e.texture), _e2.loader.parsers.length = 0, _e2.reset(), U2.add({ name: "advanced-buffer-loader", extension: _2.Asset, priority: Et2.High, loader: this._advancedLoader }), typeof _e2.registerPlugin == "function" && _e2.registerPlugin(this._advancedLoader));
      let r = Object.keys(e.texture);
      return Promise.all(r.map((s) => _e2.load(s)));
    };
    loadAudioAssets = async (t) => Promise.all(t.map(async (e) => {
      let s = await (await fetch(e)).arrayBuffer();
      return Fi2.load(e, s);
    }));
    updatedBackgroundColor = (t) => {
      this._app.renderer.background.color = t;
    };
    getStageElementBounds = () => {
      let t = {}, e = (r) => {
        if (!(!r || r.length === 0)) for (let s of r) t[s.label] = { x: s.groupTransform.tx, y: s.groupTransform.ty, width: s.width, height: s.height }, e(s.children);
      };
      return e(this._app.stage.children), t;
    };
    render = (t) => {
      this._render(this._app, this._app.stage, this._state, t, this._eventHandler), this._state = t;
    };
    _getRendererByElement = (t) => {
      for (let e of this._plugins) if (e.rendererType === t.type) return e;
      throw new Error(`No renderer found for element type: ${t.type}`);
    };
    _getTransitionByType = (t) => {
      for (let e of this._plugins) if (e.transitionType === t) return e;
      throw new Error(`No transition found for transition type: ${t}`);
    };
    _applyGlobalCursorStyles = (t, e, r) => {
      t.renderer.events.cursorStyles || (t.renderer.events.cursorStyles = {}), t.renderer.events.cursorStyles.default || (t.renderer.events.cursorStyles.default = "default"), t.renderer.events.cursorStyles.hover || (t.renderer.events.cursorStyles.hover = "pointer");
      let s = e?.cursorStyles, o = r?.cursorStyles;
      JSON.stringify(s) !== JSON.stringify(o) && (o ? (o.default && (t.renderer.events.cursorStyles.default = o.default, t.canvas.style.cursor = o.default), o.hover && (t.renderer.events.cursorStyles.hover = o.hover)) : s && (t.renderer.events.cursorStyles.default = "default", t.renderer.events.cursorStyles.hover = "pointer"));
    };
    _render = async (t, e, r, s, o) => {
      let n = Date.now();
      this._applyGlobalCursorStyles(t, r.global, s.global);
      let { toAddElements: a, toUpdateElements: c, toDeleteElements: l } = Wa(r.elements, s.elements);
      this._currentAbortController && this._currentAbortController.abort(), this._currentAbortController = new AbortController();
      let h = this._currentAbortController.signal, u = [];
      for (let f of l) {
        let d2 = this._getRendererByElement(f);
        u.push(() => d2.remove(t, { parent: e, element: f, elements: s.elements, transitions: s.transitions, getRendererByElement: this._getRendererByElement, getTransitionByType: this._getTransitionByType, eventHandler: o }, h));
      }
      for (let f of a) {
        let d2 = this._getRendererByElement(f);
        u.push(() => d2.add(t, { parent: e, element: f, elements: s.elements, getRendererByElement: this._getRendererByElement, transitions: s.transitions, getTransitionByType: this._getTransitionByType, eventHandler: o }, h));
      }
      for (let f of c) {
        let d2 = this._getRendererByElement(f.next);
        u.push(() => d2.update(t, { parent: e, prevElement: f.prev, nextElement: f.next, elements: s.elements, getRendererByElement: this._getRendererByElement, transitions: s.transitions, getTransitionByType: this._getTransitionByType, eventHandler: o }, h));
      }
      try {
        await Promise.all(u.map((f) => f())), t.stage.children.sort((f, d2) => {
          let m = s.elements.find((x2) => x2.id === f.label), g = s.elements.find((x2) => x2.id === d2.label);
          if (m && g) {
            let x2 = m.zIndex ?? 0, b = g.zIndex ?? 0;
            if (x2 !== b) return x2 - b;
            let y = s.elements.findIndex((T2) => T2.id === f.label), v = s.elements.findIndex((T2) => T2.id === d2.label);
            return y - v;
          }
          if (!m && !g) return 0;
          if (!m) return -1;
          if (!g) return 1;
        }), o && o("completed", { id: s.id, diffTime: Date.now() - n });
      } catch (f) {
        if (f.name === "AbortError") return;
        throw console.error("Error:", f), f;
      } finally {
        this._currentAbortController = void 0;
      }
    };
  };
  var y0 = Gu;
  var ku = class extends or2 {
    static rendererName = "pixi";
    rendererName = "pixi";
    rendererType = "sprite";
    add = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, element: o, transitions: n = [], getTransitionByType: a, eventHandler: c, elements: l = [] } = e, h = o.url ? B.from(o.url) : B.EMPTY, u, f, d2 = o.scaleX ?? 1, m = o.scaleY ?? 1;
      o.hoverUrl && (u = B.from(o.hoverUrl)), o.clickUrl && (f = B.from(o.clickUrl));
      let g = new Ft2(h);
      g.label = o.id, g.interactiveChildren = false, (o.eventName || o.hoverUrl || o.clickUrl) && (g.cursor = "hover", g.eventMode = "static"), o.width !== void 0 ? g.width = o.width * d2 : g.width *= d2, o.height !== void 0 ? g.height = o.height * m : g.height *= m, o.anchorX !== void 0 && (g.pivot.x = g.width * o.anchorX), o.anchorY !== void 0 && (g.pivot.y = g.height * o.anchorY), o.rotation !== void 0 && (g.rotation = o.rotation * Math.PI / 180), o.x !== void 0 && (g.x = o.x), o.y !== void 0 && (g.y = o.y), o.zIndex !== void 0 && (g.zIndex = o.zIndex), o.alpha !== void 0 && (g.alpha = o.alpha), (u || f) && g.on("pointerup", () => {
        g.texture = h;
      }).on("pointerupoutside", () => {
        g.texture = h;
      }).on("pointerleave", () => {
        g.texture = h;
      }), f && g.on("pointerdown", () => {
        g.texture = f;
      }), u && g.on("pointerenter", () => {
        g.texture = u;
      }), g.on("pointerup", (b) => {
        b.stopPropagation();
        let y = b.button;
        y === 0 ? c && c(o.eventName, o.eventPayload) : y === 2 && (o.rightClickEventName && c ? c(o.rightClickEventName) : t.stage.emit("rightclick", event));
      });
      let x2 = [];
      for (let b of n) if (b.elementId === o.id && b.event === Rt2.Add) {
        let y = a(b.type);
        if (!y) throw new Error(`Transition class not found for type ${b.type}`);
        x2.push(y.add(t, g, b, r));
      }
      s.addChild(g), Array.isArray(l) && l.length > 0 && s.children.sort((b, y) => {
        let v = l.find((P) => P.id === b.label), T2 = l.find((P) => P.id === y.label);
        if (v && T2) {
          let P = v.zIndex ?? 0, w = T2.zIndex ?? 0;
          if (P !== w) return P - w;
          let C = l.findIndex((M2) => M2.id === b.label), G2 = l.findIndex((M2) => M2.id === y.label);
          return C - G2;
        }
        if (!v && !T2) return 0;
        if (!v) return -1;
        if (!T2) return 1;
      }), await Promise.all(x2);
    };
    remove = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, element: o, transitions: n = [], getTransitionByType: a } = e, c = s.getChildByName(o.id);
      if (!c) throw new Error(`Sprite with id ${o.id} not found`);
      let l = [];
      for (let h of n) if (h.elementId === o.id && h.event === Rt2.Remove) {
        let u = a(h.type);
        if (!u) throw new Error(`Transition class not found for type ${h.type}`);
        l.push(u.remove(t, c, h, r));
      }
      await Promise.all(l), c && c.destroy();
    };
    update = async (t, { parent: e, prevElement: r, nextElement: s, transitions: o = [], getTransitionByType: n, eventHandler: a }, c) => {
      if (c?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let l = e.getChildByName(r.id);
      if (!l) throw new Error(`Sprite with id ${r.id} not found`);
      let h = [];
      for (let d2 of o) if (d2.elementId === r.id && d2.event === Rt2.Update) {
        let m = n(d2.type);
        if (!m) throw new Error(`Transition class not found for type ${d2.type}`);
        h.push(m.add(t, l, d2, c));
      }
      h.length > 0 ? (await Promise.all(h), u()) : f();
      function u() {
        if (r.url !== s.url || r.hoverUrl !== s.hoverUrl || r.clickUrl !== s.clickUrl) {
          if (s.url) {
            let x2 = B.from(s.url);
            if (l.texture = x2, !r.url && s.url) if (x2.baseTexture.valid) {
              let b = s.scaleX ?? 1, y = s.scaleY ?? 1;
              l.width = (s.width ?? x2.width) * b, l.height = (s.height ?? x2.height) * y;
            } else x2.baseTexture.once("loaded", () => {
              let b = s.scaleX ?? 1, y = s.scaleY ?? 1;
              l.width = (s.width ?? x2.width) * b, l.height = (s.height ?? x2.height) * y;
            });
          }
          let m = r.hoverUrl || r.clickUrl, g = s.hoverUrl || s.clickUrl;
          if (!m && g) {
            let x2 = l.texture;
            l.on("pointerup", () => {
              l.texture = x2;
            }).on("pointerupoutside", () => {
              l.texture = x2;
            }).on("pointerleave", () => {
              l.texture = x2;
            });
          }
          if (s.hoverUrl) {
            let x2 = B.from(s.hoverUrl);
            l.off("pointerenter"), l.on("pointerenter", () => {
              l.texture = x2;
            });
          }
          if (s.clickUrl) {
            let x2 = B.from(s.clickUrl);
            l.off("pointerdown"), l.on("pointerdown", () => {
              l.texture = x2;
            });
          }
        }
        (s.eventName || s.hoverUrl || s.clickUrl) && (l.cursor = "hover", l.eventMode = "static");
      }
      function f() {
        if (r.url !== s.url || r.hoverUrl !== s.hoverUrl || r.clickUrl !== s.clickUrl) {
          if (s.url) {
            let y = B.from(s.url);
            if (l.texture = y, !r.url && s.url) if (y.baseTexture.valid) {
              let v = s.scaleX ?? 1, T2 = s.scaleY ?? 1;
              l.width = (s.width ?? y.width) * v, l.height = (s.height ?? y.height) * T2;
            } else y.baseTexture.once("loaded", () => {
              let v = s.scaleX ?? 1, T2 = s.scaleY ?? 1;
              l.width = (s.width ?? y.width) * v, l.height = (s.height ?? y.height) * T2;
            });
          }
          let x2 = r.hoverUrl || r.clickUrl, b = s.hoverUrl || s.clickUrl;
          if (!x2 && b) {
            let y = l.texture;
            l.on("pointerup", () => {
              l.texture = y;
            }).on("pointerupoutside", () => {
              l.texture = y;
            }).on("pointerleave", () => {
              l.texture = y;
            });
          }
          if (s.hoverUrl) {
            let y = B.from(s.hoverUrl);
            l.off("pointerenter"), l.on("pointerenter", () => {
              l.texture = y;
            });
          }
          if (s.clickUrl) {
            let y = B.from(s.clickUrl);
            l.off("pointerdown"), l.on("pointerdown", () => {
              l.texture = y;
            });
          }
        }
        s.x !== void 0 && s.x !== r.x && (l.x = s.x), s.y !== void 0 && s.y !== r.y && (l.y = s.y), s.rotation !== void 0 && s.rotation !== r.rotation && (l.rotation = s.rotation * Math.PI / 180);
        let m = s.scaleX ?? 1, g = s.scaleY ?? 1;
        s.width !== void 0 && (s.width !== r.width || m !== (r.scaleX ?? 1)) && (l.width = s.width * m), s.height !== void 0 && (s.height !== r.height || g !== (r.scaleY ?? 1)) && (l.height = s.height * g), s.anchorX !== void 0 && s.anchorX !== r.anchorX && (l.pivot.x = l.width * s.anchorX / m), s.anchorY !== void 0 && s.anchorY !== r.anchorY && (l.pivot.y = l.height * s.anchorY / g), s.zIndex !== void 0 && s.zIndex !== r.zIndex && (l.zIndex = s.zIndex), s.alpha !== void 0 && s.alpha !== r.alpha && (l.alpha = s.alpha), (s.eventName || s.hoverUrl || s.clickUrl) && (l.cursor = "hover", l.eventMode = "static");
      }
    };
  };
  var Va = (i3) => new Pt2({ wordWrap: i3.wordWrap || true, breakWords: i3.breakWords || false, align: i3.align, fill: i3.fill, fontSize: i3.fontSize, lineHeight: i3.lineHeight, wordWrapWidth: i3.wordWrapWidth, fontFamily: i3.fontFamily || "Roboto", stroke: i3.strokeColor ? { color: i3.strokeColor, width: i3.strokeWidth } : void 0 });
  var Iu = class {
    static rendererName = "pixi";
    rendererName = "pixi";
    rendererType = "text";
    add = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, element: o, transitions: n = [], getTransitionByType: a, eventHandler: c } = e, l = Va(o.style), h = new ze2({ text: o.text, style: l }), u;
      o.hoverStyle && (u = Va(o.hoverStyle));
      let f;
      if (o.clickedStyle && (f = Va(o.clickedStyle)), (o.eventName || o.clickedStyle || o.hoverStyle) && (h.cursor = "hover", h.eventMode = "static"), h.label = o.id, o.x !== void 0 && (h.x = o.x), o.y !== void 0 && (h.y = o.y), o.anchorX !== void 0 && (h.anchor.x = o.anchorX), o.anchorY !== void 0 && (h.anchor.y = o.anchorY), o.anchorX !== void 0 || o.anchorY !== void 0) {
        let m = h.getLocalBounds();
        h.hitArea = new Y2(-m.width * h.anchor.x, -m.height * h.anchor.y, m.width, m.height);
      }
      h.on("pointerout", () => {
        h.isOver = false;
      }).on("pointerupoutside", () => {
        h.style = l;
      }).on("pointerup", () => {
        h.style = l;
      }).on("pointerleave", () => {
        h.style = l;
      }), h.on("pointerup", (m) => {
        o.clickSoundUrl && t.soundStage && t.soundStage.add({ id: `${o.id}-click-${Math.random()}`, url: o.clickSoundUrl, loop: false, volume: o.clickSoundVolume ?? 50 / 100 }), m.stopPropagation(), c && c(o.eventName, o.eventPayload);
      }), f && h.on("pointerdown", () => {
        h.style = f;
      }), u && h.on("pointerenter", () => {
        h.style = u, o.hoverSoundUrl && t.soundStage && o.hoverSoundVolume !== void 0 && t.soundStage.add({ id: `${o.id}-hover-${Math.random()}`, url: o.hoverSoundUrl, loop: false, volume: o.hoverSoundVolume / 100 });
      });
      let d2 = [];
      for (let m of n) if (m.elementId === o.id && m.event === Rt2.Add) {
        let g = a(m.type);
        if (!g) throw new Error(`Transition class not found for type ${m.type}`);
        d2.push(g.add(t, h, m, r));
      }
      s.addChild(h), await Promise.all(d2);
    };
    remove = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, element: o, transitions: n = [], getTransitionByType: a } = e, c = s.getChildByName(o.id);
      if (!c) {
        console.warn(`Text with id ${o.id} not found`);
        return;
      }
      let l = [];
      for (let h of n) if (h.elementId === o.id && h.event === Rt2.Remove) {
        let u = a(h.type);
        if (!u) throw new Error(`Transition class not found for type ${h.type}`);
        l.push(u.remove(t, c, h, r));
      }
      await Promise.all(l), c && c.destroy();
    };
    update = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, prevElement: o, nextElement: n, transitions: a, getTransitionByType: c, eventHandler: l } = e, h = s.getChildByName(o.id);
      if (!h) {
        console.warn(`Text with id ${o.id} not found`);
        return;
      }
      if (JSON.stringify(o) !== JSON.stringify(n)) {
        let u = [this.add(t, { parent: s, element: n, transitions: a, getTransitionByType: c, eventHandler: l }, r), this.remove(t, { parent: s, element: o, transitions: a, getTransitionByType: c }, r)];
        await Promise.all(u);
      } else o.text !== n.text && (h.text = n.text), JSON.stringify(o.style) !== JSON.stringify(n.style) && (h.style = Va(n?.style)), n.x !== void 0 && (h.x = n.x), n.y !== void 0 && (h.y = n.y);
    };
  };
  var At2 = (i3, t = false) => new Pt2({ wordWrap: i3.wordWrap || true, breakWords: t, align: i3.align, fill: i3.fill, fontSize: i3.fontSize, lineHeight: i3.lineHeight, wordWrapWidth: i3.wordWrapWidth, fontFamily: i3.fontFamily || "Roboto", whiteSpace: "pre", trim: false, stroke: i3.strokeColor ? { color: i3.strokeColor, width: i3.strokeWidth } : void 0 });
  var Fu = class {
    static rendererName = "pixi";
    rendererName = "pixi";
    rendererType = "text-revealing";
    add = async (t, { parent: e, element: r }) => {
      let s = r.content?.[0]?.text || "", o = At2(r.style, s), n = new ze2({ text: "", style: o });
      n.label = r.id, n.text_id = s;
      let a = new ct2();
      r.x !== void 0 && (a.x = r.x), r.y !== void 0 && (a.y = r.y), a.addChild(n), a.label = r.id, e.addChild(a);
      let c = r.style.wordWrapWidth || 500, l = r.content && r.content.length > 0 ? r.content.map((P) => ({ text: P.text.replace(/ +$/, (w) => "\xA0".repeat(w.length)), style: P.style ? { ...r.style, ...P.style } : r.style, align: P.align || r.align || "top", furigana: P.furigana })) : r.segments, h = [];
      if (l.length === 1) {
        let P = [], w = 0, C = 0, G2 = 0, M2 = [...l];
        for (; ; ) {
          let S2 = M2[0];
          if (!S2) {
            P.length > 0 && h.push({ lineParts: P, y: C });
            break;
          }
          if (C > 1e4) break;
          let A2 = { ...S2.style, wordWrapWidth: c - w }, R2 = it2.measureText(S2.text, At2(A2));
          R2.lineHeight > G2 && (G2 = R2.lineHeight);
          let F2 = it2.measureText("a", At2(A2)), X = it2.measureText("a a", At2(A2)).width - F2.width * 2;
          if (R2.lineWidths[0] + w > c) {
            w = 0, h.push({ lineParts: P, y: C }), C += G2, G2 = 0, P = [];
            continue;
          }
          let D = R2.lines[0];
          R2.lines.length === 1 && S2.text.endsWith(" ") && !D.endsWith(" ") && (D += " ");
          let k2 = R2.lines.slice(1).join(" "), gt2 = { text: D, style: A2, x: w, y: 0, align: S2.align };
          if (P.push(gt2), k2 && k2.length > 0 ? S2.text = k2 : M2.shift(), !(!D || D.length === 0)) {
            if (S2.furigana) {
              let j2 = it2.measureText(S2.furigana.text, At2(S2.furigana.style)), xt2 = { text: S2.furigana.text, style: S2.furigana.style, x: w + (R2.width - j2.width) / 2, y: -10 };
              P.push(xt2);
            }
            w += R2.lineWidths[0] + X;
          }
        }
      } else {
        let P = [], w = 0, C = 0, G2 = 0, M2 = [...l], S2 = /* @__PURE__ */ new WeakSet();
        for (; ; ) {
          let A2 = M2[0];
          if (!A2) {
            P.length > 0 && h.push({ lineParts: P, y: C });
            break;
          }
          if (C > 1e4) break;
          let R2 = { ...A2.style, wordWrapWidth: c - w }, F2 = it2.measureText(A2.text, At2(R2));
          F2.lineHeight > G2 && (G2 = F2.lineHeight);
          let W2 = it2.measureText("a", At2(R2)), D = it2.measureText("a a", At2(R2)).width - W2.width * 2;
          if (F2.lineWidths[0] + w > c) {
            w = 0, h.push({ lineParts: P, y: C }), C += G2, G2 = 0, P = [];
            continue;
          }
          let k2 = F2.lines[0];
          F2.lines.length === 1 && A2.text.endsWith(" ") && !k2.endsWith(" ") && (k2 += " ");
          let gt2 = F2.lines.slice(1).join(" "), j2 = { text: k2, style: R2, x: w, y: 0, align: A2.align };
          if (P.push(j2), gt2 && gt2.length > 0 ? A2.text = gt2 : M2.shift(), !(!k2 || k2.length === 0)) {
            if (A2.furigana && !S2.has(A2)) {
              S2.add(A2);
              let xt2 = it2.measureText(A2.furigana.text, At2(A2.furigana.style)), te2 = { text: A2.furigana.text, style: A2.furigana.style, x: w + (F2.lineWidths[0] - xt2.width) / 2, y: 0, isFurigana: true, parentAlign: A2.align, parentX: w, parentWidth: F2.lineWidths[0] };
              P.push(te2);
            }
            w += F2.lineWidths[0];
          }
        }
      }
      h.forEach((P) => {
        let w = new ct2();
        w.y = P.y, w.alpha = 0;
        let C = 0;
        P.lineParts.forEach((M2) => {
          let S2 = it2.measureText(M2.text, At2(M2.style));
          S2.height > C && (C = S2.height);
        });
        let G2 = /* @__PURE__ */ new Map();
        P.lineParts.forEach((M2) => {
          if (!M2.isFurigana) {
            let S2 = it2.measureText(M2.text, At2(M2.style)), A2 = M2.y, R2 = M2.align || "top";
            R2 === "center" ? A2 += (C - S2.height) / 2 : R2 === "bottom" && (A2 += C - S2.height);
            let F2 = new ze2({ text: M2.text, style: At2(M2.style), x: M2.x, y: A2 });
            w.addChild(F2), G2.set(M2.x, { yOffset: A2, height: S2.height });
          }
        }), P.lineParts.forEach((M2) => {
          if (M2.isFurigana) {
            let S2 = it2.measureText(M2.text, At2(M2.style)), A2 = G2.get(M2.parentX), R2 = -S2.height - 5;
            A2 && (R2 = A2.yOffset - S2.height + 2);
            let F2 = new ze2({ text: M2.text, style: At2(M2.style), x: M2.x, y: R2 });
            w.addChild(F2);
          }
        }), a.addChild(w);
      });
      let u = new Xt2(), f = 1e3, d2 = c / 2, m = c / 2;
      u.fill({ color: 16777215, alpha: 1 }), u.rect(0, 0, d2, f);
      for (let P = 0; P < m; P++) u.fill({ color: 16777215, alpha: 1 - P / m }), u.rect(d2 + P, 0, d2 + 1, f);
      let g = t.renderer.generateTexture(u), x2 = new Ft2(g);
      x2.x = -1.35 * d2 - m, t.stage.addChild(x2);
      let b = null, y = null;
      if (r.indicator?.revealing?.url) {
        let P = B.from(r.indicator.revealing.url);
        b = new Ft2(P), b.anchor.set(0, 0.5), b.visible = false, r.indicator.revealing.width !== void 0 && (b.width = r.indicator.revealing.width), r.indicator.revealing.height !== void 0 && (b.height = r.indicator.revealing.height), a.addChild(b);
      }
      if (r.indicator?.complete?.url) {
        let P = B.from(r.indicator.complete.url);
        y = new Ft2(P), y.anchor.set(0, 0.5), y.visible = false, r.indicator.complete.width !== void 0 && (y.width = r.indicator.complete.width), r.indicator.complete.height !== void 0 && (y.height = r.indicator.complete.height), a.addChild(y);
      }
      let v = 0, T2 = 1;
      if (h.length !== 0) {
        if (r.displaySpeed === 100 || r.hasEnded) {
          if (a.children.forEach((P) => {
            t.stage.removeChild(x2), P.mask = null, P.alpha = 1;
          }), y && (y.visible = true, h.length > 0)) {
            let P = h[h.length - 1], w = 0, C = P.y;
            P.lineParts.forEach((G2) => {
              if (!G2.isFurigana) {
                let M2 = it2.measureText(G2.text, At2(G2.style)), S2 = G2.x + M2.width;
                S2 > w && (w = S2);
              }
            }), y.x = w + 10, y.y = C + 20;
          }
          return;
        }
        await new Promise((P) => {
          let w = (C) => {
            if (T2 > a.children.length) {
              if (b && (b.visible = false), y && (y.visible = true, h.length > 0)) {
                let S2 = h[h.length - 1], A2 = 0, R2 = S2.y;
                S2.lineParts.forEach((F2) => {
                  if (!F2.isFurigana) {
                    let W2 = it2.measureText(F2.text, At2(F2.style)), X = F2.x + W2.width;
                    X > A2 && (A2 = X);
                  }
                }), y.x = A2 + 10, y.y = R2 + 20;
              }
              P();
              return;
            }
            a.getChildAt(T2).mask || (a.getChildAt(T2).mask = x2, a.getChildAt(T2).alpha = 1), v += C.deltaMS;
            let M2 = (r.displaySpeed || 50) / 1e3;
            if (x2.x += M2 * v, b && T2 <= h.length) {
              let S2 = h[T2 - 1];
              if (S2 && (a.getChildAt(T2).mask === x2 || T2 === h.length)) {
                b.visible = true;
                let R2 = x2.x + d2 + m + 150, F2 = 0, W2 = false, X = true, D = 0;
                for (let k2 of S2.lineParts) if (!k2.isFurigana) {
                  let gt2 = it2.measureText(k2.text, At2(k2.style));
                  D = Math.max(D, k2.x + gt2.width);
                }
                for (let k2 of S2.lineParts) if (!k2.isFurigana) {
                  let gt2 = it2.measureText(k2.text, At2(k2.style)), j2 = k2.x, xt2 = k2.x + gt2.width;
                  if (xt2 <= R2) F2 = xt2, W2 = true;
                  else if (j2 < R2) {
                    F2 = Math.max(j2, R2), W2 = true, X = false;
                    break;
                  } else X = false;
                }
                R2 >= D && (X = true), W2 && F2 > 0 ? (b.x = F2, b.y = S2.y + 20) : T2 === h.length && D > 0 ? (b.x = D, b.y = S2.y + 20) : b.visible = false, y && (y.visible = false);
              } else b.visible = false;
            }
            if (x2.x >= 0 && (a.getChildAt(T2).mask = null, x2.x = -1.35 * d2 - m, T2 = T2 + 1, v = 0, T2 === a.children.length)) {
              if (b && (b.visible = false), y && (y.visible = true, h.length > 0)) {
                let S2 = h[h.length - 1], A2 = 0, R2 = S2.y;
                S2.lineParts.forEach((F2) => {
                  if (!F2.isFurigana) {
                    let W2 = it2.measureText(F2.text, At2(F2.style)), X = F2.x + W2.width;
                    X > A2 && (A2 = X);
                  }
                }), y.x = A2 + 10, y.y = R2 + 20;
              }
              t.ticker.remove(w), P();
            }
          };
          t.ticker.add(w);
        });
      }
    };
    remove = async (t, e) => {
      let { parent: r, element: s, transitions: o = [], getTransitionByType: n } = e, a = r.getChildByName(s.id);
      if (!a) {
        console.warn(`Text with id ${s.id} not found`, { parent: r });
        return;
      }
      let c = [];
      for (let l of o) if (l.elementId === s.id && l.event === Rt2.Remove) {
        let h = n(l.type);
        if (!h) throw new Error(`Transition class not found for type ${l.type}`);
        c.push(h.remove(t, a, l));
      }
      await Promise.all(c), a.destroy();
    };
    update = async (t, e) => {
      let { parent: r, prevElement: s, nextElement: o } = e;
      if (!r.getChildByName(s.id)) {
        console.warn(`Text with id ${s.id} not found`, { parent: r });
        return;
      }
      await this.remove(t, { parent: r, element: s }), await this.add(t, { parent: r, element: o });
    };
  };
  var Uu = class {
    static rendererName = "pixi";
    rendererName = "pixi";
    rendererType = "container";
    add = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, element: o, elements: n = [], transitions: a = [], getTransitionByType: c, getRendererByElement: l, eventHandler: h } = e, u = structuredClone(o), f = new ct2();
      f.label = u.id;
      let d2 = {};
      u.x !== void 0 && (typeof u.x == "string" && u.x.endsWith("%") ? f.x = Number(u.x.replace("%", "")) * t.screen.width / 100 : f.x = u.x), u.y !== void 0 && (typeof u.y == "string" && u.y.endsWith("%") ? f.y = Number(u.y.replace("%", "")) * t.screen.height / 100 : f.y = u.y), u.scaleX !== void 0 && (f.scale.x = u.scaleX), u.scaleY !== void 0 && (f.scale.y = u.scaleY), u.zIndex !== void 0 && (f.zIndex = u.zIndex), u.rotation !== void 0 && (f.rotation = u.rotation * Math.PI / 180), u.propagateEvents && (f.eventMode = "static", ["pointerup", "pointerupoutside", "pointerleave", "pointerdown", "pointerenter"].forEach((M2) => {
        f.on(M2, (S2) => {
          S2.stopPropagation();
          for (let A2 of f.children) A2.emit(M2);
        });
      }));
      let m = u.gap || 0, g = new Xt2().roundRect(0, 0, u.width || 0, u.height || 0, 1).fill(u.fill ? u.fill.color : "transparent"), x2 = [0, 0.5, 1], b = u.anchorX ?? 0, y = u.anchorY ?? 0;
      if (!x2.includes(b)) throw new Error(`Invalid anchorX value: ${b}. Must be 0, 0.5, or 1`);
      if (!x2.includes(y)) throw new Error(`Invalid anchorY value: ${y}. Must be 0, 0.5, or 1`);
      if (u.direction) {
        let M2, S2;
        u.direction === "horizontal" ? (M2 = u.children.reduce((R2, F2, W2) => R2 + F2.width + (W2 > 0 ? m : 0), 0), S2 = u.children.reduce((R2, F2) => Math.max(R2, F2.height || 0), 0)) : u.direction === "vertical" && (M2 = u.children.reduce((R2, F2) => Math.max(R2, F2.width || 0), 0), S2 = u.children.reduce((R2, F2, W2) => R2 + F2.height + (W2 > 0 ? m : 0), 0));
        let A2 = { x: b, y };
        u.direction === "horizontal" ? this.layoutChildren({ element: u, anchor: A2, totalWidth: M2, totalHeight: S2, gap: m, direction: "horizontal", scroll: u.scroll }) : u.direction === "vertical" && this.layoutChildren({ element: u, anchor: A2, totalWidth: M2, totalHeight: S2, gap: m, direction: "vertical", scroll: u.scroll }), this.setupScrolling({ container: f, element: u, totalHeight: S2, totalWidth: M2, eventHandler: h, sliderRef: d2 }), g = this.createContainerGraphic(u, M2, S2, A2);
      }
      g.label = `${u.id}-container-background`, f.addChild(g);
      let v = [];
      (u.children || []).forEach((M2) => {
        let S2 = l(M2), A2 = u.width || 0, R2 = u.height || 0, F2 = b * A2, W2 = y * R2, X = { zIndex: u.zIndex, ...M2, x: (M2.x || 0) + F2, y: (M2.y || 0) + W2 };
        v.push(S2.add(t, { parent: f, element: X, elements: u.children || [], transitions: a, getTransitionByType: c, getRendererByElement: l, eventHandler: h }, r));
      });
      let T2 = [];
      for (let M2 of a) if (M2.elementId === u.id && M2.event === Rt2.Add) {
        let S2 = c(M2.type);
        if (!S2) throw new Error(`Transition class not found for type ${M2.type}`);
        T2.push(S2.add(t, f, M2, r));
      }
      s.addChild(f), await Promise.all([...v, ...T2]);
      let { width: P, height: w } = this.getContainerDimensions(u, f), C = b * P, G2 = y * w;
      f.pivot.x = C, f.pivot.y = G2;
    };
    remove = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      console.log("remove container 11111111111");
      let { parent: s, element: o } = e, n = s.getChildByName(o.id);
      if (!n) {
        console.warn(`Container with id ${o.id} not found`);
        return;
      }
      n.destroy();
    };
    update = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, prevElement: o, nextElement: n, elements: a = [], getRendererByElement: c, transitions: l = [], getTransitionByType: h, eventHandler: u } = e, f = structuredClone(o), d2 = structuredClone(n), m = s.getChildByName(f.id);
      if (!m) {
        console.warn(`Container with id ${f.id} not found`);
        return;
      }
      d2.x !== void 0 && (m.x = d2.x), d2.y !== void 0 && (m.y = d2.y), d2.rotation !== void 0 && d2.rotation !== f.rotation && (m.rotation = d2.rotation * Math.PI / 180);
      let g = [0, 0.5, 1], x2 = d2.anchorX ?? 0, b = d2.anchorY ?? 0;
      if (!g.includes(x2)) throw new Error(`Invalid anchorX value: ${x2}. Must be 0, 0.5, or 1`);
      if (!g.includes(b)) throw new Error(`Invalid anchorY value: ${b}. Must be 0, 0.5, or 1`);
      if (d2.direction) {
        let S2 = d2.gap || 0, A2, R2;
        d2.direction === "horizontal" ? (A2 = d2.children.reduce((X, D, k2) => X + D.width + (k2 > 0 ? S2 : 0), 0), R2 = d2.children.reduce((X, D) => Math.max(X, D.height || 0), 0)) : d2.direction === "vertical" && (A2 = d2.children.reduce((X, D) => Math.max(X, D.width || 0), 0), R2 = d2.children.reduce((X, D, k2) => X + D.height + (k2 > 0 ? S2 : 0), 0));
        let F2 = { x: x2, y: b };
        d2.direction === "horizontal" ? this.layoutChildren({ element: d2, anchor: F2, totalWidth: A2, totalHeight: R2, gap: S2, direction: "horizontal", scroll: d2.scroll }) : d2.direction === "vertical" && this.layoutChildren({ element: d2, anchor: F2, totalWidth: A2, totalHeight: R2, gap: S2, direction: "vertical", scroll: d2.scroll });
        let W2 = m.children.find((X) => X.label === `${d2.id}-container-background`);
        if (W2) {
          W2.destroy();
          let X = this.createContainerGraphic(d2, A2, R2, F2);
          X.label = `${d2.id}-container-background`, m.addChildAt(X, 0);
        }
        f.scroll !== d2.scroll && this.setupScrolling({ container: m, element: d2, totalHeight: R2, totalWidth: A2, eventHandler: u, sliderRef: {} });
      }
      let y = [], { toAddElements: v, toUpdateElements: T2, toDeleteElements: P } = Wa(f.children, d2.children);
      if (d2.direction && d2.children) {
        let S2 = /* @__PURE__ */ new Map();
        d2.children.forEach((A2) => {
          S2.set(A2.id, { x: A2.x, y: A2.y });
        }), T2.forEach((A2) => {
          let R2 = S2.get(A2.next.id);
          R2 && (A2.next.x = R2.x, A2.next.y = R2.y);
        }), v.forEach((A2) => {
          let R2 = S2.get(A2.id);
          R2 && (A2.x = R2.x, A2.y = R2.y);
        });
      }
      for (let S2 of P) {
        let A2 = c(S2);
        y.push(A2.remove(t, { parent: m, element: S2, elements: d2.children || [], transitions: l, getTransitionByType: h, getRendererByElement: c, eventHandler: u }, r));
      }
      for (let S2 of v) {
        let A2 = c(S2), R2 = d2.width || 0, F2 = d2.height || 0, W2 = x2 * R2, X = b * F2, D = { ...S2, x: (S2.x || 0) + W2, y: (S2.y || 0) + X };
        y.push(A2.add(t, { parent: m, element: D, elements: d2.children || [], transitions: l, getTransitionByType: h, getRendererByElement: c, eventHandler: u }, r));
      }
      for (let S2 of T2) {
        let A2 = c(S2.next), R2 = d2.width || 0, F2 = d2.height || 0, W2 = x2 * R2, X = b * F2, D = f.anchorX ?? 0, k2 = f.anchorY ?? 0, gt2 = f.width || 0, j2 = f.height || 0, xt2 = D * gt2, te2 = k2 * j2, nr2 = { ...S2.prev, x: (S2.prev.x || 0) + xt2, y: (S2.prev.y || 0) + te2 }, ar2 = { ...S2.next, x: (S2.next.x || 0) + W2, y: (S2.next.y || 0) + X };
        y.push(A2.update(t, { parent: m, prevElement: nr2, nextElement: ar2, elements: d2.children || [], transitions: l, getTransitionByType: h, getRendererByElement: c, eventHandler: u }, r));
      }
      d2.children && d2.children.length > 0 && m.children.sort((S2, A2) => {
        let R2 = d2.children.find((W2) => W2.id === S2.label), F2 = d2.children.find((W2) => W2.id === A2.label);
        if (R2 && F2) {
          let W2 = R2.zIndex ?? 0, X = F2.zIndex ?? 0;
          if (W2 !== X) return W2 - X;
          let D = d2.children.indexOf(R2), k2 = d2.children.indexOf(F2);
          return D - k2;
        }
        if (!R2 && !F2) return 0;
        if (!R2) return -1;
        if (!F2) return 1;
      }), await Promise.all(y);
      let { width: w, height: C } = this.getContainerDimensions(d2, m), G2 = x2 * w, M2 = b * C;
      m.pivot.x = G2, m.pivot.y = M2;
    };
    layoutChildren({ element: t, anchor: e, totalWidth: r, totalHeight: s, gap: o, direction: n, scroll: a }) {
      let c = n === "horizontal", l = c ? "x" : "y", h = c ? "y" : "x", u = c ? "width" : "height", f = c ? "height" : "width", d2 = c ? r : s, m = c ? s : r, g = c ? e.x : e.y, x2 = c ? e.y : e.x;
      if (!a && t[u] !== void 0 && t[u] < d2) {
        let y = 0, v = 0, T2 = 0, P = 0;
        (t.children || []).forEach((w, C) => {
          y > 0 && y + w[u] > t[u] && (this.alignRowElements(t.children.slice(P, C), l, g, t[u]), y = 0, v += T2 + o, T2 = 0, P = C), w[l] = y, w[h] = v, y += w[u], C < t.children.length - 1 && (y += o), T2 = Math.max(T2, w[f] || 0);
        }), P < t.children.length && this.alignRowElements(t.children.slice(P), l, g, t[u]);
      } else {
        if (g === 0) {
          let y = 0;
          (t.children || []).forEach((v, T2) => {
            let P = v[u] || 0, w = c ? v.anchorX || 0 : v.anchorY || 0;
            v[l] = y + P * w, y += P, T2 < t.children.length - 1 && (y += o);
          });
        } else if (g === 1) {
          let y = -d2;
          (t.children || []).forEach((v, T2) => {
            let P = v[u] || 0, w = c ? v.anchorX || 0 : v.anchorY || 0;
            v[l] = y + P * w, y += P, T2 < t.children.length - 1 && (y += o);
          });
        } else if (g === 0.5) {
          let y = -d2 / 2;
          (t.children || []).forEach((v, T2) => {
            let P = v[u] || 0, w = c ? v.anchorX || 0 : v.anchorY || 0;
            v[l] = y + P * w, y += P, T2 < t.children.length - 1 && (y += o);
          });
        }
        x2 === 0 ? (t.children || []).forEach((y) => {
          let v = y[f] || 0, T2 = c ? y.anchorY || 0 : y.anchorX || 0;
          y[h] = v * T2;
        }) : x2 === 0.5 ? (t.children || []).forEach((y) => {
          let v = y[f] || 0, T2 = c ? y.anchorY || 0 : y.anchorX || 0;
          y[h] = -v / 2 + v * T2;
        }) : x2 === 1 && (t.children || []).forEach((y) => {
          let v = y[f] || 0, T2 = c ? y.anchorY || 0 : y.anchorX || 0;
          y[h] = -v + v * T2;
        });
      }
    }
    alignRowElements(t, e, r, s) {
      if (!t.length) return;
      let o = t.reduce((n, a, c) => n + a[e === "x" ? "width" : "height"] + (c > 0, 0), 0);
      if (r === 0.5) {
        let a = (s - o) / 2;
        t.forEach((c) => {
          c[e] = a, a += c[e === "x" ? "width" : "height"] + 0;
        });
      } else if (r === 1) {
        let a = s - o;
        t.forEach((c) => {
          c[e] = a, a += c[e === "x" ? "width" : "height"] + 0;
        });
      }
    }
    createContainerGraphic(t, e, r, s) {
      let o = new Xt2().roundRect(0, 0, e, r, 1).fill(t.fill ? t.fill.color : "transparent");
      return s.x === 1 && (o.x -= t.width), s.x === 0.5 && (o.x -= t.width / 2), s.y === 1 && (o.y -= t.height), s.y === 0.5 && (o.y -= t.height / 2), o;
    }
    getContainerDimensions(t, e) {
      let r = t.width || 0, s = t.height || 0;
      if (!t.direction && (!t.width || !t.height) && e.children && e.children.length > 0) {
        let o = 1 / 0, n = -1 / 0, a = 1 / 0, c = -1 / 0;
        e.children.forEach((l) => {
          let h = l.x || 0, u = l.y || 0, f = l.width || 0, d2 = l.height || 0;
          o = Math.min(o, h), n = Math.max(n, h + f), a = Math.min(a, u), c = Math.max(c, u + d2);
        }), t.width || (r = n - o, (isNaN(r) || !isFinite(r)) && (r = 0)), t.height || (s = c - a, (isNaN(s) || !isFinite(s)) && (s = 0));
      }
      return { width: r, height: s };
    }
    setupScrolling({ container: t, element: e, totalHeight: r, totalWidth: s, eventHandler: o, sliderRef: n }) {
      let a = e.scroll && e.height && r > e.height, c = e.scroll && e.width && s > e.width;
      if (a || c) {
        let l = 0, h = 0, u = -r + e.height, f = -s + e.width, d2 = new Xt2().rect(0, 0, e.width || s, e.height || r).fill("red");
        t.mask = d2, t.eventMode = "static", t.addChild(d2), t.on("wheel", (m) => {
          if (a && m.deltaY !== 0 && (l - m.deltaY > 0 || l - m.deltaY < u || (l -= m.deltaY, t.y -= m.deltaY, d2.y += m.deltaY)), c && (m.deltaX !== 0 || m.shiftKey && m.deltaY !== 0)) {
            let g = m.deltaX !== 0 ? m.deltaX : m.deltaY;
            if (h - g > 0 || h - g < f) return;
            h -= g, t.x -= g, d2.x += g;
          }
        });
      }
    }
  };
  var Yw = { linear: (i3) => i3 };
  var $w = (i3, t, e, r) => i3 + (t - i3) * Yw[r](e);
  function b0(i3, t, e) {
    typeof t == "string" && (t = t.split("."));
    let r = i3;
    for (let s of t) {
      if (r == null) return e;
      r = r[s];
    }
    return r === void 0 ? e : r;
  }
  function v0(i3, t, e) {
    typeof t == "string" && (t = t.split("."));
    let r = i3;
    for (let s = 0; s < t.length - 1; s++) {
      let o = t[s];
      o in r || (r[o] = {}), r = r[o];
    }
    return r[t[t.length - 1]] = e, i3;
  }
  var jw = (i3, t) => {
    let e = [], r = 0, s;
    i3.forEach(({ value: n, duration: a, easing: c, relative: l }, h) => {
      h === 0 ? (s = n, e.push({ time: r, value: n, easing: "linear" })) : a !== void 0 && c !== void 0 && (r += a, l ? s = s + n : s = n, e.push({ time: r, value: s, easing: c }));
    });
    let o = 0;
    for (let n = 0; n < e.length - 1; n++) {
      let { time: a, value: c, easing: l } = e[n], { time: h, value: u } = e[n + 1];
      if (t >= a && t <= h) {
        let f = (t - a) / (h - a);
        o = $w(c, u, f, l);
        break;
      } else t > h && (o = u);
    }
    return o;
  };
  function Kw(i3) {
    return Math.max.apply(null, i3);
  }
  var Du = class {
    static rendererName = "pixi";
    rendererName = "pixi";
    transitionType = "keyframes";
    _transition = async (t, e, r, s) => new Promise((o, n) => {
      if (s?.aborted) {
        n(new DOMException("Operation aborted", "AbortError"));
        return;
      }
      let { properties: a } = r, c = Array.isArray(a) ? a : Object.entries(a).map(([x2, b]) => ({ ...b, property: x2 })), l = c.map((x2) => x2.keyframes.reduce((b, y) => b + y.duration || 0, 0)), h = Kw(l), u = 0, f = {};
      c.forEach((x2) => {
        f[x2.property] = b0(e, x2.property);
      });
      let d2 = (x2) => {
        let b = {};
        c.forEach((y) => {
          let v = [];
          y.initialValue !== void 0 ? v = [{ value: y.initialValue, duration: 0 }] : v = [{ value: f[y.property], duration: 0 }], v = v.concat(y.keyframes), v0(b, y.property, jw(v, x2));
        }), c.forEach((y) => {
          let { property: v } = y;
          e && !e.destroyed && v0(e, v, b0(b, v));
        });
      }, m = () => {
        t.ticker.remove(g), d2(h);
      };
      s && s.addEventListener("abort", () => {
        m(), n(new DOMException("Operation aborted", "AbortError"));
      });
      let g = (x2) => {
        if (u += x2.deltaMS, u >= h) {
          t.ticker.remove(g), o();
          return;
        }
        d2(u);
      };
      if (s?.aborted) {
        m(), n(new DOMException("Operation aborted", "AbortError"));
        return;
      }
      t.ticker.add(g);
    });
    add = async (t, e, r, s) => this._transition(t, e, r, s);
    remove = async (t, e, r, s) => this._transition(t, e, r, s);
  };
  var Ou = class {
    static rendererName = "pixi";
    rendererName = "pixi";
    rendererType = "rect";
    add = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, element: o, transitions: n = [], getTransitionByType: a, eventHandler: c } = e, l = new Xt2();
      l.label = o.id, l.interactiveChildren = false, l.eventMode = "none", o.x !== void 0 && (l.x = o.x), o.y !== void 0 && (l.y = o.y), o.alpha !== void 0 && (l.alpha = o.alpha), o.scaleX !== void 0 && (l.scale.x = o.scaleX), o.scaleY !== void 0 && (l.scale.y = o.scaleY), o.rotation !== void 0 && (l.rotation = o.rotation * Math.PI / 180), o.cursor && (l.cursor = o.cursor), o.pointerDown && l.on("pointerdown", (d2) => {
        d2.stopPropagation(), c && c(o.pointerDown, { x: d2.global.x, y: d2.global.y });
      }), o.pointerUp && l.on("pointerup", (d2) => {
        d2.stopPropagation(), c && c(o.pointerUp, { x: d2.global.x, y: d2.global.y });
      }), o.pointerMove && l.on("pointermove", (d2) => {
        d2.stopPropagation(), c && c(o.pointerMove, { x: d2.global.x, y: d2.global.y });
      }), (o.cursor || o.pointerDown || o.pointerUp || o.pointerMove) && (l.eventMode = "static");
      let h = o.width, u = o.height;
      l.roundRect(0, 0, h, u, o.radius ?? 0), o.fill && l.fill(o.fill), o.border && l.stroke({ width: o.border.width, color: o.border.color, alpha: o.border.alpha ?? 1, alignment: o.border.alignment ?? 1 }), o.anchorX !== void 0 && (l.pivot.x = h * o.anchorX), o.anchorY !== void 0 && (l.pivot.y = u * o.anchorY), (o.clickEventName || o.rightClickEventName) && c && (l.eventMode = "static", l.on("pointerup", (d2) => {
        d2.stopPropagation(), d2.button === 0 ? c(o.clickEventName, o.clickEventPayload) : d2.button === 2 && c(o.rightClickEventName, o.rightClickEventPayload);
      })), o.wheelEventName && c && (l.eventMode = "static", l.on("wheel", (d2) => {
        d2.stopPropagation(), c(o.wheelEventName, { deltaY: d2.deltaY });
      }));
      let f = [];
      for (let d2 of n) if (d2.elementId === o.id && d2.event === Rt2.Add) {
        let m = a(d2.type);
        if (!m) throw new Error(`Transition class not found for type ${d2.type}`);
        f.push(m.add(t, l, d2, r));
      }
      s.addChild(l), await Promise.all(f);
    };
    remove = async (t, e, r) => {
      if (r?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let { parent: s, element: o, transitions: n = [], getTransitionByType: a } = e, c = s.getChildByName(o.id);
      if (!c) throw new Error(`Rect with id ${o.id} not found`);
      let l = [];
      for (let h of n) if (h.elementId === o.id && h.event === Rt2.Remove) {
        let u = a(h.type);
        if (!u) throw new Error(`Transition class not found for type ${h.type}`);
        l.push(u.remove(t, c, h, r));
      }
      await Promise.all(l), c && c.destroy();
    };
    update = async (t, { parent: e, prevElement: r, nextElement: s, transitions: o = [], getTransitionByType: n, eventHandler: a }, c) => {
      if (c?.aborted) throw new DOMException("Operation aborted", "AbortError");
      let l = e.getChildByName(r.id);
      if (!l) throw new Error(`Rect with id ${r.id} not found`);
      let h = [];
      for (let u of o) if (u.elementId === r.id && u.event === Rt2.Update) {
        let f = n(u.type);
        if (!f) throw new Error(`Transition class not found for type ${u.type}`);
        h.push(f.add(t, l, u, c));
      }
      if (h.length > 0) await Promise.all(h), (r.width !== s.width || r.height !== s.height || r.fill !== s.fill) && (l.clear(), l.rect(0, 0, s.width, s.height), l.fill(s.fill)), r.anchorX !== void 0 && s.anchorX !== r.anchorX && (l.pivot.x = s.width * s.anchorX), r.anchorY !== void 0 && s.anchorY !== r.anchorY && (l.pivot.y = s.height * s.anchorY);
      else {
        r.x !== void 0 && s.x !== r.x && (l.x = s.x), r.y !== void 0 && s.y !== r.y && (l.y = s.y), r.alpha !== void 0 && s.alpha !== r.alpha && (l.alpha = s.alpha), r.scaleX !== void 0 && s.scaleX !== r.scaleX && (l.scale.x = s.scaleX), r.scaleY !== void 0 && s.scaleY !== r.scaleY && (l.scale.y = s.scaleY), r.rotation !== void 0 && s.rotation !== r.rotation && (l.rotation = s.rotation * Math.PI / 180);
        let u = JSON.stringify(r.border) !== JSON.stringify(s.border);
        (r.width !== s.width || r.height !== s.height || r.radius !== s.radius || r.fill !== s.fill || u) && (l.clear(), l.roundRect(0, 0, s.width, s.height, s.radius ?? 0), s.fill && l.fill(s.fill), s.border && l.stroke({ width: s.border.width, color: s.border.color, alpha: s.border.alpha ?? 1, alignment: s.border.alignment ?? 1 })), r.anchorX !== void 0 && s.anchorX !== r.anchorX && (l.pivot.x = s.width * s.anchorX), r.anchorY !== void 0 && s.anchorY !== r.anchorY && (l.pivot.y = s.height * s.anchorY);
      }
    };
  };
  var Lu = class extends or2 {
    static rendererName = "pixi";
    rendererName = "pixi";
    rendererType = "slider";
    add = async (t, { parent: e, element: r, transitions: s = [], getTransitionByType: o, eventHandler: n, ref: a }) => {
      let { direction: c, idleThumb: l, hoverThumb: h, idleBar: u, hoverBar: f, dragEndEventName: d2, dragEventName: m, dragEventPayload: g, initialValue: x2 } = r, b = { horizontal: { axis: "x", size: "width" }, vertical: { axis: "y", size: "height" } }, y = b[c].axis, v = b[c].size, T2 = B.from(l), P = B.from(h), w = B.from(u), C = B.from(f), G2 = new Ft2({ texture: w, anchor: { x: 0, y: 0 } });
      G2.label = r.id;
      let M2 = G2[v];
      G2.x = r.x || 0, G2.y = r.y || 0;
      let S2 = new Ft2({ texture: T2, anchor: { x: 0.5, y: 0.5 } });
      if (S2.y = G2.height / 2, S2.x = G2.width / 2, S2.eventMode = "static", S2.cursor = "hover", G2.eventMode = "static", G2.cursor = "hover", S2.on("pointerdown", F2).on("pointerup", W2).on("pointerupoutside", W2), G2.on("pointerdown", A2).on("pointerup", R2).on("pointerupoutside", R2), G2.addChild(S2), x2 !== void 0) {
        let k2 = S2[v] / 2;
        S2[y] = x2 / 100 * (M2 - S2[v]) + k2;
      }
      function A2(k2) {
        S2.texture = P, G2.texture = C, X(k2), t.stage.eventMode = "static", t.stage.addEventListener("pointermove", X);
      }
      function R2(k2) {
        S2.texture = T2, G2.texture = w, X(k2), t.stage.eventMode = "auto", t.stage.removeEventListener("pointermove", X);
      }
      function F2(k2) {
        k2.stopPropagation(), S2.texture = P, G2.texture = C, t.stage.eventMode = "static", t.stage.addEventListener("pointermove", X);
      }
      function W2(k2) {
        if (S2.texture = T2, G2.texture = w, t.stage.eventMode = "auto", t.stage.removeEventListener("pointermove", X), d2) {
          let gt2 = G2.toLocal(k2.global)[y], j2 = S2[v] / 2;
          S2[y] = Math.max(0 + j2, Math.min(gt2, M2 - j2));
          let xt2 = Math.floor((S2[y] - j2) / (M2 - S2[v]) * 100), te2 = JSON.stringify(g);
          n && n(d2, JSON.parse(te2.replace('"{{ value }}"', String(xt2))));
        }
      }
      function X(k2) {
        let gt2 = G2.toLocal(k2.global)[y], j2 = S2[v] / 2;
        S2[y] = Math.max(0 + j2, Math.min(gt2, M2 - j2));
        let xt2 = Math.floor((S2[y] - j2) / (M2 - S2[v]) * 100);
        if (m) {
          let te2 = JSON.stringify(g);
          n && n(m, JSON.parse(te2.replace('"{{ value }}"', String(xt2))));
        }
        return xt2;
      }
      a && (a.current = { updateValue: (k2) => {
        let gt2 = S2[v] / 2;
        S2[y] = k2 / 100 * (M2 - S2[v]) + gt2;
      } });
      let D = [];
      for (let k2 of s) if (k2.elementId === r.id && k2.event === Rt2.Add) {
        let gt2 = o(k2.type);
        if (!gt2) throw new Error(`Transition class not found for type ${k2.type}`);
        D.push(gt2.add(t, G2, k2));
      }
      e.addChild(G2), await Promise.all(D);
    };
    remove = async (t, e) => {
      let { parent: r, element: s, transitions: o = [], getTransitionByType: n } = e, a = r.getChildByName(s.id);
      if (!a) {
        console.warn(`Sprite with id ${s.id} not found`);
        return;
      }
      let c = [];
      for (let l of o) if (l.elementId === s.id && l.event === Rt2.Remove) {
        let h = n(l.type);
        if (!h) throw new Error(`Transition class not found for type ${l.type}`);
        c.push(h.remove(t, a, l));
      }
      await Promise.all(c), a.destroy();
    };
    update = async (t, { parent: e, prevElement: r, nextElement: s, transitions: o, getTransitionByType: n, eventHandler: a }) => {
      if (!e.getChildByName(r.id)) {
        console.warn(`Slider with id ${r.id} not found`, { parent: e });
        return;
      }
      JSON.stringify(r) !== JSON.stringify(s) && await Promise.all([this.remove(t, { parent: e, element: r, transitions: o, getTransitionByType: n, eventHandler: a }), this.add(t, { parent: e, element: s, transitions: o, getTransitionByType: n, eventHandler: a })]);
    };
  };
  var Nu = class extends or2 {
    static rendererName = "pixi";
    rendererName = "pixi";
    rendererType = "audio";
    add = async (t, { parent: e, element: r, transitions: s = [], getTransitionByType: o }) => {
      r.delay ? setTimeout(() => {
        t.audioStage.add({ id: r.id, url: r.url, loop: r.loop ?? false, volume: r.volume ?? 1 });
      }, r.delay) : t.audioStage.add({ id: r.id, url: r.url, loop: r.loop ?? false, volume: r.volume ?? 1 });
    };
    remove = async (t, e) => {
      let { element: r } = e;
      t.audioStage.remove(r.id);
    };
    update = async (t, { parent: e, prevElement: r, nextElement: s, transitions: o, getTransitionByType: n }) => {
      if (r.url !== s.url || r.volume !== s.volume) {
        let a = t.audioStage.getById(r.id);
        a && (a.url = s.url, a.volume = s.volume ?? 1);
      }
    };
  };
  var Hu = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    async load(t) {
      let e = [];
      for (let [r, s] of Object.entries(t)) this.cache.has(r) || e.push([r, s]);
      e.length > 0 && await Promise.all(e.map(async ([r, s]) => {
        let a = { buffer: await (await fetch(s.url)).arrayBuffer(), type: s.type };
        this.cache.set(r, a);
      }));
    }
    getBufferMap() {
      let t = {};
      for (let [e, r] of this.cache.entries()) t[e] = r;
      return t;
    }
    clear() {
      this.cache.clear();
    }
    size() {
      return this.cache.size;
    }
    has(t) {
      return this.cache.has(t);
    }
  };
  var qw = () => new Hu();
  var tj = y0;

  // main.js
  async function parseVNBundle(arrayBuffer) {
    const uint8View = new Uint8Array(arrayBuffer);
    const headerSize = 9 + Number(new DataView(uint8View.buffer, 1, 8).getBigUint64(0));
    const index = JSON.parse(new TextDecoder().decode(uint8View.subarray(9, headerSize)));
    const assets = {};
    let instructions = null;
    for (const [id2, metadata] of Object.entries(index)) {
      const content = uint8View.subarray(metadata.start + headerSize, metadata.end + headerSize + 1);
      if (id2 === "instructions") {
        instructions = JSON.parse(new TextDecoder().decode(content));
      } else {
        const fileType = await fileTypeFromBuffer(content);
        const detectedType = fileType?.mime;
        assets[`file:${id2}`] = {
          url: URL.createObjectURL(new Blob([content], { type: detectedType })),
          type: detectedType,
          size: content.byteLength
        };
      }
    }
    return { assets, instructions };
  }
  var jsonData = js_yaml_default.load(window.yamlContent);
  var init = async () => {
    const response = await fetch("./test.vnbundle");
    if (!response.ok) throw new Error(`Failed to fetch VNBundle: ${response.statusText}`);
    const { assets: vnbundleAssets, instructions: vnbundleInstructions } = await parseVNBundle(await response.arrayBuffer());
    console.log("VNBundle assets:", vnbundleAssets);
    console.log("VNBundle instructions:", vnbundleInstructions);
    const jsonData2 = {
      ...vnbundleInstructions.projectData,
      i18n: {
        defaultPackId: "eklekfjwalefj",
        packs: {
          eklekfjwalefj: {
            label: "English",
            lang: "en",
            keys: {}
          }
        }
      }
    };
    jsonData2.resources.layouts["storyScreenLayout"] = {
      name: "Story Screen Background",
      elements: [
        {
          "id": "story-screen-bg",
          "type": "rect",
          "x": 0,
          "y": 0,
          "width": 1920,
          "height": 1080,
          "fill": "#000000",
          "clickEventName": "system",
          "clickEventPayload": {
            "actions": {
              "nextLine": {}
            }
          }
        }
      ]
    };
    jsonData2.story.scenes["scene-prologue"].sections["section-main"].lines[0].actions.screen = {
      resourceId: "storyScreenLayout",
      resourceType: "layout"
    };
    const assets = vnbundleAssets;
    const assetBufferManager = qw();
    await assetBufferManager.load(assets);
    const assetBufferMap = assetBufferManager.getBufferMap();
    const app = new tj();
    await app.init({
      width: 1920,
      height: 1080,
      assetBufferMap,
      eventHandler: (eventType, payload) => {
        console.log("eventHandler", { eventType, payload });
        if (eventType === "completed") {
          engine.handleEvent({
            payload: {
              actions: {
                handleCompleted: {}
              }
            }
          });
        } else if (eventType === "system") {
          engine.handleEvent({ payload });
        }
      },
      plugins: [
        new ku(),
        new Iu(),
        new Uu(),
        new Fu(),
        new Ou(),
        new Nu(),
        new Lu(),
        new Du()
      ]
    });
    await app.loadAssets(assetBufferMap);
    document.getElementById("canvas").appendChild(app.canvas);
    document.getElementById("canvas").addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });
    const findElementByLabel = (container, targetLabel) => {
      if (container.label === targetLabel) {
        return container;
      }
      if (container.children && container.children.length > 0) {
        for (const child of container.children) {
          const found = findElementByLabel(child, targetLabel);
          if (found) {
            return found;
          }
        }
      }
      return null;
    };
    const captureElement = async (targetLabel) => {
      console.log(`Searching for element with label: ${targetLabel}`);
      const element = findElementByLabel(app._app.stage, targetLabel);
      if (!element) {
        console.error(`Element with label "${targetLabel}" not found`);
        return null;
      }
      console.log(`Found element:`, element);
      const base64 = await app._app.renderer.extract.base64(element);
      const img = new Image();
      img.src = base64;
      await new Promise((resolve) => {
        img.onload = resolve;
      });
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(img.width / 6);
      canvas.height = Math.floor(img.height / 6);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      const resizedBase64 = canvas.toDataURL("image/png");
      console.log(`Image of ${targetLabel} captured (${canvas.width}x${canvas.height})`);
      return resizedBase64;
    };
    const engine = Fi();
    engine.onEvent(({ eventType, payload }) => {
      console.log("onEvent", { eventType, payload });
      if (eventType === "render") {
        app.render(payload);
      }
    });
    engine.init({
      projectData: jsonData2,
      ticker: app._app.ticker,
      captureElement,
      loadAssets: app.loadAssets
    });
  };
  (async () => {
    await init();
  })();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
